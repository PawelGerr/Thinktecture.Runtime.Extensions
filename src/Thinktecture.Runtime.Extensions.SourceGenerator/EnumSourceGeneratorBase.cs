using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Thinktecture
{
   /// <summary>
   /// Base class for source generator for enum-like classes.
   /// </summary>
   public abstract class EnumSourceGeneratorBase : ISourceGenerator
   {
      private static readonly DiagnosticDescriptor _fieldMustBeReadOnly = new("TTRESG001", "Field must be read-only", "The field '{0}' of the class '{1}' must be read-only", nameof(EnumSourceGenerator), DiagnosticSeverity.Error, true);
      private static readonly DiagnosticDescriptor _fieldMustBePublic = new("TTRESG002", "Field must be public", "The field '{0}' of the class '{1}' must be public", nameof(EnumSourceGenerator), DiagnosticSeverity.Error, true);
      private static readonly DiagnosticDescriptor _typeCouldNotBeResolved = new("TTRESG003", "Type could not be resolved", "The type '{0}' could not be resolved", nameof(EnumSourceGenerator), DiagnosticSeverity.Error, true);
      private static readonly DiagnosticDescriptor _multipleIncompatibleEnumInterfaces = new("TTRESG004", "Multiple interfaces with different key types", "The type '{0}' implements multiple interfaces with different key types", nameof(EnumSourceGenerator), DiagnosticSeverity.Error, true);

      /// <inheritdoc />
      public void Initialize(GeneratorInitializationContext context)
      {
         context.RegisterForSyntaxNotifications(() => new EnumSyntaxReceiver());
      }

      /// <inheritdoc />
      public void Execute(GeneratorExecutionContext context)
      {
         var receiver = (EnumSyntaxReceiver)(context.SyntaxReceiver ?? throw new Exception($"Syntax receiver must be of type '{nameof(EnumSyntaxReceiver)}' but found '{context.SyntaxReceiver?.GetType().Name}'."));

         foreach (var enumDeclaration in receiver.Enums)
         {
            var model = context.Compilation.GetSemanticModel(enumDeclaration.TypeDeclarationSyntax.SyntaxTree, true);
            var enumInterface = GetValidEnumInterface(enumDeclaration, context, model);

            if (enumInterface != null)
            {
               var generatedCode = GenerateCode(enumDeclaration, enumInterface, context, model);
               context.AddSource($"{enumDeclaration.TypeDeclarationSyntax.Identifier}_Generated.cs", $@"
// <auto-generated />
#nullable enable

{generatedCode}
");
            }
         }
      }

      protected abstract string GenerateCode(EnumSourceGeneratorState state);

      protected virtual EnumInterfaceInfo? GetValidEnumInterface(
         EnumDeclaration enumDeclaration,
         GeneratorExecutionContext context,
         SemanticModel model)
      {
         if (enumDeclaration is null)
            throw new ArgumentNullException(nameof(enumDeclaration));

         EnumInterfaceInfo? validInterface = null;

         foreach (var enumInterface in enumDeclaration.EnumInterfaces)
         {
            var typeInfo = model.GetTypeInfo(enumInterface).Type;

            if (typeInfo is null)
               continue;

            if (typeInfo.ContainingNamespace.Name != "Thinktecture")
               continue;

            var type = enumInterface.TypeArgumentList.Arguments[0];
            var keyType = model.GetTypeInfo(type).Type;

            if (keyType is null)
            {
               context.ReportDiagnostic(Diagnostic.Create(_typeCouldNotBeResolved,
                                                          type.GetLocation(),
                                                          type));

               return null;
            }

            var candicate = new EnumInterfaceInfo(enumInterface, typeInfo, keyType, typeInfo.Name == "IValidatableEnum");

            if (validInterface == null)
            {
               validInterface = candicate;
            }
            else
            {
               if (!SymbolEqualityComparer.Default.Equals(validInterface.KeyType, candicate.KeyType))
               {
                  context.ReportDiagnostic(Diagnostic.Create(_multipleIncompatibleEnumInterfaces,
                                                             enumDeclaration.TypeDeclarationSyntax.GetLocation(),
                                                             enumDeclaration.TypeDeclarationSyntax.Identifier));

                  return null;
               }

               if (candicate.IsValidatable)
                  validInterface = candicate;
            }
         }

         return validInterface;
      }

      private string GenerateCode(
         EnumDeclaration enumDeclaration,
         EnumInterfaceInfo enumInterfaceInfo,
         GeneratorExecutionContext context,
         SemanticModel model)
      {
         var classTypeInfo = model.GetDeclaredSymbol(enumDeclaration.TypeDeclarationSyntax);

         if (classTypeInfo is null)
            return String.Empty;

         var items = GetItems(enumDeclaration, context, model, classTypeInfo);
         var state = new EnumSourceGeneratorState(context, model, enumDeclaration, classTypeInfo, enumInterfaceInfo, items);

         return GenerateCode(state);
      }

      private static IReadOnlyList<FieldDeclarationSyntax> GetItems(
         EnumDeclaration enumDeclaration,
         GeneratorExecutionContext context,
         SemanticModel model,
         INamedTypeSymbol classTypeInfo)
      {
         return enumDeclaration.TypeDeclarationSyntax.Members
                               .Select(m =>
                                       {
                                          if (m.IsStatic() && m is FieldDeclarationSyntax fds)
                                          {
                                             var fieldTypeInfo = model.GetTypeInfo(fds.Declaration.Type).Type;

                                             if (SymbolEqualityComparer.Default.Equals(fieldTypeInfo, classTypeInfo))
                                             {
                                                if (!m.IsPublic())
                                                {
                                                   context.ReportDiagnostic(Diagnostic.Create(_fieldMustBePublic,
                                                                                              fds.GetLocation(),
                                                                                              fds.Declaration.Variables[0].Identifier,
                                                                                              enumDeclaration.TypeDeclarationSyntax.Identifier));
                                                   return null;
                                                }

                                                if (!m.IsReadOnly())
                                                {
                                                   context.ReportDiagnostic(Diagnostic.Create(_fieldMustBeReadOnly,
                                                                                              fds.GetLocation(),
                                                                                              fds.Declaration.Variables[0].Identifier,
                                                                                              enumDeclaration.TypeDeclarationSyntax.Identifier));

                                                   return null;
                                                }

                                                return fds;
                                             }
                                          }

                                          return null;
                                       })
                               .Where(fds => fds is not null)
                               .ToList()!;
      }
   }
}
