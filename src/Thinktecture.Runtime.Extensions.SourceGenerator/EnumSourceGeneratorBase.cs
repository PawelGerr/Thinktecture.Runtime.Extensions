using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Thinktecture
{
   /// <summary>
   /// Base class for source generator for enum-like classes.
   /// </summary>
   public abstract class EnumSourceGeneratorBase : ISourceGenerator
   {
      /// <inheritdoc />
      public void Initialize(GeneratorInitializationContext context)
      {
         context.RegisterForSyntaxNotifications(() => new EnumSyntaxReceiver());
      }

      /// <inheritdoc />
      public void Execute(GeneratorExecutionContext context)
      {
         var receiver = (EnumSyntaxReceiver)(context.SyntaxReceiver ?? throw new Exception($"Syntax receiver must be of type '{nameof(EnumSyntaxReceiver)}' but found '{context.SyntaxReceiver?.GetType().Name}'."));

         foreach (var enumDeclaration in receiver.Enums)
         {
            var model = context.Compilation.GetSemanticModel(enumDeclaration.SyntaxTree, true);
            var enumType = model.GetDeclaredSymbol(enumDeclaration);

            if (enumType is null)
               continue;

            if (!enumType.IsEnum(out var enumInterfaces))
               continue;

            if (enumType.ContainingType is not null)
               continue;

            var enumInterface = enumInterfaces.GetValidEnumInterface(enumType);

            if (enumInterface is not null)
            {
               var state = new EnumSourceGeneratorState(model, enumDeclaration, enumType, enumInterface);
               var generatedCode = GenerateCode(state);

               if (!String.IsNullOrWhiteSpace(generatedCode))
               {
                  context.AddSource($"{enumDeclaration.Identifier}_Generated.cs", $@"// <auto-generated />
#nullable enable
{generatedCode}");
               }
            }
         }
      }

      protected abstract string GenerateCode(EnumSourceGeneratorState state);
   }
}
