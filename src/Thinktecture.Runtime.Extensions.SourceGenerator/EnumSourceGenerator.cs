using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Thinktecture
{
   /// <summary>
   /// Source generator for <see cref="Thinktecture.IEnum{TEnum}"/>.
   /// </summary>
   [Generator]
   public class EnumSourceGenerator : ISourceGenerator
   {
      private static readonly DiagnosticDescriptor _classMustBePartial = new("TTRE001", "Class must be partial", "The class '{0}' must be partial", nameof(EnumSourceGenerator), DiagnosticSeverity.Error, true);
      private static readonly DiagnosticDescriptor _fieldMustBeReadOnly = new("TTRE002", "Field must be read-only", "The field '{0}' of the class '{1}' must be read-only", nameof(EnumSourceGenerator), DiagnosticSeverity.Error, true);

      /// <inheritdoc />
      public void Initialize(GeneratorInitializationContext context)
      {
         context.RegisterForSyntaxNotifications(() => new EnumSyntaxReceiver());
      }

      /// <inheritdoc />
      public void Execute(GeneratorExecutionContext context)
      {
         var receiver = (EnumSyntaxReceiver)(context.SyntaxReceiver ?? throw new Exception($"Syntax receiver must be of type '{nameof(EnumSyntaxReceiver)}' but found '{context.SyntaxReceiver?.GetType().Name}'."));

         foreach (var enumDeclaration in receiver.Enums)
         {
            var model = context.Compilation.GetSemanticModel(enumDeclaration.ClassDeclarationSyntax.SyntaxTree, true);

            if (IsValid(enumDeclaration, context, model))
            {
               var generatedCode = GenerateCode(enumDeclaration, context, model);
               context.AddSource($"{enumDeclaration.ClassDeclarationSyntax.Identifier}_Generated.cs", generatedCode);
            }
         }
      }

      private static bool IsValid(
         EnumDeclaration enumDeclaration,
         GeneratorExecutionContext context,
         SemanticModel model)
      {
         var typeInfo = model.GetTypeInfo(enumDeclaration.BaseType).Type;

         if (typeInfo is null)
            return false;

         if (typeInfo.ContainingNamespace.Name != "Thinktecture")
            return false;

         if (!enumDeclaration.ClassDeclarationSyntax.IsPartial())
         {
            context.ReportDiagnostic(Diagnostic.Create(_classMustBePartial,
                                                       enumDeclaration.ClassDeclarationSyntax.GetLocation(),
                                                       enumDeclaration.ClassDeclarationSyntax.Identifier));
            return false;
         }

         return true;
      }

      private static string GenerateCode(
         EnumDeclaration enumDeclaration,
         GeneratorExecutionContext context,
         SemanticModel model)
      {
         var classTypeInfo = model.GetDeclaredSymbol(enumDeclaration.ClassDeclarationSyntax);

         if (classTypeInfo is null)
            return String.Empty;

         var ns = classTypeInfo.ContainingNamespace.ToString();
         var keyType = GetKeyType(enumDeclaration.BaseType, model, out var isKeyARefType);
         var enumType = enumDeclaration.ClassDeclarationSyntax.Identifier;
         var items = GetItems(enumDeclaration, context, model, classTypeInfo);
         var nullableQuestionMark = context.Compilation.Options.NullableContextOptions == NullableContextOptions.Disable ? null : "?";
         var nullableQuestionMarkKey = isKeyARefType ? nullableQuestionMark : null;
         var enumSettings = enumDeclaration.ClassDeclarationSyntax.AttributeLists.SelectMany(a => a.Attributes).FirstOrDefault(a => model.GetTypeInfo(a).Type?.ToString() == "Thinktecture.EnumGenerationAttribute");
         var keyComparerMember = GetKeyComparerMember(enumSettings, out var needsDefaultComparer);

         var sb = new StringBuilder($@"// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

{(String.IsNullOrWhiteSpace(ns) ? null : $"namespace {ns}")}
{{
   public class {enumType}_EnumTypeConverter : Thinktecture.EnumTypeConverter<{enumType}, {keyType}>
   {{
      [return: NotNullIfNotNull(""key"")]
      protected override {enumType}{nullableQuestionMark} ConvertFrom({keyType}{nullableQuestionMarkKey} key)
      {{
         return {enumType}.Get(key);
      }}
   }}

   [System.ComponentModel.TypeConverter(typeof({enumDeclaration.ClassDeclarationSyntax.Identifier}_EnumTypeConverter))]
   partial class {enumType} : IEquatable<{enumType}{nullableQuestionMark}>
   {{");

         if (needsDefaultComparer)
         {
            var defaultComparer = IsString(keyType) ? "StringComparer.OrdinalIgnoreCase" : $"EqualityComparer<{keyType}>.Default";

            sb.Append($@"
      private static readonly IEqualityComparer<{keyType}> _defaultKeyComparerMember = {defaultComparer};
");
         }

         sb.Append($@"
      private static IReadOnlyDictionary<{keyType}, {enumType}>{nullableQuestionMark} _itemsLookup;
      private static IReadOnlyDictionary<{keyType}, {enumType}> ItemsLookup => _itemsLookup ??= GetLookup();

      private static IReadOnlyList<{enumType}>{nullableQuestionMark} _items;
      private static IReadOnlyList<{enumType}> Items => _items ??= ItemsLookup.Values.ToList().AsReadOnly();

      /// <inheritdoc />
      object IEnum.Key => Key;

      /// <summary>
      /// The key of the enumeration item.
      /// </summary>
      [NotNull]
      public {keyType} Key {{ get; }}

      /// <inheritdoc />
      public bool IsValid {{ get; init; }}

      private {enumType}({keyType} key)
      {{");

         if (isKeyARefType)
         {
            sb.Append(@"
        if (key is null)
            throw new ArgumentNullException(nameof(key));
");
         }

         sb.Append($@"
         Key = key;
         IsValid = true;
      }}

      /// <inheritdoc />
      public void EnsureValid()
      {{
         if (!IsValid)
            throw new InvalidOperationException($""The current enumeration item of type '{enumType}' with key {{Key}} is not valid."");
      }}

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      /// <returns>A collection with all valid items.</returns>
      public static IReadOnlyList<{enumType}> GetAll()
      {{
         return Items;
      }}

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The key to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""{enumType}"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      [return: NotNullIfNotNull(""key"")]
      public static {enumType}{nullableQuestionMark} Get([AllowNull] {keyType} key)
      {{");

         if (isKeyARefType)
         {
            sb.Append(@"
        if (key is null)
            return null;
");
         }

         sb.Append($@"
         if (!ItemsLookup.TryGetValue(key, out var item))
            item = new {enumType}(key) {{ IsValid = false }};

         return item;
      }}

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The key to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""{enumType}""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([AllowNull] {keyType} key, [MaybeNullWhen(false)] out {enumType} item)
      {{");

         if (isKeyARefType)
         {
            sb.Append(@"
         if (key is null)
         {{
            item = default;
            return false;
         }}
");
         }

         sb.Append($@"
         return ItemsLookup.TryGetValue(key, out item);
      }}

      /// <summary>
      /// Implicit conversion to the type of <typeparamref name=""TKey""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""Key""/> of provided <paramref name=""item""/> or <c>null</c> if a<paramref name=""item""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""item"")]
      public static implicit operator {keyType}{nullableQuestionMarkKey}({enumType}{nullableQuestionMark} item)
      {{
         return item is null ? default : item.Key;
      }}

      /// <summary>
      /// Compares to instances of <see cref=""{enumType}""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==({enumType}{nullableQuestionMark} item1, {enumType}{nullableQuestionMark} item2)
      {{
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""{enumType}""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=({enumType}{nullableQuestionMark} item1, {enumType}{nullableQuestionMark} item2)
      {{
         return !(item1 == item2);
      }}

      /// <inheritdoc />
      public bool Equals({enumType}{nullableQuestionMark} other)
      {{
         if (other is null)
            return false;
         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;
         if (ReferenceEquals(this, other))
            return true;

         // valid items are ""ReferenceEquals"" so if we are here
         // then one of the items are valid the other is not.
         if (IsValid || other.IsValid)
            return false;

         return {keyComparerMember}.Equals(Key, other.Key);
      }}

      /// <inheritdoc />
      public override bool Equals(object? otherEnum)
      {{
         return Equals(otherEnum as {enumType});
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return GetType().GetHashCode() * 397 ^ {keyComparerMember}.GetHashCode(Key);
      }}

      /// <inheritdoc />
      public override string{nullableQuestionMark} ToString()
      {{
         return Key.ToString();
      }}

      private static IReadOnlyDictionary<{keyType}, {enumType}> GetLookup()
      {{
         var items = new {enumType}[] {{ {String.Join(", ", items.Select(i => i.Declaration.Variables[0].Identifier))} }};
         var lookup = new Dictionary<{keyType}, {enumType}>({keyComparerMember});

         foreach (var item in items)
         {{
            if(!item.IsValid)
               throw new ArgumentException(""All 'public static readonly' fields of type \""{enumType}\"" must be valid but the item with the key \""{{item.Key}}\"" is not."");

            if (lookup.ContainsKey(item.Key))
               throw new ArgumentException($""The type \""{enumType}\"" has multiple items with the key \""{{item.Key}}\""."");

            lookup.Add(item.Key, item);
         }}

         return lookup;
      }}
   }}
}}
");

         return sb.ToString();
      }

      private static string GetKeyComparerMember(AttributeSyntax? enumSettingsAttribute, out bool needsDefaultComparer)
      {
         var keyComparer = enumSettingsAttribute?.ArgumentList?.Arguments.FirstOrDefault(a => a.NameEquals?.Name.Identifier.ToString() == "KeyComparerProvidingMember");

         if (keyComparer is { Expression: LiteralExpressionSyntax les })
         {
            if (!String.IsNullOrWhiteSpace(les.Token.ValueText))
            {
               needsDefaultComparer = false;
               return les.Token.ValueText;
            }
         }

         needsDefaultComparer = true;
         return "_defaultKeyComparerMember";
      }

      private static bool IsString(ITypeSymbol? keyType)
      {
         return keyType?.ContainingNamespace.Name == "System" && keyType?.Name == "String";
      }

      private static IReadOnlyList<FieldDeclarationSyntax> GetItems(
         EnumDeclaration enumDeclaration,
         GeneratorExecutionContext context,
         SemanticModel model,
         INamedTypeSymbol classTypeInfo)
      {
         return enumDeclaration.ClassDeclarationSyntax.Members
                               .Select(m =>
                                       {
                                          if (m.IsStatic() && m.IsPublic() && m is FieldDeclarationSyntax fds)
                                          {
                                             var fieldTypeInfo = model.GetTypeInfo(fds.Declaration.Type).Type;

                                             if (SymbolEqualityComparer.Default.Equals(fieldTypeInfo, classTypeInfo))
                                             {
                                                if (m.IsReadOnly())
                                                   return fds;

                                                context.ReportDiagnostic(Diagnostic.Create(_fieldMustBeReadOnly,
                                                                                           fds.GetLocation(),
                                                                                           fds.Declaration.Variables[0].Identifier,
                                                                                           enumDeclaration.ClassDeclarationSyntax.Identifier));
                                             }
                                          }

                                          return null;
                                       })
                               .Where(fds => fds is not null)
                               .ToList()!;
      }

      private static string GetEnumType(EnumDeclaration enumDeclaration, SemanticModel model)
      {
         var typeInfo = model.GetTypeInfo(enumDeclaration.BaseType.TypeArgumentList.Arguments[0]).Type;

         if (typeInfo is null)
            return enumDeclaration.BaseType.TypeArgumentList.Arguments[0].ToString();

         return typeInfo.ToString();
      }

      private static ITypeSymbol? GetKeyType(GenericNameSyntax enumBaseType, SemanticModel model, out bool isRefType)
      {
         var type = enumBaseType.TypeArgumentList.Arguments[0];
         var typeInfo = model.GetTypeInfo(type).Type;
         isRefType = typeInfo?.TypeKind != TypeKind.Struct;

         return typeInfo;
      }
   }

   internal class EnumSyntaxReceiver : ISyntaxReceiver
   {
      public List<EnumDeclaration> Enums { get; }

      public EnumSyntaxReceiver()
      {
         Enums = new List<EnumDeclaration>();
      }

      /// <inheritdoc />
      public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
      {
         if (syntaxNode is ClassDeclarationSyntax cds)
         {
            if (cds.IsAbstract())
               return;

            if (IsEnum(cds, out var enumDeclaration))
               Enums.Add(enumDeclaration);
         }
      }

      private static bool IsEnum(
         ClassDeclarationSyntax cds,
         [MaybeNullWhen(false)] out EnumDeclaration enumDeclaration)
      {
         if (cds.BaseList?.Types.Count > 0)
         {
            foreach (var type in cds.BaseList.Types)
            {
               if (type.Type is GenericNameSyntax genNameSyntax)
               {
                  if (genNameSyntax.Identifier.Text == "IEnum" &&
                      genNameSyntax.TypeArgumentList.Arguments.Count == 1)
                  {
                     enumDeclaration = new EnumDeclaration(cds, genNameSyntax);
                     return true;
                  }
               }
            }
         }

         enumDeclaration = null;
         return false;
      }
   }

   internal class EnumDeclaration
   {
      public ClassDeclarationSyntax ClassDeclarationSyntax { get; }
      public GenericNameSyntax BaseType { get; }

      public EnumDeclaration(
         ClassDeclarationSyntax cds,
         GenericNameSyntax baseType)
      {
         ClassDeclarationSyntax = cds ?? throw new ArgumentNullException(nameof(cds));
         BaseType = baseType ?? throw new ArgumentNullException(nameof(baseType));
      }
   }
}
