using Microsoft.CodeAnalysis;

namespace Thinktecture.CodeAnalysis.SmartEnums;

public sealed class BaseTypeState : IEquatable<BaseTypeState>
{
   public IReadOnlyList<ConstructorState> Constructors { get; }

   public BaseTypeState(
      INamedTypeSymbol type,
      IBaseEnumState? baseEnum)
   {
      Constructors = GetConstructorArguments(type, baseEnum);
   }

   private static IReadOnlyList<ConstructorState> GetConstructorArguments(
      INamedTypeSymbol type,
      IBaseEnumState? baseEnum)
   {
      var ctors = type.Constructors
                      .Where(c => c.MethodKind == MethodKind.Constructor
                                  && c.DeclaredAccessibility is Accessibility.Protected or Accessibility.Public
                                  && (!c.IsImplicitlyDeclared || baseEnum?.IsSameAssembly != true)); // default-ctor will be replaced by ctor implemented by this generator

      var constructors = ctors.Select(ctor =>
                                      {
                                         var parameters = ctor.Parameters
                                                              .Select(p => new DefaultMemberState(p.Name, p.Type, p.Name, false))
                                                              .ToList();

                                         return new ConstructorState(parameters);
                                      })
                              .ToList();

      // add the constructor generated by this source generator
      if (baseEnum is not null && baseEnum.IsSameAssembly)
         constructors.Add(new ConstructorState(baseEnum.ConstructorArguments));

      return constructors;
   }

   public override bool Equals(object? obj)
   {
      return obj is BaseTypeState other && Equals(other);
   }

   public bool Equals(BaseTypeState? other)
   {
      if (ReferenceEquals(null, other))
         return false;
      if (ReferenceEquals(this, other))
         return true;

      return Constructors.EqualsTo(other.Constructors);
   }

   public override int GetHashCode()
   {
      return Constructors.ComputeHashCode();
   }
}
