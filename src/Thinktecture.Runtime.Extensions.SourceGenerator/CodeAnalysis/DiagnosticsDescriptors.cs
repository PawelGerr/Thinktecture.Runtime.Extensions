using Microsoft.CodeAnalysis;
using Thinktecture.CodeAnalysis.Diagnostics;

namespace Thinktecture.CodeAnalysis;

internal static class DiagnosticsDescriptors
{
   public static readonly DiagnosticDescriptor FieldMustBeReadOnly = new("TTRESG001", "Field must be read-only", "The field '{0}' of the type '{1}' must be read-only", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor FieldMustBePublic = new("TTRESG002", "Field must be public", "The field '{0}' of the type '{1}' must be public", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor PropertyMustBeReadOnly = new("TTRESG003", "Property must be read-only", "The Property '{0}' of the type '{1}' must be read-only", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustBeClassOrStruct = new("TTRESG004", "The type must be a class or a struct", "The type '{0}' must be a class or a struct", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor MultipleIncompatibleEnumInterfaces = new("TTRESG005", "Multiple interfaces with different key types", "The type '{0}' implements multiple interfaces with different key types", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustBePartial = new("TTRESG006", "Type must be partial", "The type '{0}' must be partial", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor InvalidSignatureOfCreateInvalidItem = new("TTRESG007", "Incorrect signature of the method 'CreateInvalidItem'", "The signature of the method 'CreateInvalidItem' must be 'private static {0} CreateInvalidItem({1} key)'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor AbstractEnumNeedsCreateInvalidItemImplementation = new("TTRESG008", "An abstract class needs an implementation of the method 'CreateInvalidItem'", "An abstract class needs an implementation of the method 'CreateInvalidItem', the signature should be 'private static {0} CreateInvalidItem({1} key)'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ConstructorsMustBePrivate = new("TTRESG009", "An enumeration must have private constructors only", "All constructors of the enumeration '{0}' must be private", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor NonValidatableEnumsMustBeClass = new("TTRESG010", "An non-validatable enumeration must be a class", "A non-validatable enum must be a class", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor StructMustBeReadOnly = new("TTRESG011", "A struct must be readonly", "A struct must be readonly", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor KeyPropertyNameNotAllowed = new("TTRESG012", "Provided KeyPropertyName is not allowed", "Provided KeyPropertyName '{0}' is not allowed", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor DerivedTypeMustNotImplementEnumInterfaces = new("TTRESG013", "Derived types must not implement IEnum<T> or IValidatableEnum<T>", "Derived type '{0}' must not implement IEnum<T> or IValidatableEnum<T> if a base type implement one of this interfaces already", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor FirstLevelInnerTypeMustBePrivate = new("TTRESG014", "First-level inner types must be private", "Derived type '{0}' must be private", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor NonFirstLevelInnerTypeMustBePublic = new("TTRESG015", "Non-first-level inner types must be public", "Derived type '{0}' must be public", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeCannotBeNestedClass = new("TTRESG016", "The type cannot be a nested class", "The type '{0}' cannot be a nested class", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor KeyMemberShouldNotBeNullable = new("TTRESG017", "The key member should not be nullable", "The key member '{0}' should not be nullable", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ExtensibleEnumMemberMustBePublicOrHaveMapping = new("TTRESG018", "The members of an extensible enumeration must be public or be mapped to another public member with same value/behavior", "The member '{0}' of an extensible enumeration must be public or be mapped to another public member with same value/behavior (use [EnumGenerationMember(MapsToMember = nameof(PublicMember))] for mapping)", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor MemberNotFound = new("TTRESG019", "Member not found", "The member with the name '{0}' not found", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor MultipleMembersWithSameName = new("TTRESG020", "Multiple member with same name found", "Multiple members with the name '{0}' found", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor MappedMemberMustBePublic = new("TTRESG021", "Mapped member must be public", "Mapped member with the name '{0}' must be public", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor MappedMethodMustBeNotBeGeneric = new("TTRESG022", "Mapped method must not be generic", "Mapped method with the name '{0}' must not be generic", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ExtendedEnumCannotBeValidatableIfBaseEnumIsNot = new("TTRESG023", "Type cannot be IValidatableEnum<T> if base enum is IEnum<T>", "Type '{0}' cannot be IValidatableEnum<T> if the base enum is IEnum<T>", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor DerivedEnumMustNotBeExtensible = new("TTRESG024", "Derived enumeration must not be extensible", "Derived enumeration '{0}' cannot be extensible", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor BaseEnumMustBeExtensible = new("TTRESG025", "Base enumeration must not extensible", "Base enumeration '{0}' must be extensible to be able to extend it, that is, to derive from it", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ExtensibleEnumCannotBeStruct = new("TTRESG026", "An extensible enumeration cannot be a struct", "A extensible enumeration '{0}' cannot be a struct", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ExtensibleEnumCannotBeAbstract = new("TTRESG027", "An extensible enumeration cannot be a abstract", "A extensible enumeration '{0}' cannot be abstract", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ExtensibleEnumMustNotHaveVirtualMembers = new("TTRESG028", "An extensible enumeration must not have virtual members", "A extensible enumeration '{0}' must not have virtual members", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor KeyComparerOfExtensibleEnumMustBeProtectedOrPublic = new("TTRESG029", "The key comparer of an extensible enumeration must be protected or public", "The key comparer '{0}' of an extensible enumeration must be protected or public", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor KeyComparerMustBeStaticFieldOrProperty = new("TTRESG030", "The key comparer must a static field or property", "The key comparer '{0}' must be a static field or property", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ComparerApplicableOnKeyMemberOnly = new("TTRESG031", "A comparer is applicable on a key member only", "A comparer like '{0}' is applicable on a key member only", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ExtendedEnumMustHaveSameKeyPropertyName = new("TTRESG032", "Enumeration must have the same key property name as its base class", "Enumeration '{0}' must have the same key property name as its base class '{1}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor EnumsAndValueObjectsMustNotBeGeneric = new("TTRESG033", "Enumerations and value objects must not be generic", "{0} '{1}' must not be generic", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ConstructorsMustBePrivateOrProtected = new("TTRESG034", "An extensible enumeration must have private or protected constructors only", "All constructors of the enumeration '{0}' must be private or protected", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);

   public static readonly DiagnosticDescriptor ErrorDuringGeneration = new("TTRESG099", "Error during code generation", "Error during code generation for '{0}': '{1}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);

   public static readonly DiagnosticDescriptor NoItemsWarning = new("TTRESG100", "The enumeration has no items", "The enumeration '{0}' has no items", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor StaticPropertiesAreNotConsideredItems = new("TTRESG101", "Static properties are not considered enumeration items, use a field instead", "The static property '{0}' is not considered a enumeration item, use a field instead", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
}
