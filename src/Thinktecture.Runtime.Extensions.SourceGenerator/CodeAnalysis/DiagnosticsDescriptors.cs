using Thinktecture.CodeAnalysis.Diagnostics;

namespace Thinktecture.CodeAnalysis;

internal static class DiagnosticsDescriptors
{
   public static readonly DiagnosticDescriptor FieldMustBeReadOnly = new("TTRESG001", "Field must be read-only", "The field '{0}' of the type '{1}' must be read-only", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor SmartEnumItemMustBePublic = new("TTRESG002", "Smart Enum item must be public", "The Smart Enum item '{0}' of the type '{1}' must be public", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor PropertyMustBeReadOnly = new("TTRESG003", "Property must be read-only", "The property '{0}' of the type '{1}' must be read-only", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustBeClassOrStruct = new("TTRESG004", "The type must be a class or a struct", "The type '{0}' must be a class or a struct", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustBePartial = new("TTRESG006", "Type must be partial", "The type '{0}' must be partial", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ConstructorsMustBePrivate = new("TTRESG009", "The constructors must be private", "All constructors of type '{0}' must be private", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor SmartEnumKeyMemberNameNotAllowed = new("TTRESG012", "Provided key member name is not allowed", "Provided key member name '{0}' is not allowed", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor InnerSmartEnumOnFirstLevelMustBePrivate = new("TTRESG014", "Inner Smart Enum on first level must be private", "Derived inner Smart Enum '{0}' on first-level must be private", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor InnerSmartEnumOnNonFirstLevelMustBePublic = new("TTRESG015", "Inner Smart Enum on non-first level must be public", "Derived inner Smart Enum '{0}' on non-first-level must be public", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor KeyMemberShouldNotBeNullable = new("TTRESG017", "The key member must not be nullable", "A key member must not be nullable", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor AdHocUnionsMustNotBeGeneric = new("TTRESG033", "Ad hoc unions must not be generic", "Type '{0}' must not be generic", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor BaseClassFieldMustBeReadOnly = new("TTRESG034", "Field of the base class must be read-only", "The field '{0}' of the base class '{1}' must be read-only", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor BaseClassPropertyMustBeReadOnly = new("TTRESG035", "Property of the base class must be read-only", "The property '{0}' of the base class '{1}' must be read-only", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor SmartEnumKeyShouldNotBeNullable = new("TTRESG036", "The key type must not be nullable", "The generic type T of SmartEnumAttribute<T> must not be nullable", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor SmartEnumWithoutDerivedTypesMustBeSealed = new("TTRESG037", "Smart Enum without derived types must be sealed", "Smart Enum '{0}' without derived types must be sealed", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ComparerTypeMustMatchMemberType = new("TTRESG041", "The type of the comparer doesn't match the type of the member", "The comparer '{0}' doesn't match the member type '{1}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor InitAccessorMustBePrivate = new("TTRESG042", "Property 'init' accessor must be private", "The 'init' accessor of the property '{0}' of the type '{1}' must be private", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor PrimaryConstructorNotAllowed = new("TTRESG043", "Primary constructor is not allowed", "Primary constructor is not allowed in object of type '{0}' because it cannot be marked as 'private'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor CustomKeyMemberImplementationNotFound = new("TTRESG044", "Custom implementation of the key member not found", $"Provide a custom implementation of the key member. Implement a field or property '{{0}}'. Use '{Constants.Attributes.Properties.KEY_MEMBER_NAME}' to change the name.", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor CustomKeyMemberImplementationTypeMismatch = new("TTRESG045", "Key member type mismatch", "The type of the key member '{0}' must be '{2}' instead of '{1}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor IndexBasedSwitchAndMapMustUseNamedParameters = new("TTRESG046", "The arguments of 'Switch' and 'Map' must be named", "Not all arguments of 'Switch/Map' on type '{0}' are named", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor VariableMustBeInitializedWithNonDefaultValue = new("TTRESG047", "Variable must be initialed with non-default value", "Variable of type '{0}' must be initialized with non-default value", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor StringBasedValueObjectNeedsEqualityComparer = new("TTRESG048", "String-based Value Object needs equality comparer", "String-based Value Object needs equality comparer. Use 'KeyMemberEqualityComparerAttribute<TAccessor, TKey>' to define the equality comparer. Example: [KeyMemberEqualityComparer<ComparerAccessors.StringOrdinalIgnoreCase, string>].", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor ComplexValueObjectWithStringMembersNeedsDefaultEqualityComparer = new("TTRESG049", "Complex Value Object with string members needs equality comparer", "Complex Value Object with string members needs equality comparer. Use 'DefaultStringComparison' to define the comparer. Example: [ComplexValueObject(DefaultStringComparison = StringComparison.OrdinalIgnoreCase)].", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor MethodWithUseDelegateFromConstructorMustBePartial = new("TTRESG050", $"Method with '{Constants.Attributes.UseDelegateFromConstructor.NAME}' must be partial", $"The method '{{0}}' with '{Constants.Attributes.UseDelegateFromConstructor.NAME}' must be marked as partial", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor MethodWithUseDelegateFromConstructorMustNotHaveGenerics = new("TTRESG051", $"Method with '{Constants.Attributes.UseDelegateFromConstructor.NAME}' must not have generics", $"The method '{{0}}' with '{Constants.Attributes.UseDelegateFromConstructor.NAME}' must not have generic type parameters. Use inheritance approach instead.", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustNotBeInsideGenericType = new("TTRESG052", "The type must not be inside generic type", "Type '{0}' must not be inside a generic type", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor UnionDerivedTypesMustNotBeGeneric = new("TTRESG053", "Derived type of a union must not be generic", "Derived type '{0}' of a union must not be generic", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor UnionMustBeSealedOrHavePrivateConstructorsOnly = new("TTRESG054", "Discriminated union must be sealed or have private constructors only", "Discriminated union '{0}' must be sealed or have private constructors only", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor UnionRecordMustBeSealed = new("TTRESG055", "Discriminated union implemented using a record must be sealed", "Discriminated union '{0}' using a record must be sealed. Use a class for nesting unions.", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor NonAbstractDerivedUnionIsLessAccessibleThanBaseUnion = new("TTRESG056", "Non-abstract derived union is less accessible than base union", "Non-abstract derived union '{0}' is less accessible than base union '{1}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor AllowDefaultStructsCannotBeTrueIfValueObjectIsStructButKeyTypeIsClass = new("TTRESG057", "'AllowDefaultStructs' must be 'false' if Value Object is a struct but key type is a reference type", "'AllowDefaultStructs' of type '{0}' must be 'false' because it is a struct but the key type '{1}' is a reference type", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor AllowDefaultStructsCannotBeTrueIfSomeMembersDisallowDefaultValues = new("TTRESG058", "'AllowDefaultStructs' must be 'false' if some members disallow default values", "'AllowDefaultStructs' of type '{0}' must be 'false' because following members disallow default values: {1}", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ObjectFactoryMustHaveCorrespondingConstructor = new("TTRESG059", "Type with ObjectFactoryAttribute<T> and 'HasCorrespondingConstructor = true' must have a constructor with type 'T'", "The type '{0}' with 'ObjectFactoryAttribute<{1}>' and 'HasCorrespondingConstructor = true' must have a constructor with a single argument of type '{1}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor SmartEnumMustNotHaveObjectFactoryConstructor = new("TTRESG060", "Smart Enums with ObjectFactoryAttribute<T> must not have 'HasCorrespondingConstructor' set to 'true'", "Smart Enum '{0}' with 'ObjectFactoryAttribute<{1}>' must not have the property 'HasCorrespondingConstructor' set to 'true'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ObjectFactoryMustImplementStaticValidateMethod = new("TTRESG061", "Type with ObjectFactoryAttribute<TValue> must implement static Validate method", "The type '{0}' with 'ObjectFactoryAttribute<{2}>' must implement a static method 'Validate' with signature: static {4}? Validate({1} value, IFormatProvider? provider, out {3} item)", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ObjectFactoryMustImplementToValueMethod = new("TTRESG062", "Type with ObjectFactoryAttribute<TValue> must implement ToValue method when used for serialization or Entity Framework", "The type '{0}' with 'ObjectFactoryAttribute<{1}>' must implement an instance method '{1} ToValue()' because 'UseForSerialization' is not 'None' or 'UseWithEntityFramework' is 'true'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustNotHaveMoreThanOneAttribute = new("TTRESG063", "Type must not have more than one ValueObject/SmartEnum/Union-attribute", "The type '{0}' must not have more than one ValueObject/SmartEnum/Union-attribute", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustNotHaveMoveThanOneSmartEnumAttribute = new("TTRESG064", $"Type must not have more than one {Constants.Attributes.SmartEnum.NAME}", $"The type '{{0}}' must not have more than one {Constants.Attributes.SmartEnum.NAME}", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustNotHaveMoveThanOneValueObjectAttribute = new("TTRESG065", $"Type must not have more than one {Constants.Attributes.ValueObject.KEYED_NAME}/{Constants.Attributes.ValueObject.COMPLEX_NAME}", $"The type '{{0}}' must not have more than one {Constants.Attributes.ValueObject.KEYED_NAME}/{Constants.Attributes.ValueObject.COMPLEX_NAME}", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor TypeMustNotHaveMoveThanOneDiscriminatedUnionAttribute = new("TTRESG066", $"Type must not have more than one {Constants.Attributes.Union.NAME}/{Constants.Attributes.Union.NAME_AD_HOC}", $"The type '{{0}}' must not have more than one {Constants.Attributes.Union.NAME}/{Constants.Attributes.Union.NAME_AD_HOC}", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor AdHocUnionMustHaveAtLeastTwoMemberTypes = new("TTRESG067", "Ad hoc union must define at least two member types", "Ad hoc union '{0}' must have at least two member types", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);

   public static readonly DiagnosticDescriptor ErrorDuringModulesAnalysis = new("TTRESG097", "Error during analysis of referenced modules", "Error during analysis of referenced modules: '{0}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);
   public static readonly DiagnosticDescriptor ErrorDuringCodeAnalysis = new("TTRESG098", "Error during code analysis", "Error during code analysis of '{0}': '{1}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor ErrorDuringGeneration = new("TTRESG099", "Error during code generation", "Error during code generation for '{0}': '{1}'", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Error, true);

   public static readonly DiagnosticDescriptor SmartEnumHasNoItems = new("TTRESG100", "The Smart Enum has no items", "The Smart Enum '{0}' has no items", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor StaticPropertiesAreNotConsideredItems = new("TTRESG101", "Static properties are not considered Smart Enum items, use a field instead", "The static property '{0}' is not considered a Smart Enum item, use a field instead", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor ExplicitComparerWithoutEqualityComparer = new("TTRESG102", "The type has a comparer defined but no equality comparer", "The type '{0}' has a comparer defined but no equality comparer", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor ExplicitEqualityComparerWithoutComparer = new("TTRESG103", "The type has an equality comparer defined but no comparer", "The type '{0}' has an equality comparer defined but no comparer", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor MembersDisallowingDefaultValuesMustBeRequired = new("TTRESG104", "The member must be marked as 'required' to ensure proper initialization", "The {0} '{1}' of type '{2}' must be marked as 'required' to ensure proper initialization", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);
   public static readonly DiagnosticDescriptor ComparisonAndEqualityOperatorsMismatch = new("TTRESG105", "Comparison and equality operators settings mismatch", "The type '{0}' has 'ComparisonOperators = {1}' and 'EqualityComparisonOperators = {2}' which differ. Set them to the same value.", nameof(ThinktectureRuntimeExtensionsAnalyzer), DiagnosticSeverity.Warning, true);

   public static readonly DiagnosticDescriptor InternalApiUsage = new("TTRESG1000", "Internal Thinktecture.Runtime.Extensions API usage", "'{0}' is an internal API that supports the Thinktecture.Runtime.Extensions infrastructure and not subject to the same compatibility standards as public APIs. It may be changed or removed without notice in any release.", nameof(ThinktectureRuntimeExtensionsInternalUsageAnalyzer), DiagnosticSeverity.Warning, true);
}
