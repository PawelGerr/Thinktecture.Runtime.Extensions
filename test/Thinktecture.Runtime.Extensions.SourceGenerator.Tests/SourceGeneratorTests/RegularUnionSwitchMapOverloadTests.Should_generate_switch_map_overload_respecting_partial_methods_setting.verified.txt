// <auto-generated />
#nullable enable

namespace Thinktecture.Tests;

[global::System.Diagnostics.CodeAnalysis.SuppressMessage("ThinktectureRuntimeExtensionsAnalyzer", "TTRESG1000:Internal Thinktecture.Runtime.Extensions API usage")]
abstract partial class TestUnion :
   global::Thinktecture.Internal.IMetadataOwner
{
   static global::Thinktecture.Internal.Metadata global::Thinktecture.Internal.IMetadataOwner.Metadata { get; }
      = new global::Thinktecture.Internal.Metadata.RegularUnion(typeof(global::Thinktecture.Tests.TestUnion))
      {
         TypeMembers = new global::System.Collections.Generic.List<global::System.Type>
                       {
                           typeof(global::Thinktecture.Tests.TestUnion.BaseType),
                           typeof(global::Thinktecture.Tests.TestUnion.ConcreteType1),
                           typeof(global::Thinktecture.Tests.TestUnion.ConcreteType2),
                           typeof(global::Thinktecture.Tests.TestUnion.OtherType)
                       }
                       .AsReadOnly()
      };

   private TestUnion()
   {
   }

   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="concreteType2">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch(
      global::System.Action<global::Thinktecture.Tests.TestUnion.ConcreteType2> @concreteType2,
      global::System.Action<global::Thinktecture.Tests.TestUnion.ConcreteType1> @concreteType1,
      global::System.Action<global::Thinktecture.Tests.TestUnion.OtherType> @otherType)
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
            @concreteType2(value);
            return;
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
            @concreteType1(value);
            return;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            @otherType(value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }

   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="default">The action to execute if no type-specific action is provided.</param>
   /// <param name="concreteType2">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void SwitchPartially(
      global::System.Action<global::Thinktecture.Tests.TestUnion>? @default = null,
      global::System.Action<global::Thinktecture.Tests.TestUnion.ConcreteType2>? @concreteType2 = null,
      global::System.Action<global::Thinktecture.Tests.TestUnion.ConcreteType1>? @concreteType1 = null,
      global::System.Action<global::Thinktecture.Tests.TestUnion.OtherType>? @otherType = null)
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
            if (@concreteType2 is null)
               break;

            @concreteType2(value);
            return;
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
            if (@concreteType1 is null)
               break;

            @concreteType1(value);
            return;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            if (@otherType is null)
               break;

            @otherType(value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      @default?.Invoke(this);
   }

   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="concreteType2">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch<TState>(
      TState @state,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.ConcreteType2> @concreteType2,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.ConcreteType1> @concreteType1,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.OtherType> @otherType)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
            @concreteType2(@state, value);
            return;
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
            @concreteType1(@state, value);
            return;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            @otherType(@state, value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }

   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="default">The action to execute if no type-specific action is provided.</param>
   /// <param name="concreteType2">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void SwitchPartially<TState>(
      TState @state,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion>? @default = null,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.ConcreteType2>? @concreteType2 = null,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.ConcreteType1>? @concreteType1 = null,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.OtherType>? @otherType = null)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
            if (@concreteType2 is null)
               break;

            @concreteType2(@state, value);
            return;
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
            if (@concreteType1 is null)
               break;

            @concreteType1(@state, value);
            return;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            if (@otherType is null)
               break;

            @otherType(@state, value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      @default?.Invoke(@state, this);
   }

   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="concreteType2">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TResult>(
      global::System.Func<global::Thinktecture.Tests.TestUnion.ConcreteType2, TResult> @concreteType2,
      global::System.Func<global::Thinktecture.Tests.TestUnion.ConcreteType1, TResult> @concreteType1,
      global::System.Func<global::Thinktecture.Tests.TestUnion.OtherType, TResult> @otherType)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
            return @concreteType2(value);
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
            return @concreteType1(value);
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            return @otherType(value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }

   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="default">The function to execute if no type-specific action is provided.</param>
   /// <param name="concreteType2">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult SwitchPartially<TResult>(
      global::System.Func<global::Thinktecture.Tests.TestUnion, TResult> @default,
      global::System.Func<global::Thinktecture.Tests.TestUnion.ConcreteType2, TResult>? @concreteType2 = null,
      global::System.Func<global::Thinktecture.Tests.TestUnion.ConcreteType1, TResult>? @concreteType1 = null,
      global::System.Func<global::Thinktecture.Tests.TestUnion.OtherType, TResult>? @otherType = null)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
            if (@concreteType2 is null)
               break;

            return @concreteType2(value);
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
            if (@concreteType1 is null)
               break;

            return @concreteType1(value);
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            if (@otherType is null)
               break;

            return @otherType(value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      return @default(this);
   }

   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="concreteType2">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TState, TResult>(
      TState @state,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.ConcreteType2, TResult> @concreteType2,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.ConcreteType1, TResult> @concreteType1,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.OtherType, TResult> @otherType)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
            return @concreteType2(@state, value);
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
            return @concreteType1(@state, value);
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            return @otherType(@state, value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }

   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="default">The function to execute if no type-specific action is provided.</param>
   /// <param name="concreteType2">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult SwitchPartially<TState, TResult>(
      TState @state,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion, TResult> @default,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.ConcreteType2, TResult>? @concreteType2 = null,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.ConcreteType1, TResult>? @concreteType1 = null,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.OtherType, TResult>? @otherType = null)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
            if (@concreteType2 is null)
               break;

            return @concreteType2(@state, value);
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
            if (@concreteType1 is null)
               break;

            return @concreteType1(@state, value);
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            if (@otherType is null)
               break;

            return @otherType(@state, value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      return @default(@state, this);
   }

   /// <summary>
   /// Maps current instance to an instance of type <typeparamref name="TResult"/>.
   /// </summary>
   /// <param name="concreteType2">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Map<TResult>(
      TResult @concreteType2,
      TResult @concreteType1,
      TResult @otherType)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
               return @concreteType2;
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
               return @concreteType1;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
               return @otherType;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
         }
   }

   /// <summary>
   /// Maps current instance to an instance of type <typeparamref name="TResult"/>.
   /// </summary>
   /// <param name="default">The instance to return if no value is provided for the current type.</param>
   /// <param name="concreteType2">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType2"/>.</param>
   /// <param name="concreteType1">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.ConcreteType1"/>.</param>
   /// <param name="otherType">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult MapPartially<TResult>(
      TResult @default,
      global::Thinktecture.Argument<TResult> @concreteType2 = default,
      global::Thinktecture.Argument<TResult> @concreteType1 = default,
      global::Thinktecture.Argument<TResult> @otherType = default)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.ConcreteType2 value:
               if (!@concreteType2.IsSet)
                  break;

               return @concreteType2.Value;
         case global::Thinktecture.Tests.TestUnion.ConcreteType1 value:
               if (!@concreteType1.IsSet)
                  break;

               return @concreteType1.Value;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
               if (!@otherType.IsSet)
                  break;

               return @otherType.Value;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
         }

         return @default;
   }

   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="baseType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch(
      global::System.Action<global::Thinktecture.Tests.TestUnion.BaseType> @baseType,
      global::System.Action<global::Thinktecture.Tests.TestUnion.OtherType> @otherType)
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
            @baseType(value);
            return;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            @otherType(value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }

   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="default">The action to execute if no type-specific action is provided.</param>
   /// <param name="baseType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void SwitchPartially(
      global::System.Action<global::Thinktecture.Tests.TestUnion>? @default = null,
      global::System.Action<global::Thinktecture.Tests.TestUnion.BaseType>? @baseType = null,
      global::System.Action<global::Thinktecture.Tests.TestUnion.OtherType>? @otherType = null)
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
            if (@baseType is null)
               break;

            @baseType(value);
            return;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            if (@otherType is null)
               break;

            @otherType(value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      @default?.Invoke(this);
   }

   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="baseType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch<TState>(
      TState @state,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.BaseType> @baseType,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.OtherType> @otherType)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
            @baseType(@state, value);
            return;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            @otherType(@state, value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }

   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="default">The action to execute if no type-specific action is provided.</param>
   /// <param name="baseType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The action to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void SwitchPartially<TState>(
      TState @state,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion>? @default = null,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.BaseType>? @baseType = null,
      global::System.Action<TState, global::Thinktecture.Tests.TestUnion.OtherType>? @otherType = null)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
            if (@baseType is null)
               break;

            @baseType(@state, value);
            return;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            if (@otherType is null)
               break;

            @otherType(@state, value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      @default?.Invoke(@state, this);
   }

   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="baseType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TResult>(
      global::System.Func<global::Thinktecture.Tests.TestUnion.BaseType, TResult> @baseType,
      global::System.Func<global::Thinktecture.Tests.TestUnion.OtherType, TResult> @otherType)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
            return @baseType(value);
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            return @otherType(value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }

   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="default">The function to execute if no type-specific action is provided.</param>
   /// <param name="baseType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult SwitchPartially<TResult>(
      global::System.Func<global::Thinktecture.Tests.TestUnion, TResult> @default,
      global::System.Func<global::Thinktecture.Tests.TestUnion.BaseType, TResult>? @baseType = null,
      global::System.Func<global::Thinktecture.Tests.TestUnion.OtherType, TResult>? @otherType = null)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
            if (@baseType is null)
               break;

            return @baseType(value);
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            if (@otherType is null)
               break;

            return @otherType(value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      return @default(this);
   }

   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="baseType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TState, TResult>(
      TState @state,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.BaseType, TResult> @baseType,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.OtherType, TResult> @otherType)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
            return @baseType(@state, value);
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            return @otherType(@state, value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }

   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="default">The function to execute if no type-specific action is provided.</param>
   /// <param name="baseType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The function to execute if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult SwitchPartially<TState, TResult>(
      TState @state,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion, TResult> @default,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.BaseType, TResult>? @baseType = null,
      global::System.Func<TState, global::Thinktecture.Tests.TestUnion.OtherType, TResult>? @otherType = null)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
            if (@baseType is null)
               break;

            return @baseType(@state, value);
         case global::Thinktecture.Tests.TestUnion.OtherType value:
            if (@otherType is null)
               break;

            return @otherType(@state, value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      return @default(@state, this);
   }

   /// <summary>
   /// Maps current instance to an instance of type <typeparamref name="TResult"/>.
   /// </summary>
   /// <param name="baseType">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Map<TResult>(
      TResult @baseType,
      TResult @otherType)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
               return @baseType;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
               return @otherType;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
         }
   }

   /// <summary>
   /// Maps current instance to an instance of type <typeparamref name="TResult"/>.
   /// </summary>
   /// <param name="default">The instance to return if no value is provided for the current type.</param>
   /// <param name="baseType">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.BaseType"/>.</param>
   /// <param name="otherType">The instance to return if the current type is <see cref="global::Thinktecture.Tests.TestUnion.OtherType"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult MapPartially<TResult>(
      TResult @default,
      global::Thinktecture.Argument<TResult> @baseType = default,
      global::Thinktecture.Argument<TResult> @otherType = default)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.TestUnion.BaseType value:
               if (!@baseType.IsSet)
                  break;

               return @baseType.Value;
         case global::Thinktecture.Tests.TestUnion.OtherType value:
               if (!@otherType.IsSet)
                  break;

               return @otherType.Value;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
         }

         return @default;
   }
}
