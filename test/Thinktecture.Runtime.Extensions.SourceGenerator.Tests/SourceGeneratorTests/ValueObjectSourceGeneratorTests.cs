using MessagePack;
using Thinktecture.CodeAnalysis;
using Thinktecture.Formatters;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class ValueObjectSourceGeneratorTests : SourceGeneratorTestsBase
{
   public ValueObjectSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   private const string _GENERATED_HEADER = @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;
using ValidationResult = System.ComponentModel.DataAnnotations.ValidationResult;
using ValidationException = System.ComponentModel.DataAnnotations.ValidationException;
using ArgumentException = System.ArgumentException;
using NullReferenceException = System.NullReferenceException;
";

   private const string _SIMPLE_VALUE_TYPE_OUTPUT = $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create()
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject();
      }}

      public static ValidationResult? TryCreate(
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject()
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return true;
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return _type.GetHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return ""TestValueObject"";
      }}
   }}
}}
";

   [Fact]
   public void Should_generate_simple_class_with_ValueObjectAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_simple_class_with_ValueObjectAttribute_using_long_form()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObjectAttribute]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_simple_class_with_fully_qualified_ValueObjectAttribute()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
   [Thinktecture.ValueObject]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_not_generate_factory_methods_if_SkipFactoryMethods_is_true()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(SkipFactoryMethods = true)]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return true;
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return _type.GetHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return ""TestValueObject"";
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_simple_struct_with_ValueObjectAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor()]
   partial struct TestValueObject : System.IEquatable<TestValueObject>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static readonly TestValueObject Empty = default;

      public static TestValueObject Create()
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject();
      }}

      public static ValidationResult? TryCreate(
         [MaybeNull] out TestValueObject obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject()
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject obj, TestValueObject other)
      {{
         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject obj, TestValueObject other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject other)
      {{
         return true;
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return _type.GetHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return ""TestValueObject"";
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial struct TestValueObject : System.IEquatable<TestValueObject>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static readonly TestValueObject Empty = default;

      public static TestValueObject Create(string referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueObject obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject obj)
      {{
         return obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(string referenceField)
      {{
         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject obj, TestValueObject other)
      {{
         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject obj, TestValueObject other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject other)
      {{
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject obj)
      {{
         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial struct TestValueObject : System.IEquatable<TestValueObject>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static readonly TestValueObject Empty = default;

      public static TestValueObject Create(string referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueObject obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject obj)
      {{
         return obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(string referenceField)
      {{
         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject obj, TestValueObject other)
      {{
         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject obj, TestValueObject other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject other)
      {{
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject obj)
      {{
         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject? ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(string referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueObject?(string? referenceField)
      {{
         if(referenceField is null)
            return null;

         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, int>
   {{
      /// <inheritdoc />
      protected override TestValueObject ConvertFrom(int structField)
      {{
         return TestValueObject.Create(structField);
      }}

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueObject obj)
      {{
         return (int) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(StructField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IFormattable, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<int, TestValueObject>(TestValueObject.Create);
         Expression<Func<int, TestValueObject>> convertFromKeyExpression = static structField => new TestValueObject(structField);

         var convertToKey = new Func<TestValueObject, int>(static item => item.StructField);
         Expression<Func<TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, int>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(int structField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(structField);
      }}

      public static ValidationResult? TryCreate(
         int structField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(structField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int structField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.StructField;
      }}

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueObject obj)
      {{
         if(obj is null)
            throw new NullReferenceException();

         return obj.StructField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""structField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(int structField)
      {{
         return TestValueObject.Create(structField);
      }}

      private TestValueObject(int structField)
      {{
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }}

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.StructField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.StructField.ToString();
      }}

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {{
         return this.StructField.ToString(format, formatProvider);
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member_and_NullInFactoryMethodsYieldsNull()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject? ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      [return: NotNullIfNotNull(""referenceField"")]
      public static TestValueObject? Create(string? referenceField)
      {{
         if(referenceField is null)
            return default;

         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string? referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         if(referenceField is null)
         {{
            obj = default;
            return null;
         }}

         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueObject?(string? referenceField)
      {{
         if(referenceField is null)
            return null;

         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, int>
   {{
      /// <inheritdoc />
      protected override TestValueObject ConvertFrom(int structField)
      {{
         return TestValueObject.Create(structField);
      }}

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueObject obj)
      {{
         return (int) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(StructField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IFormattable, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<int, TestValueObject>(TestValueObject.Create);
         Expression<Func<int, TestValueObject>> convertFromKeyExpression = static structField => new TestValueObject(structField);

         var convertToKey = new Func<TestValueObject, int>(static item => item.StructField);
         Expression<Func<TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, int>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(int structField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(structField);
      }}

      public static ValidationResult? TryCreate(
         int structField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(structField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int structField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.StructField;
      }}

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueObject obj)
      {{
         if(obj is null)
            throw new NullReferenceException();

         return obj.StructField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""structField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(int structField)
      {{
         return TestValueObject.Create(structField);
      }}

      private TestValueObject(int structField)
      {{
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }}

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.StructField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.StructField.ToString();
      }}

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {{
         return this.StructField.ToString(format, formatProvider);
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_keyed_value_type_if_second_member_is_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;

      [ValueObjectIgnore]
      public readonly string OtherField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject? ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(string referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueObject?(string? referenceField)
      {{
         if(referenceField is null)
            return null;

         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_having_EqualityMemberAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectEqualityMember(EqualityComparer = ""EqualityComparer<int>.Default"", Comparer = ""Comparer<int>.Default"")]
      public readonly int ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, int>
   {{
      /// <inheritdoc />
      protected override TestValueObject ConvertFrom(int referenceField)
      {{
         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueObject obj)
      {{
         return (int) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IFormattable, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<int, TestValueObject>(TestValueObject.Create);
         Expression<Func<int, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, int>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, int>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, int>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(int referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         int referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueObject obj)
      {{
         if(obj is null)
            throw new NullReferenceException();

         return obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(int referenceField)
      {{
         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(int referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref int referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return EqualityComparer<int>.Default.Equals(this.ReferenceField, other.ReferenceField);
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField, EqualityComparer<int>.Default);
         return hashCode.ToHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField.ToString();
      }}

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {{
         return this.ReferenceField.ToString(format, formatProvider);
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         return Comparer<int>.Default.Compare(this.ReferenceField, obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_8_members()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectEqualityMember(EqualityComparer = nameof(StringComparer.OrdinalIgnoreCase))]
      public readonly string ReferenceField;

      [ValueObjectEqualityMember]
      public readonly int StructField;

      public string ReferenceProperty { get; }
      public int StructProperty { get; }

      public int ExpressionBodyProperty => 42;

      public int GetterExpressionProperty
      {
         get => 42;
      }

      public int GetterBodyProperty
      {
         get { return 42; }
      }

      public int SetterProperty
      {
         set { }
      }
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField), nameof(StructField), nameof(ReferenceProperty), nameof(StructProperty))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(string referenceField, int structField, string referenceProperty, int structProperty)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField, structField, referenceProperty, structProperty);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         int structField,
         string referenceProperty,
         int structProperty,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField, structField, referenceProperty, structProperty)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      private TestValueObject(string referenceField, int structField, string referenceProperty, int structProperty)
      {{
         ValidateConstructorArguments(ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         this.ReferenceField = referenceField;
         this.StructField = structField;
         this.ReferenceProperty = referenceProperty;
         this.StructProperty = structProperty;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return StringComparer.OrdinalIgnoreCase.Equals(this.ReferenceField, other.ReferenceField)
             && this.StructField.Equals(other.StructField);
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField, StringComparer.OrdinalIgnoreCase);
         hashCode.Add(this.StructField);
         return hashCode.ToHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return $""{{{{ ReferenceField = {{this.ReferenceField}}, StructField = {{this.StructField}} }}}}"";
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_9_members()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField1;
      public readonly string ReferenceField2;
      public readonly string ReferenceField3;
      public readonly string ReferenceField4;
      public readonly string ReferenceField5;
      public readonly string ReferenceField6;
      public readonly string ReferenceField7;
      public readonly string ReferenceField8;
      public readonly string ReferenceField9;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertStrings(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField1), nameof(ReferenceField2), nameof(ReferenceField3), nameof(ReferenceField4), nameof(ReferenceField5), nameof(ReferenceField6), nameof(ReferenceField7), nameof(ReferenceField8), nameof(ReferenceField9))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9);
      }}

      public static ValidationResult? TryCreate(
         string referenceField1,
         string referenceField2,
         string referenceField3,
         string referenceField4,
         string referenceField5,
         string referenceField6,
         string referenceField7,
         string referenceField8,
         string referenceField9,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      private TestValueObject(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {{
         ValidateConstructorArguments(ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         this.ReferenceField1 = referenceField1;
         this.ReferenceField2 = referenceField2;
         this.ReferenceField3 = referenceField3;
         this.ReferenceField4 = referenceField4;
         this.ReferenceField5 = referenceField5;
         this.ReferenceField6 = referenceField6;
         this.ReferenceField7 = referenceField7;
         this.ReferenceField8 = referenceField8;
         this.ReferenceField9 = referenceField9;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField1 is null ? other.ReferenceField1 is null : this.ReferenceField1.Equals(other.ReferenceField1))
             && (this.ReferenceField2 is null ? other.ReferenceField2 is null : this.ReferenceField2.Equals(other.ReferenceField2))
             && (this.ReferenceField3 is null ? other.ReferenceField3 is null : this.ReferenceField3.Equals(other.ReferenceField3))
             && (this.ReferenceField4 is null ? other.ReferenceField4 is null : this.ReferenceField4.Equals(other.ReferenceField4))
             && (this.ReferenceField5 is null ? other.ReferenceField5 is null : this.ReferenceField5.Equals(other.ReferenceField5))
             && (this.ReferenceField6 is null ? other.ReferenceField6 is null : this.ReferenceField6.Equals(other.ReferenceField6))
             && (this.ReferenceField7 is null ? other.ReferenceField7 is null : this.ReferenceField7.Equals(other.ReferenceField7))
             && (this.ReferenceField8 is null ? other.ReferenceField8 is null : this.ReferenceField8.Equals(other.ReferenceField8))
             && (this.ReferenceField9 is null ? other.ReferenceField9 is null : this.ReferenceField9.Equals(other.ReferenceField9));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField1);
         hashCode.Add(this.ReferenceField2);
         hashCode.Add(this.ReferenceField3);
         hashCode.Add(this.ReferenceField4);
         hashCode.Add(this.ReferenceField5);
         hashCode.Add(this.ReferenceField6);
         hashCode.Add(this.ReferenceField7);
         hashCode.Add(this.ReferenceField8);
         hashCode.Add(this.ReferenceField9);
         return hashCode.ToHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return $""{{{{ ReferenceField1 = {{this.ReferenceField1}}, ReferenceField2 = {{this.ReferenceField2}}, ReferenceField3 = {{this.ReferenceField3}}, ReferenceField4 = {{this.ReferenceField4}}, ReferenceField5 = {{this.ReferenceField5}}, ReferenceField6 = {{this.ReferenceField6}}, ReferenceField7 = {{this.ReferenceField7}}, ReferenceField8 = {{this.ReferenceField8}}, ReferenceField9 = {{this.ReferenceField9}} }}}}"";
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_JsonConverter_and_Attribute_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Thinktecture;

namespace Thinktecture.Tests
{
   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueObjectJsonConverterFactory))]
   partial class TestValueObject
   {
      public class ValueObjectJsonConverterFactory : System.Text.Json.Serialization.JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(System.Type typeToConvert)
         {
            return typeof(TestValueObject).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override System.Text.Json.Serialization.JsonConverter CreateConverter(System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new ArgumentNullException(nameof(options));

            return new Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<TestValueObject, string>(TestValueObject.Create, static obj => obj.ReferenceField, options);
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_JsonConverter_and_Attribute_for_struct_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Thinktecture;

namespace Thinktecture.Tests
{
   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueObjectJsonConverterFactory))]
   partial struct TestValueObject
   {
      public class ValueObjectJsonConverterFactory : System.Text.Json.Serialization.JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(System.Type typeToConvert)
         {
            return typeof(TestValueObject).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override System.Text.Json.Serialization.JsonConverter CreateConverter(System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new ArgumentNullException(nameof(options));

            return new Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<TestValueObject, string>(TestValueObject.Create, static obj => obj.ReferenceField, options);
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_JsonConverter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Thinktecture.Text.Json.Serialization;
using ValidationResult = System.ComponentModel.DataAnnotations.ValidationResult;
using JsonTokenType = System.Text.Json.JsonTokenType;
using JsonException = System.Text.Json.JsonException;
using JsonSerializerOptions = System.Text.Json.JsonSerializerOptions;
using JsonIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition;

namespace Thinktecture.Tests
{
   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueObjectJsonConverterFactory))]
   partial class TestValueObject
   {
      public class ValueObjectJsonConverter : System.Text.Json.Serialization.JsonConverter<TestValueObject>
      {
         private readonly string _referenceFieldPropertyName;
         private readonly string _structPropertyPropertyName;
         private readonly System.Text.Json.Serialization.JsonConverter<decimal?> _nullableStructPropertyConverter;
         private readonly string _nullableStructPropertyPropertyName;

         public ValueObjectJsonConverter(JsonSerializerOptions options)
         {
            if(options is null)
               throw new ArgumentNullException(nameof(options));

            var namingPolicy = options.PropertyNamingPolicy;

            this._referenceFieldPropertyName = namingPolicy?.ConvertName(""ReferenceField"") ?? ""ReferenceField"";
            this._structPropertyPropertyName = namingPolicy?.ConvertName(""StructProperty"") ?? ""StructProperty"";
            this._nullableStructPropertyConverter = (System.Text.Json.Serialization.JsonConverter<decimal?>)options.GetConverter(typeof(decimal?));
            this._nullableStructPropertyPropertyName = namingPolicy?.ConvertName(""NullableStructProperty"") ?? ""NullableStructProperty"";
         }

         /// <inheritdoc />
         public override TestValueObject? Read(ref Utf8JsonReader reader, System.Type typeToConvert, JsonSerializerOptions options)
         {
            if (reader.TokenType == JsonTokenType.Null)
               return default;

            if (reader.TokenType != JsonTokenType.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonTokenType.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = options.PropertyNameCaseInsensitive ? System.StringComparer.OrdinalIgnoreCase : System.StringComparer.Ordinal;

            while (reader.Read())
            {
               if (reader.TokenType == JsonTokenType.EndObject)
                  break;

               if (reader.TokenType != JsonTokenType.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonTokenType.PropertyName}'."");

               var propName = reader.GetString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueObject'."");

               if (comparer.Equals(propName, this._referenceFieldPropertyName))
               {
                  referenceField = reader.GetString();
               }
               else if (comparer.Equals(propName, this._structPropertyPropertyName))
               {
                  structProperty = reader.GetInt32();
               }
               else if (comparer.Equals(propName, this._nullableStructPropertyPropertyName))
               {
                  nullableStructProperty = this._nullableStructPropertyConverter.Read(ref reader, typeof(decimal?), options);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueObject'."");
               }
            }

            var validationResult = TestValueObject.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void Write(Utf8JsonWriter writer, TestValueObject value, JsonSerializerOptions options)
         {
            writer.WriteStartObject();

            var ignoreNullValues = options.DefaultIgnoreCondition is JsonIgnoreCondition.WhenWritingNull or JsonIgnoreCondition.WhenWritingDefault;
            var ignoreDefaultValues = options.DefaultIgnoreCondition == JsonIgnoreCondition.WhenWritingDefault;

            var referenceFieldPropertyValue = value.ReferenceField;

            if(!ignoreNullValues || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName(this._referenceFieldPropertyName);
               writer.WriteStringValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            if(!ignoreDefaultValues || !structPropertyPropertyValue.Equals(default(int)))
            {
               writer.WritePropertyName(this._structPropertyPropertyName);
               writer.WriteNumberValue(structPropertyPropertyValue);
            }
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(!ignoreNullValues || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName(this._nullableStructPropertyPropertyName);
               this._nullableStructPropertyConverter.Write(writer, nullableStructPropertyPropertyValue, options);
            }
            writer.WriteEndObject();
         }
      }

      public class ValueObjectJsonConverterFactory : System.Text.Json.Serialization.JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(System.Type typeToConvert)
         {
            return typeof(TestValueObject).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override System.Text.Json.Serialization.JsonConverter CreateConverter(System.Type typeToConvert, JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new ArgumentNullException(nameof(options));

            return new ValueObjectJsonConverter(options);
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_JsonConverter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Thinktecture.Text.Json.Serialization;
using ValidationResult = System.ComponentModel.DataAnnotations.ValidationResult;
using JsonTokenType = System.Text.Json.JsonTokenType;
using JsonException = System.Text.Json.JsonException;
using JsonSerializerOptions = System.Text.Json.JsonSerializerOptions;
using JsonIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition;

namespace Thinktecture.Tests
{
   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueObjectJsonConverterFactory))]
   partial struct TestValueObject
   {
      public class ValueObjectJsonConverter : System.Text.Json.Serialization.JsonConverter<TestValueObject>
      {
         private readonly string _referenceFieldPropertyName;
         private readonly string _structPropertyPropertyName;
         private readonly System.Text.Json.Serialization.JsonConverter<decimal?> _nullableStructPropertyConverter;
         private readonly string _nullableStructPropertyPropertyName;

         public ValueObjectJsonConverter(JsonSerializerOptions options)
         {
            if(options is null)
               throw new ArgumentNullException(nameof(options));

            var namingPolicy = options.PropertyNamingPolicy;

            this._referenceFieldPropertyName = namingPolicy?.ConvertName(""ReferenceField"") ?? ""ReferenceField"";
            this._structPropertyPropertyName = namingPolicy?.ConvertName(""StructProperty"") ?? ""StructProperty"";
            this._nullableStructPropertyConverter = (System.Text.Json.Serialization.JsonConverter<decimal?>)options.GetConverter(typeof(decimal?));
            this._nullableStructPropertyPropertyName = namingPolicy?.ConvertName(""NullableStructProperty"") ?? ""NullableStructProperty"";
         }

         /// <inheritdoc />
         public override TestValueObject Read(ref Utf8JsonReader reader, System.Type typeToConvert, JsonSerializerOptions options)
         {
            if (reader.TokenType == JsonTokenType.Null)
               return default;

            if (reader.TokenType != JsonTokenType.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonTokenType.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = options.PropertyNameCaseInsensitive ? System.StringComparer.OrdinalIgnoreCase : System.StringComparer.Ordinal;

            while (reader.Read())
            {
               if (reader.TokenType == JsonTokenType.EndObject)
                  break;

               if (reader.TokenType != JsonTokenType.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonTokenType.PropertyName}'."");

               var propName = reader.GetString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueObject'."");

               if (comparer.Equals(propName, this._referenceFieldPropertyName))
               {
                  referenceField = reader.GetString();
               }
               else if (comparer.Equals(propName, this._structPropertyPropertyName))
               {
                  structProperty = reader.GetInt32();
               }
               else if (comparer.Equals(propName, this._nullableStructPropertyPropertyName))
               {
                  nullableStructProperty = this._nullableStructPropertyConverter.Read(ref reader, typeof(decimal?), options);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueObject'."");
               }
            }

            var validationResult = TestValueObject.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void Write(Utf8JsonWriter writer, TestValueObject value, JsonSerializerOptions options)
         {
            writer.WriteStartObject();

            var ignoreNullValues = options.DefaultIgnoreCondition is JsonIgnoreCondition.WhenWritingNull or JsonIgnoreCondition.WhenWritingDefault;
            var ignoreDefaultValues = options.DefaultIgnoreCondition == JsonIgnoreCondition.WhenWritingDefault;

            var referenceFieldPropertyValue = value.ReferenceField;

            if(!ignoreNullValues || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName(this._referenceFieldPropertyName);
               writer.WriteStringValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            if(!ignoreDefaultValues || !structPropertyPropertyValue.Equals(default(int)))
            {
               writer.WritePropertyName(this._structPropertyPropertyName);
               writer.WriteNumberValue(structPropertyPropertyValue);
            }
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(!ignoreNullValues || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName(this._nullableStructPropertyPropertyName);
               this._nullableStructPropertyConverter.Write(writer, nullableStructPropertyPropertyValue, options);
            }
            writer.WriteEndObject();
         }
      }

      public class ValueObjectJsonConverterFactory : System.Text.Json.Serialization.JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(System.Type typeToConvert)
         {
            return typeof(TestValueObject).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override System.Text.Json.Serialization.JsonConverter CreateConverter(System.Type typeToConvert, JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new ArgumentNullException(nameof(options));

            return new ValueObjectJsonConverter(options);
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_and_Attribute_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial class TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Thinktecture.Json.ValueObjectNewtonsoftJsonConverter<TestValueObject, string>
      {
         public ValueObjectNewtonsoftJsonConverter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_struct_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial struct TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Thinktecture.Json.ValueObjectNewtonsoftJsonConverter<TestValueObject, string>
      {
         public ValueObjectNewtonsoftJsonConverter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Thinktecture;
using JsonException = Newtonsoft.Json.JsonException;
using JsonToken = Newtonsoft.Json.JsonToken;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial class TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Newtonsoft.Json.JsonConverter<TestValueObject?>
      {
         /// <inheritdoc />
         public override TestValueObject? ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, TestValueObject? existingValue, bool hasExistingValue, Newtonsoft.Json.JsonSerializer serializer)
         {
            if (reader is null)
               throw new System.ArgumentNullException(nameof(reader));
            if (serializer is null)
               throw new System.ArgumentNullException(nameof(serializer));

            if (reader.TokenType == JsonToken.Null)
               return default;

            if (reader.TokenType != JsonToken.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = System.StringComparer.OrdinalIgnoreCase;

            while (reader.Read())
            {
               if (reader.TokenType == JsonToken.EndObject)
                  break;

               if (reader.TokenType != JsonToken.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.PropertyName}'."");

               var propName = reader.Value!.ToString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueObject'."");

               if (comparer.Equals(propName, ""referenceField""))
               {
                  referenceField = serializer.Deserialize<string>(reader);
               }
               else if (comparer.Equals(propName, ""structProperty""))
               {
                  structProperty = serializer.Deserialize<int>(reader);
               }
               else if (comparer.Equals(propName, ""nullableStructProperty""))
               {
                  nullableStructProperty = serializer.Deserialize<decimal?>(reader);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueObject'."");
               }
            }

            var validationResult = TestValueObject.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void WriteJson(Newtonsoft.Json.JsonWriter writer, TestValueObject? value, Newtonsoft.Json.JsonSerializer serializer)
         {
            if (value == null)
            {
               writer.WriteNull();
               return;
            }

            var resolver = serializer.ContractResolver as Newtonsoft.Json.Serialization.DefaultContractResolver;

            writer.WriteStartObject();
            var referenceFieldPropertyValue = value.ReferenceField;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""ReferenceField"") : ""ReferenceField"");
               writer.WriteValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""StructProperty"") : ""StructProperty"");
            writer.WriteValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""NullableStructProperty"") : ""NullableStructProperty"");
               serializer.Serialize(writer, nullableStructPropertyPropertyValue);
            }
            writer.WriteEndObject();
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Thinktecture;
using JsonException = Newtonsoft.Json.JsonException;
using JsonToken = Newtonsoft.Json.JsonToken;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial struct TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Newtonsoft.Json.JsonConverter<TestValueObject>
      {
         /// <inheritdoc />
         public override TestValueObject ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, TestValueObject existingValue, bool hasExistingValue, Newtonsoft.Json.JsonSerializer serializer)
         {
            if (reader is null)
               throw new System.ArgumentNullException(nameof(reader));
            if (serializer is null)
               throw new System.ArgumentNullException(nameof(serializer));

            if (reader.TokenType == JsonToken.Null)
               return default;

            if (reader.TokenType != JsonToken.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = System.StringComparer.OrdinalIgnoreCase;

            while (reader.Read())
            {
               if (reader.TokenType == JsonToken.EndObject)
                  break;

               if (reader.TokenType != JsonToken.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.PropertyName}'."");

               var propName = reader.Value!.ToString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueObject'."");

               if (comparer.Equals(propName, ""referenceField""))
               {
                  referenceField = serializer.Deserialize<string>(reader);
               }
               else if (comparer.Equals(propName, ""structProperty""))
               {
                  structProperty = serializer.Deserialize<int>(reader);
               }
               else if (comparer.Equals(propName, ""nullableStructProperty""))
               {
                  nullableStructProperty = serializer.Deserialize<decimal?>(reader);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueObject'."");
               }
            }

            var validationResult = TestValueObject.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void WriteJson(Newtonsoft.Json.JsonWriter writer, TestValueObject value, Newtonsoft.Json.JsonSerializer serializer)
         {
            var resolver = serializer.ContractResolver as Newtonsoft.Json.Serialization.DefaultContractResolver;

            writer.WriteStartObject();
            var referenceFieldPropertyValue = value.ReferenceField;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""ReferenceField"") : ""ReferenceField"");
               writer.WriteValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""StructProperty"") : ""StructProperty"");
            writer.WriteValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""NullableStructProperty"") : ""NullableStructProperty"");
               serializer.Serialize(writer, nullableStructPropertyPropertyValue);
            }
            writer.WriteEndObject();
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial class TestValueObject
   {
      public class ValueObjectMessagePackFormatter : Thinktecture.Formatters.ValueObjectMessagePackFormatter<TestValueObject, string>
      {
         public ValueObjectMessagePackFormatter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_struct_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial struct TestValueObject
   {
      public class ValueObjectMessagePackFormatter : Thinktecture.Formatters.ValueObjectMessagePackFormatter<TestValueObject, string>
      {
         public ValueObjectMessagePackFormatter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using MessagePack;
using MessagePack.Formatters;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial class TestValueObject
   {
      public class ValueObjectMessagePackFormatter : MessagePack.Formatters.IMessagePackFormatter<TestValueObject?>
      {
         /// <inheritdoc />
         public TestValueObject? Deserialize(ref MessagePack.MessagePackReader reader, MessagePack.MessagePackSerializerOptions options)
         {
            if (reader.TryReadNil())
               return default;

            var count = reader.ReadArrayHeader();

            if (count != 3)
               throw new MessagePack.MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

            MessagePack.IFormatterResolver resolver = options.Resolver;
            options.Security.DepthStep(ref reader);

            try
            {

               var referenceField = reader.ReadString()!;
               var structProperty = reader.ReadInt32()!;
               var nullableStructProperty = resolver.GetFormatterWithVerify<decimal?>().Deserialize(ref reader, options)!;

               var validationResult = TestValueObject.TryCreate(
                                          referenceField,
                                          structProperty,
                                          nullableStructProperty,
                                          out var obj);

               if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
                  throw new MessagePack.MessagePackSerializationException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

               return obj;
            }
            finally
            {
              reader.Depth--;
            }
         }

         /// <inheritdoc />
         public void Serialize(ref MessagePack.MessagePackWriter writer, TestValueObject? value, MessagePack.MessagePackSerializerOptions options)
         {
            if(value is null)
            {
               writer.WriteNil();
               return;
            }

            writer.WriteArrayHeader(3);

            var resolver = options.Resolver;
            writer.Write(value.ReferenceField);
            writer.Write(value.StructProperty);
            resolver.GetFormatterWithVerify<decimal?>().Serialize(ref writer, value.NullableStructProperty, options);
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertStrings(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using MessagePack;
using MessagePack.Formatters;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial struct TestValueObject
   {
      public class ValueObjectMessagePackFormatter : MessagePack.Formatters.IMessagePackFormatter<TestValueObject>
      {
         /// <inheritdoc />
         public TestValueObject Deserialize(ref MessagePack.MessagePackReader reader, MessagePack.MessagePackSerializerOptions options)
         {
            if (reader.TryReadNil())
               return default;

            var count = reader.ReadArrayHeader();

            if (count != 3)
               throw new MessagePack.MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

            MessagePack.IFormatterResolver resolver = options.Resolver;
            options.Security.DepthStep(ref reader);

            try
            {

               var referenceField = reader.ReadString()!;
               var structProperty = reader.ReadInt32()!;
               var nullableStructProperty = resolver.GetFormatterWithVerify<decimal?>().Deserialize(ref reader, options)!;

               var validationResult = TestValueObject.TryCreate(
                                          referenceField,
                                          structProperty,
                                          nullableStructProperty,
                                          out var obj);

               if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
                  throw new MessagePack.MessagePackSerializationException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

               return obj;
            }
            finally
            {
              reader.Depth--;
            }
         }

         /// <inheritdoc />
         public void Serialize(ref MessagePack.MessagePackWriter writer, TestValueObject value, MessagePack.MessagePackSerializerOptions options)
         {
            writer.WriteArrayHeader(3);

            var resolver = options.Resolver;
            writer.Write(value.ReferenceField);
            writer.Write(value.StructProperty);
            resolver.GetFormatterWithVerify<decimal?>().Serialize(ref writer, value.NullableStructProperty, options);
         }
      }
   }
}
");
   }

   private static void AssertStrings(string output, string expectedOutput)
   {
      if (Environment.NewLine == "\n")
      {
         output = output.Replace("\r\n", Environment.NewLine);
         expectedOutput = expectedOutput.Replace("\r\n", Environment.NewLine);
      }

      output.Should().Be(expectedOutput);
   }
}
