using Thinktecture.CodeAnalysis;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class ValueObjectSourceGeneratorTests : SourceGeneratorTestsBase
{
   public ValueObjectSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   private const string _GENERATED_HEADER = @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;
using ValidationResult = System.ComponentModel.DataAnnotations.ValidationResult;
using ValidationException = System.ComponentModel.DataAnnotations.ValidationException;
using ArgumentException = System.ArgumentException;
using NullReferenceException = System.NullReferenceException;
";

   private const string _SIMPLE_VALUE_TYPE_OUTPUT = $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create()
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject();
      }}

      public static ValidationResult? TryCreate(
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject()
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult);

      private TestValueObject()
      {{
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return true;
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return _type.GetHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return ""TestValueObject"";
      }}
   }}
}}
";

   [Fact]
   public void Should_not_generate_code_if_not_partial()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_not_generate_code_if_generic()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject<T>
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_generate_simple_class_with_ValueObjectAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_code_for_class_with_generic()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject<T>
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_simple_class_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
   [Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create()
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject();
      }}

      public static ValidationResult? TryCreate(
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject()
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult);

      private TestValueObject()
      {{
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return true;
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return _type.GetHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return ""TestValueObject"";
      }}
   }}
");
   }

   [Fact]
   public void Should_generate_simple_class_with_ValueObjectAttribute_using_long_form()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObjectAttribute]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_simple_class_with_fully_qualified_ValueObjectAttribute()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
   [Thinktecture.ValueObject]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_not_generate_factory_methods_if_SkipFactoryMethods_is_true()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(SkipFactoryMethods = true)]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      private TestValueObject()
      {{
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return true;
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return _type.GetHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return ""TestValueObject"";
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_simple_struct_with_ValueObjectAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor()]
   partial struct TestValueObject : System.IEquatable<TestValueObject>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static readonly TestValueObject Empty = default;

      public static TestValueObject Create()
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject();
      }}

      public static ValidationResult? TryCreate(
         [MaybeNull] out TestValueObject obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject()
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult);

      private TestValueObject()
      {{
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject obj, TestValueObject other)
      {{
         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject obj, TestValueObject other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject other)
      {{
         return true;
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return _type.GetHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return ""TestValueObject"";
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial struct TestValueObject : System.IEquatable<TestValueObject>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static readonly TestValueObject Empty = default;

      public static TestValueObject Create(string referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueObject obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject obj)
      {{
         return obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(string referenceField)
      {{
         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject obj, TestValueObject other)
      {{
         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject obj, TestValueObject other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject other)
      {{
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject obj)
      {{
         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial struct TestValueObject : System.IEquatable<TestValueObject>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static readonly TestValueObject Empty = default;

      public static TestValueObject Create(string referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueObject obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject obj)
      {{
         return obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(string referenceField)
      {{
         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject obj, TestValueObject other)
      {{
         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject obj, TestValueObject other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject other)
      {{
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject obj)
      {{
         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject? ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(string referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueObject?(string? referenceField)
      {{
         if(referenceField is null)
            return null;

         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, int>
   {{
      /// <inheritdoc />
      protected override TestValueObject ConvertFrom(int structField)
      {{
         return TestValueObject.Create(structField);
      }}

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueObject obj)
      {{
         return (int) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(StructField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IFormattable, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<int, TestValueObject>(TestValueObject.Create);
         Expression<Func<int, TestValueObject>> convertFromKeyExpression = static structField => new TestValueObject(structField);

         var convertToKey = new Func<TestValueObject, int>(static item => item.StructField);
         Expression<Func<TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, int>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(int structField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(structField);
      }}

      public static ValidationResult? TryCreate(
         int structField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(structField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int structField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.StructField;
      }}

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueObject obj)
      {{
         if(obj is null)
            throw new NullReferenceException();

         return obj.StructField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""structField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(int structField)
      {{
         return TestValueObject.Create(structField);
      }}

      private TestValueObject(int structField)
      {{
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }}

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.StructField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.StructField.ToString();
      }}

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {{
         return this.StructField.ToString(format, formatProvider);
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member_and_NullInFactoryMethodsYieldsNull()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject? ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      [return: NotNullIfNotNull(""referenceField"")]
      public static TestValueObject? Create(string? referenceField)
      {{
         if(referenceField is null)
            return default;

         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string? referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         if(referenceField is null)
         {{
            obj = default;
            return null;
         }}

         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueObject?(string? referenceField)
      {{
         if(referenceField is null)
            return null;

         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, int>
   {{
      /// <inheritdoc />
      protected override TestValueObject ConvertFrom(int structField)
      {{
         return TestValueObject.Create(structField);
      }}

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueObject obj)
      {{
         return (int) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(StructField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IFormattable, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<int, TestValueObject>(TestValueObject.Create);
         Expression<Func<int, TestValueObject>> convertFromKeyExpression = static structField => new TestValueObject(structField);

         var convertToKey = new Func<TestValueObject, int>(static item => item.StructField);
         Expression<Func<TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, int>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(int structField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(structField);
      }}

      public static ValidationResult? TryCreate(
         int structField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(structField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int structField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.StructField;
      }}

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueObject obj)
      {{
         if(obj is null)
            throw new NullReferenceException();

         return obj.StructField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""structField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(int structField)
      {{
         return TestValueObject.Create(structField);
      }}

      private TestValueObject(int structField)
      {{
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }}

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.StructField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.StructField.ToString();
      }}

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {{
         return this.StructField.ToString(format, formatProvider);
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_keyed_value_type_if_second_member_is_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;

      [ValueObjectIgnore]
      public readonly string OtherField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, string>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject? ConvertFrom(string? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueObject obj)
      {{
         return (string) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<string, TestValueObject>(TestValueObject.Create);
         Expression<Func<string, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, string>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, string>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(string referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueObject?(string? referenceField)
      {{
         if(referenceField is null)
            return null;

         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(string referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_having_EqualityMemberAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectEqualityMember(EqualityComparer = ""EqualityComparer<int>.Default"", Comparer = ""Comparer<int>.Default"")]
      public readonly int ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, int>
   {{
      /// <inheritdoc />
      protected override TestValueObject ConvertFrom(int referenceField)
      {{
         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueObject obj)
      {{
         return (int) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IFormattable, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<int, TestValueObject>(TestValueObject.Create);
         Expression<Func<int, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, int>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, int>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, int>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(int referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         int referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueObject obj)
      {{
         if(obj is null)
            throw new NullReferenceException();

         return obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator TestValueObject(int referenceField)
      {{
         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(int referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref int referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return EqualityComparer<int>.Default.Equals(this.ReferenceField, other.ReferenceField);
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField, EqualityComparer<int>.Default);
         return hashCode.ToHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField.ToString();
      }}

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {{
         return this.ReferenceField.ToString(format, formatProvider);
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         return Comparer<int>.Default.Compare(this.ReferenceField, obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_IComperable_if_member_is_not_IComperable_but_has_custom_comparer()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectEqualityMember(Comparer = ""Comparer<Foo>.Default"")]
      public readonly Foo ReferenceField;
   }

   public class Foo
   {
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   public class TestValueObject_ValueObjectTypeConverter : Thinktecture.ValueObjectTypeConverter<TestValueObject, Thinktecture.Tests.Foo>
   {{
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueObject? ConvertFrom(Thinktecture.Tests.Foo? referenceField)
      {{
         if(referenceField is null)
            return default(TestValueObject);

         return TestValueObject.Create(referenceField);
      }}

      /// <inheritdoc />
      protected override Thinktecture.Tests.Foo GetKeyValue(TestValueObject obj)
      {{
         return (Thinktecture.Tests.Foo) obj;
      }}
   }}

   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueObject]
   [System.ComponentModel.TypeConverter(typeof(TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>, System.IComparable, System.IComparable<TestValueObject>
   {{
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {{
         var convertFromKey = new Func<Thinktecture.Tests.Foo, TestValueObject>(TestValueObject.Create);
         Expression<Func<Thinktecture.Tests.Foo, TestValueObject>> convertFromKeyExpression = static referenceField => new TestValueObject(referenceField);

         var convertToKey = new Func<TestValueObject, Thinktecture.Tests.Foo>(static item => item.ReferenceField);
         Expression<Func<TestValueObject, Thinktecture.Tests.Foo>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueObject, Thinktecture.Tests.Foo>(TestValueObject.TryCreate);

         var type = typeof(TestValueObject);
         var metadata = new Thinktecture.Internal.ValueObjectMetadata(type, typeof(Thinktecture.Tests.Foo), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }}

      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(Thinktecture.Tests.Foo referenceField)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField);
      }}

      public static ValidationResult? TryCreate(
         Thinktecture.Tests.Foo referenceField,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref Thinktecture.Tests.Foo referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""Thinktecture.Tests.Foo""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator Thinktecture.Tests.Foo?(TestValueObject? obj)
      {{
         return obj is null ? null : obj.ReferenceField;
      }}

      /// <summary>
      /// Explicit conversion from the type <see cref=""Thinktecture.Tests.Foo""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueObject?(Thinktecture.Tests.Foo? referenceField)
      {{
         if(referenceField is null)
            return null;

         return TestValueObject.Create(referenceField);
      }}

      private TestValueObject(Thinktecture.Tests.Foo referenceField)
      {{
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }}

      static partial void ValidateConstructorArguments(ref Thinktecture.Tests.Foo referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         return HashCode.Combine(this.ReferenceField);
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return this.ReferenceField?.ToString();
      }}

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {{
         if(obj is null)
            return 1;

         if(obj is not TestValueObject valueObject)
            throw new ArgumentException(""Argument must be of type 'TestValueObject'."", nameof(obj));

         return this.CompareTo(valueObject);
      }}

      /// <inheritdoc />
      public int CompareTo(TestValueObject? obj)
      {{
         if(obj is null)
            return 1;

         return Comparer<Foo>.Default.Compare(this.ReferenceField, obj.ReferenceField);
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_8_members()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectEqualityMember(EqualityComparer = nameof(StringComparer.OrdinalIgnoreCase))]
      public readonly string ReferenceField;

      [ValueObjectEqualityMember]
      public readonly int StructField;

      public string ReferenceProperty { get; }
      public int StructProperty { get; }

      public int ExpressionBodyProperty => 42;

      public int GetterExpressionProperty
      {
         get => 42;
      }

      public int GetterBodyProperty
      {
         get { return 42; }
      }

      public int SetterProperty
      {
         set { }
      }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField), nameof(StructField), nameof(ReferenceProperty), nameof(StructProperty))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(string referenceField, int structField, string referenceProperty, int structProperty)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField, structField, referenceProperty, structProperty);
      }}

      public static ValidationResult? TryCreate(
         string referenceField,
         int structField,
         string referenceProperty,
         int structProperty,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField, structField, referenceProperty, structProperty)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      private TestValueObject(string referenceField, int structField, string referenceProperty, int structProperty)
      {{
         ValidateConstructorArguments(ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         this.ReferenceField = referenceField;
         this.StructField = structField;
         this.ReferenceProperty = referenceProperty;
         this.StructProperty = structProperty;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return StringComparer.OrdinalIgnoreCase.Equals(this.ReferenceField, other.ReferenceField)
             && this.StructField.Equals(other.StructField);
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField, StringComparer.OrdinalIgnoreCase);
         hashCode.Add(this.StructField);
         return hashCode.ToHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return $""{{{{ ReferenceField = {{this.ReferenceField}}, StructField = {{this.StructField}} }}}}"";
      }}
   }}
}}
");
   }

   [Fact]
   public void Should_generate_class_with_9_members()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField1;
      public readonly string ReferenceField2;
      public readonly string ReferenceField3;
      public readonly string ReferenceField4;
      public readonly string ReferenceField5;
      public readonly string ReferenceField6;
      public readonly string ReferenceField7;
      public readonly string ReferenceField8;
      public readonly string ReferenceField9;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, $@"{_GENERATED_HEADER}
namespace Thinktecture.Tests
{{
   [Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField1), nameof(ReferenceField2), nameof(ReferenceField3), nameof(ReferenceField4), nameof(ReferenceField5), nameof(ReferenceField6), nameof(ReferenceField7), nameof(ReferenceField8), nameof(ReferenceField9))]
   partial class TestValueObject : System.IEquatable<TestValueObject?>
   {{
      private static readonly System.Type _type = typeof(TestValueObject);

      public static TestValueObject Create(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueObject(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9);
      }}

      public static ValidationResult? TryCreate(
         string referenceField1,
         string referenceField2,
         string referenceField3,
         string referenceField4,
         string referenceField5,
         string referenceField6,
         string referenceField7,
         string referenceField8,
         string referenceField9,
         [MaybeNull] out TestValueObject? obj)
      {{
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         obj = validationResult == ValidationResult.Success
               ? new TestValueObject(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9)
               : default;

         return validationResult;
      }}

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      private TestValueObject(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {{
         ValidateConstructorArguments(ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         this.ReferenceField1 = referenceField1;
         this.ReferenceField2 = referenceField2;
         this.ReferenceField3 = referenceField3;
         this.ReferenceField4 = referenceField4;
         this.ReferenceField5 = referenceField5;
         this.ReferenceField6 = referenceField6;
         this.ReferenceField7 = referenceField7;
         this.ReferenceField8 = referenceField8;
         this.ReferenceField9 = referenceField9;
      }}

      static partial void ValidateConstructorArguments(ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueObject? obj, TestValueObject? other)
      {{
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }}

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueObject? obj, TestValueObject? other)
      {{
         return !(obj == other);
      }}

      /// <inheritdoc />
      public override bool Equals(object? other)
      {{
         return other is TestValueObject obj && Equals(obj);
      }}

      /// <inheritdoc />
      public bool Equals(TestValueObject? other)
      {{
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField1 is null ? other.ReferenceField1 is null : this.ReferenceField1.Equals(other.ReferenceField1))
             && (this.ReferenceField2 is null ? other.ReferenceField2 is null : this.ReferenceField2.Equals(other.ReferenceField2))
             && (this.ReferenceField3 is null ? other.ReferenceField3 is null : this.ReferenceField3.Equals(other.ReferenceField3))
             && (this.ReferenceField4 is null ? other.ReferenceField4 is null : this.ReferenceField4.Equals(other.ReferenceField4))
             && (this.ReferenceField5 is null ? other.ReferenceField5 is null : this.ReferenceField5.Equals(other.ReferenceField5))
             && (this.ReferenceField6 is null ? other.ReferenceField6 is null : this.ReferenceField6.Equals(other.ReferenceField6))
             && (this.ReferenceField7 is null ? other.ReferenceField7 is null : this.ReferenceField7.Equals(other.ReferenceField7))
             && (this.ReferenceField8 is null ? other.ReferenceField8 is null : this.ReferenceField8.Equals(other.ReferenceField8))
             && (this.ReferenceField9 is null ? other.ReferenceField9 is null : this.ReferenceField9.Equals(other.ReferenceField9));
      }}

      /// <inheritdoc />
      public override int GetHashCode()
      {{
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField1);
         hashCode.Add(this.ReferenceField2);
         hashCode.Add(this.ReferenceField3);
         hashCode.Add(this.ReferenceField4);
         hashCode.Add(this.ReferenceField5);
         hashCode.Add(this.ReferenceField6);
         hashCode.Add(this.ReferenceField7);
         hashCode.Add(this.ReferenceField8);
         hashCode.Add(this.ReferenceField9);
         return hashCode.ToHashCode();
      }}

      /// <inheritdoc />
      public override string? ToString()
      {{
         return $""{{{{ ReferenceField1 = {{this.ReferenceField1}}, ReferenceField2 = {{this.ReferenceField2}}, ReferenceField3 = {{this.ReferenceField3}}, ReferenceField4 = {{this.ReferenceField4}}, ReferenceField5 = {{this.ReferenceField5}}, ReferenceField6 = {{this.ReferenceField6}}, ReferenceField7 = {{this.ReferenceField7}}, ReferenceField8 = {{this.ReferenceField8}}, ReferenceField9 = {{this.ReferenceField9}} }}}}"";
      }}
   }}
}}
");
   }
}
