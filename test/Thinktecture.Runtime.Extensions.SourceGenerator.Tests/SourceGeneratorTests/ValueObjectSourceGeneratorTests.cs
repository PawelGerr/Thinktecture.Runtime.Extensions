using Thinktecture.CodeAnalysis.ValueObjects;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class ValueObjectSourceGeneratorTests : SourceGeneratorTestsBase
{
   public ValueObjectSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   private const string _GENERATED_HEADER = @"// <auto-generated />
#nullable enable
";

   private const string _SIMPLE_VALUE_TYPE_OUTPUT = _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   [global::Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>
   {
      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject();
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit();

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueObject"";
      }
   }
}
";

   [Fact]
   public void Should_not_generate_code_if_not_partial()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_not_generate_code_if_generic()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject<T>
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_generate_simple_class_with_ValueObjectAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_post_init_method_if_validation_method_returns_struct()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      static partial int ValidateFactoryArguments(ref ValidationResult? validationResult)
      {
         return 42;
      }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   [global::Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>
   {
      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         var factoryArgumentsValidationResult = ValidateFactoryArguments(ref validationResult);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject();
         obj.FactoryPostInit(factoryArgumentsValidationResult);

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         var factoryArgumentsValidationResult = ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit(factoryArgumentsValidationResult);
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      private static partial int ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit(int factoryArgumentsValidationResult);

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueObject"";
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_post_init_method_if_validation_method_returns_nullable_string()
   {
      var source = @"
using System;
using Thinktecture;

#nullable enable

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      static partial string? ValidateFactoryArguments(ref ValidationResult? validationResult)
      {
         return String.Empty;
      }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   [global::Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>
   {
      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         var factoryArgumentsValidationResult = ValidateFactoryArguments(ref validationResult);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject();
         obj.FactoryPostInit(factoryArgumentsValidationResult);

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         var factoryArgumentsValidationResult = ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit(factoryArgumentsValidationResult);
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      private static partial string? ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit(string? factoryArgumentsValidationResult);

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueObject"";
      }
   }
}
");
   }

   [Fact]
   public void Should_not_generate_code_for_class_with_generic()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject<T>
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_generate_simple_class_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
   [global::Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : global::System.IEquatable<global::TestValueObject?>
   {
      private static readonly global::System.Type _type = typeof(global::TestValueObject);

      public static global::TestValueObject Create()
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::TestValueObject();
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::TestValueObject();
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit();

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::TestValueObject? obj, global::TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::TestValueObject? obj, global::TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueObject"";
      }
   }
");
   }

   [Fact]
   public void Should_generate_simple_class_with_ValueObjectAttribute_using_long_form()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObjectAttribute]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_simple_class_with_fully_qualified_ValueObjectAttribute()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
   [Thinktecture.ValueObject]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_not_generate_factory_methods_if_SkipFactoryMethods_is_true()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(SkipFactoryMethods = true)]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   [global::Thinktecture.Internal.ValueObjectConstructor()]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>
   {
      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueObject"";
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_simple_struct_with_ValueObjectAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   [global::Thinktecture.Internal.ValueObjectConstructor()]
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>
   {
      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Empty = default;

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject();
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit();

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueObject"";
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      protected override global::Thinktecture.Tests.TestValueObject ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(global::Thinktecture.Tests.TestValueObject);

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (string) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, string>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Empty = default;

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject obj)
      {
         return obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(string referenceField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      protected override global::Thinktecture.Tests.TestValueObject ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(global::Thinktecture.Tests.TestValueObject);

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (string) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, string>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Empty = default;

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject obj)
      {
         return obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(string referenceField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      protected override global::Thinktecture.Tests.TestValueObject? ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(global::Thinktecture.Tests.TestValueObject);

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (string) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, string>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, int>
   {
      /// <inheritdoc />
      protected override global::Thinktecture.Tests.TestValueObject ConvertFrom(int structField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(structField);
      }

      /// <inheritdoc />
      protected override int GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (int) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(StructField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.IFormattable, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<int, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static structField => global::Thinktecture.Tests.TestValueObject.Create(structField);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static structField => new global::Thinktecture.Tests.TestValueObject(structField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, int>(static item => item.StructField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, int>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create(int structField)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(structField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         int structField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(structField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref int structField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator int?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj is null ? null : obj.StructField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static explicit operator int(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(obj is null)
            throw new global::System.NullReferenceException();

         return obj.StructField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""structField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(int structField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(structField);
      }

      private TestValueObject(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, global::System.IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member_and_NullInFactoryMethodsYieldsNull()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      protected override global::Thinktecture.Tests.TestValueObject? ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(global::Thinktecture.Tests.TestValueObject);

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (string) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, string>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      public static global::Thinktecture.Tests.TestValueObject? Create(string? referenceField)
      {
         if(referenceField is null)
            return default;

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         string? referenceField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return null;
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, int>
   {
      /// <inheritdoc />
      protected override global::Thinktecture.Tests.TestValueObject ConvertFrom(int structField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(structField);
      }

      /// <inheritdoc />
      protected override int GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (int) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(StructField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.IFormattable, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<int, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static structField => global::Thinktecture.Tests.TestValueObject.Create(structField);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static structField => new global::Thinktecture.Tests.TestValueObject(structField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, int>(static item => item.StructField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, int>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create(int structField)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(structField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         int structField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(structField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref int structField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator int?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj is null ? null : obj.StructField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static explicit operator int(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(obj is null)
            throw new global::System.NullReferenceException();

         return obj.StructField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""structField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(int structField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(structField);
      }

      private TestValueObject(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, global::System.IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_keyed_value_type_if_second_member_is_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;

      [ValueObjectIgnore]
      public readonly string OtherField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      protected override global::Thinktecture.Tests.TestValueObject? ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(global::Thinktecture.Tests.TestValueObject);

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (string) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, string>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_having_EqualityMemberAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectEqualityMember(EqualityComparer = ""EqualityComparer<int>.Default"", Comparer = ""Comparer<int>.Default"")]
      public readonly int ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, int>
   {
      /// <inheritdoc />
      protected override global::Thinktecture.Tests.TestValueObject ConvertFrom(int referenceField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      /// <inheritdoc />
      protected override int GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (int) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.IFormattable, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<int, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, int>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, int>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, int>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create(int referenceField)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         int referenceField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref int referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator int?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static explicit operator int(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(obj is null)
            throw new global::System.NullReferenceException();

         return obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(int referenceField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(int referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref int referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return EqualityComparer<int>.Default.Equals(this.ReferenceField, other.ReferenceField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new global::System.HashCode();
         hashCode.Add(this.ReferenceField, EqualityComparer<int>.Default);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, global::System.IFormatProvider? formatProvider = null)
      {
         return this.ReferenceField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return Comparer<int>.Default.Compare(this.ReferenceField, obj.ReferenceField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_IComperable_if_member_is_not_IComperable_but_has_custom_comparer()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectEqualityMember(Comparer = ""Comparer<Foo>.Default"")]
      public readonly Foo ReferenceField;
   }

   public class Foo
   {
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestValueObject_ValueObjectTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.Foo>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      protected override global::Thinktecture.Tests.TestValueObject? ConvertFrom(global::Thinktecture.Tests.Foo? referenceField)
      {
         if(referenceField is null)
            return default(global::Thinktecture.Tests.TestValueObject);

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      /// <inheritdoc />
      protected override global::Thinktecture.Tests.Foo GetKeyValue(global::Thinktecture.Tests.TestValueObject obj)
      {
         return (global::Thinktecture.Tests.Foo) obj;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestValueObject_ValueObjectTypeConverter))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<global::Thinktecture.Tests.Foo, global::Thinktecture.Tests.TestValueObject>(global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.Foo, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.Foo, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.Foo>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.Foo>> convertToKeyExpression = static obj => obj.ReferenceField;

         var tryCreate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.Foo>(global::Thinktecture.Tests.TestValueObject.TryCreate);

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(type, typeof(global::Thinktecture.Tests.Foo), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression, tryCreate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create(global::Thinktecture.Tests.Foo referenceField)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         global::Thinktecture.Tests.Foo referenceField,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref global::Thinktecture.Tests.Foo referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Implicit conversion to the type <see cref=""Foo""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""obj"")]
      public static implicit operator global::Thinktecture.Tests.Foo?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""Foo""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueObject""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""referenceField"")]
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(global::Thinktecture.Tests.Foo? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(global::Thinktecture.Tests.Foo referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref global::Thinktecture.Tests.Foo referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject valueObject)
            throw new global::System.ArgumentException(""Argument must be of type \""TestValueObject\""."", nameof(obj));

         return this.CompareTo(valueObject);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return Comparer<Foo>.Default.Compare(this.ReferenceField, obj.ReferenceField);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_class_with_8_members()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectEqualityMember(EqualityComparer = nameof(StringComparer.OrdinalIgnoreCase))]
      public readonly string ReferenceField;

      [ValueObjectEqualityMember]
      public readonly int StructField;

      public string ReferenceProperty { get; }
      public int StructProperty { get; }

      public int ExpressionBodyProperty => 42;

      public int GetterExpressionProperty
      {
         get => 42;
      }

      public int GetterBodyProperty
      {
         get { return 42; }
      }

      public int SetterProperty
      {
         set { }
      }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField), nameof(StructField), nameof(ReferenceProperty), nameof(StructProperty))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>
   {
      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField, int structField, string referenceProperty, int structProperty)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField, structField, referenceProperty, structProperty);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         string referenceField,
         int structField,
         string referenceProperty,
         int structProperty,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField, structField, referenceProperty, structProperty);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      partial void FactoryPostInit();

      private TestValueObject(string referenceField, int structField, string referenceProperty, int structProperty)
      {
         ValidateConstructorArguments(ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         this.ReferenceField = referenceField;
         this.StructField = structField;
         this.ReferenceProperty = referenceProperty;
         this.StructProperty = structProperty;
      }

      static partial void ValidateConstructorArguments(ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return global::System.StringComparer.OrdinalIgnoreCase.Equals(this.ReferenceField, other.ReferenceField)
             && this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new global::System.HashCode();
         hashCode.Add(this.ReferenceField, global::System.StringComparer.OrdinalIgnoreCase);
         hashCode.Add(this.StructField);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return $""{{ ReferenceField = {this.ReferenceField}, StructField = {this.StructField} }}"";
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_class_with_9_members()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField1;
      public readonly string ReferenceField2;
      public readonly string ReferenceField3;
      public readonly string ReferenceField4;
      public readonly string ReferenceField5;
      public readonly string ReferenceField6;
      public readonly string ReferenceField7;
      public readonly string ReferenceField8;
      public readonly string ReferenceField9;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(ReferenceField1), nameof(ReferenceField2), nameof(ReferenceField3), nameof(ReferenceField4), nameof(ReferenceField5), nameof(ReferenceField6), nameof(ReferenceField7), nameof(ReferenceField8), nameof(ReferenceField9))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>
   {
      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         if(validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         var obj = new global::Thinktecture.Tests.TestValueObject(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9);
         obj.FactoryPostInit();

         return obj;
      }

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? TryCreate(
         string referenceField1,
         string referenceField2,
         string referenceField3,
         string referenceField4,
         string referenceField5,
         string referenceField6,
         string referenceField7,
         string referenceField8,
         string referenceField9,
         [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      partial void FactoryPostInit();

      private TestValueObject(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {
         ValidateConstructorArguments(ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         this.ReferenceField1 = referenceField1;
         this.ReferenceField2 = referenceField2;
         this.ReferenceField3 = referenceField3;
         this.ReferenceField4 = referenceField4;
         this.ReferenceField5 = referenceField5;
         this.ReferenceField6 = referenceField6;
         this.ReferenceField7 = referenceField7;
         this.ReferenceField8 = referenceField8;
         this.ReferenceField9 = referenceField9;
      }

      static partial void ValidateConstructorArguments(ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueObject""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField1 is null ? other.ReferenceField1 is null : this.ReferenceField1.Equals(other.ReferenceField1))
             && (this.ReferenceField2 is null ? other.ReferenceField2 is null : this.ReferenceField2.Equals(other.ReferenceField2))
             && (this.ReferenceField3 is null ? other.ReferenceField3 is null : this.ReferenceField3.Equals(other.ReferenceField3))
             && (this.ReferenceField4 is null ? other.ReferenceField4 is null : this.ReferenceField4.Equals(other.ReferenceField4))
             && (this.ReferenceField5 is null ? other.ReferenceField5 is null : this.ReferenceField5.Equals(other.ReferenceField5))
             && (this.ReferenceField6 is null ? other.ReferenceField6 is null : this.ReferenceField6.Equals(other.ReferenceField6))
             && (this.ReferenceField7 is null ? other.ReferenceField7 is null : this.ReferenceField7.Equals(other.ReferenceField7))
             && (this.ReferenceField8 is null ? other.ReferenceField8 is null : this.ReferenceField8.Equals(other.ReferenceField8))
             && (this.ReferenceField9 is null ? other.ReferenceField9 is null : this.ReferenceField9.Equals(other.ReferenceField9));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new global::System.HashCode();
         hashCode.Add(this.ReferenceField1);
         hashCode.Add(this.ReferenceField2);
         hashCode.Add(this.ReferenceField3);
         hashCode.Add(this.ReferenceField4);
         hashCode.Add(this.ReferenceField5);
         hashCode.Add(this.ReferenceField6);
         hashCode.Add(this.ReferenceField7);
         hashCode.Add(this.ReferenceField8);
         hashCode.Add(this.ReferenceField9);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return $""{{ ReferenceField1 = {this.ReferenceField1}, ReferenceField2 = {this.ReferenceField2}, ReferenceField3 = {this.ReferenceField3}, ReferenceField4 = {this.ReferenceField4}, ReferenceField5 = {this.ReferenceField5}, ReferenceField6 = {this.ReferenceField6}, ReferenceField7 = {this.ReferenceField7}, ReferenceField8 = {this.ReferenceField8}, ReferenceField9 = {this.ReferenceField9} }}"";
      }
   }
}
");
   }
}
