using Thinktecture.CodeAnalysis.ValueObjects;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class ValueObjectSourceGeneratorTests : SourceGeneratorTestsBase
{
   public ValueObjectSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   private const string _GENERATED_HEADER = @"// <auto-generated />
#nullable enable
";

   private const string _SIMPLE_VALUE_TYPE_OUTPUT = _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = Validate(out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit();

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return "TestValueObject";
      }
   }
}

""";

   [Fact]
   public void Should_not_generate_code_if_not_partial()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_not_generate_code_if_generic()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject<T>
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_generate_simple_class_with_ValueObjectAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_post_init_method_if_validation_method_returns_struct()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      static partial int ValidateFactoryArguments(ref ValidationResult? validationResult)
      {
         return 42;
      }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         var factoryArgumentsValidationResult = ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit(factoryArgumentsValidationResult);
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = Validate(out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      private static partial int ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit(int factoryArgumentsValidationResult);

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return "TestValueObject";
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_post_init_method_if_validation_method_returns_nullable_string()
   {
      var source = @"
using System;
using Thinktecture;

#nullable enable

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      static partial string? ValidateFactoryArguments(ref ValidationResult? validationResult)
      {
         return String.Empty;
      }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         var factoryArgumentsValidationResult = ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit(factoryArgumentsValidationResult);
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = Validate(out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      private static partial string? ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit(string? factoryArgumentsValidationResult);

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return "TestValueObject";
      }
   }
}

""");
   }

   [Fact]
   public void Should_not_generate_code_for_class_with_generic()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject<T>
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_generate_simple_class_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

   partial class TestValueObject : global::System.IEquatable<global::TestValueObject?>, global::System.Numerics.IEqualityOperators<global::TestValueObject, global::TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         out global::TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::TestValueObject();
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::TestValueObject Create()
      {
         var validationResult = Validate(out global::TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::TestValueObject? obj)
      {
         var validationResult = Validate(out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit();

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::TestValueObject? obj, global::TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::TestValueObject? obj, global::TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return "TestValueObject";
      }
   }

""");
   }

   [Fact]
   public void Should_generate_simple_class_with_ValueObjectAttribute_using_long_form()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObjectAttribute]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_generate_simple_class_with_fully_qualified_ValueObjectAttribute()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
   [Thinktecture.ValueObject]
	public partial class TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _SIMPLE_VALUE_TYPE_OUTPUT);
   }

   [Fact]
   public void Should_not_generate_factory_methods_if_SkipFactoryMethods_is_true()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(SkipFactoryMethods = true)]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IFormattable, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IComparisonOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IKeyedValueObject<int>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<int, global::Thinktecture.Tests.TestValueObject>? convertFromKey = null;
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>>? convertFromKeyExpression = null;
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static structField => new global::Thinktecture.Tests.TestValueObject(structField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, int>(static item => item.StructField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      int global::Thinktecture.IKeyedValueObject<int>.GetKey()
      {
         return this.StructField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator int?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.StructField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static explicit operator int(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(obj is null)
            throw new global::System.NullReferenceException();

         return obj.StructField;
      }

      private TestValueObject(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, global::System.IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThan(TSelf, TOther)" />
      public static bool operator <(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField < right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThanOrEqual(TSelf, TOther)" />
      public static bool operator <=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField <= right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThan(TSelf, TOther)" />
      public static bool operator >(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField > right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThanOrEqual(TSelf, TOther)" />
      public static bool operator >=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField >= right.StructField;
   }
}

""");
   }

   [Fact]
   public void Should_generate_simple_struct_with_ValueObjectAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Empty = default;

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = Validate(out global::Thinktecture.Tests.TestValueObject obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = Validate(out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit();

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return "TestValueObject";
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_struct_with_custom_default_instance_property_name()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(DefaultInstancePropertyName = ""Null"")]
	public readonly partial struct TestValueObject
	{
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Null = default;

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject();
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create()
      {
         var validationResult = Validate(out global::Thinktecture.Tests.TestValueObject obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = Validate(out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult);

      partial void FactoryPostInit();

      private TestValueObject()
      {
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return "TestValueObject";
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>))]
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::Thinktecture.IKeyedValueObject<string>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, string>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<string, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Empty = default;

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string? referenceField,
         out global::Thinktecture.Tests.TestValueObject obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return new global::System.ComponentModel.DataAnnotations.ValidationResult("The argument 'referenceField' must not be null.", global::Thinktecture.SingleItem.Collection(nameof(global::Thinktecture.Tests.TestValueObject.ReferenceField)));
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = Validate(referenceField, out global::Thinktecture.Tests.TestValueObject obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = Validate(referenceField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      string global::Thinktecture.IKeyedValueObject<string>.GetKey()
      {
         return this.ReferenceField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="string"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="ReferenceField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="string"/>.
      /// </summary>
      /// <param name="referenceField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(string referenceField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject obj)
      {
         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out result!);
         return validationResult is null;
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_struct_with_int_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, int>))]
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IFormattable, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IAdditionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.ISubtractionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IMultiplyOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IDivisionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IComparisonOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IKeyedValueObject<int>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, int>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<int, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static structField => global::Thinktecture.Tests.TestValueObject.Create(structField);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static structField => new global::Thinktecture.Tests.TestValueObject(structField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, int>(static item => item.StructField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Empty = default;

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         int structField,
         out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(structField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(int structField)
      {
         var validationResult = Validate(structField, out global::Thinktecture.Tests.TestValueObject obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         int structField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = Validate(structField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref int structField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      int global::Thinktecture.IKeyedValueObject<int>.GetKey()
      {
         return this.StructField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator int?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.StructField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/>.</returns>
      public static implicit operator int(global::Thinktecture.Tests.TestValueObject obj)
      {
         return obj.StructField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="int"/>.
      /// </summary>
      /// <param name="structField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(int structField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(structField);
      }

      private TestValueObject(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, global::System.IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject obj)
      {
         return this.StructField.CompareTo(obj.StructField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var key = int.Parse(s, provider);
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(key, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         if(!int.TryParse(s, provider, out var key))
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(key, out result!);
         return validationResult is null;
      }

      /// <inheritdoc cref="global::System.Numerics.IAdditionOperators{TSelf, TOther, TResult}.op_Addition(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator +(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField + right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IAdditionOperators{TSelf, TOther, TResult}.op_Addition(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked +(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField + right.StructField));

      /// <inheritdoc cref="global::System.Numerics.ISubtractionOperators{TSelf, TOther, TResult}.op_Subtraction(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator -(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField - right.StructField);

      /// <inheritdoc cref="global::System.Numerics.ISubtractionOperators{TSelf, TOther, TResult}.op_Subtraction(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked -(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField - right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IMultiplyOperators{TSelf, TOther, TResult}.op_Multiply(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator *(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField * right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IMultiplyOperators{TSelf, TOther, TResult}.op_Multiply(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked *(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField * right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IDivisionOperators{TSelf, TOther, TResult}.op_Division(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator /(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField / right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IDivisionOperators{TSelf, TOther, TResult}.op_Division(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked /(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField / right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThan(TSelf, TOther)" />
      public static bool operator <(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField < right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThanOrEqual(TSelf, TOther)" />
      public static bool operator <=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField <= right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThan(TSelf, TOther)" />
      public static bool operator >(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField > right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThanOrEqual(TSelf, TOther)" />
      public static bool operator >=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField >= right.StructField;
   }
}

""");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>))]
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::Thinktecture.IKeyedValueObject<string>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, string>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<string, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Empty = default;

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string? referenceField,
         out global::Thinktecture.Tests.TestValueObject obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return new global::System.ComponentModel.DataAnnotations.ValidationResult("The argument 'referenceField' must not be null.", global::Thinktecture.SingleItem.Collection(nameof(global::Thinktecture.Tests.TestValueObject.ReferenceField)));
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = Validate(referenceField, out global::Thinktecture.Tests.TestValueObject obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = Validate(referenceField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      string global::Thinktecture.IKeyedValueObject<string>.GetKey()
      {
         return this.ReferenceField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="string"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="ReferenceField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="string"/>.
      /// </summary>
      /// <param name="referenceField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(string referenceField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject obj)
      {
         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out result!);
         return validationResult is null;
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_struct_with_string_key_member_and_EmptyStringInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(EmptyStringInFactoryMethodsYieldsNull = true)]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>))]
   partial struct TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::Thinktecture.IKeyedValueObject<string>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, string>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<string, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static readonly global::Thinktecture.Tests.TestValueObject Empty = default;

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string? referenceField,
         out global::Thinktecture.Tests.TestValueObject obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return new global::System.ComponentModel.DataAnnotations.ValidationResult("The argument 'referenceField' must not be null.", global::Thinktecture.SingleItem.Collection(nameof(global::Thinktecture.Tests.TestValueObject.ReferenceField)));
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = Validate(referenceField, out global::Thinktecture.Tests.TestValueObject obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject obj)
      {
         var validationResult = Validate(referenceField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      string global::Thinktecture.IKeyedValueObject<string>.GetKey()
      {
         return this.ReferenceField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="string"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="ReferenceField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="string"/>.
      /// </summary>
      /// <param name="referenceField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(string referenceField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject obj, global::Thinktecture.Tests.TestValueObject other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject other)
      {
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject obj)
      {
         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out result!);
         return validationResult is null;
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::Thinktecture.IKeyedValueObject<string>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, string>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<string, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string? referenceField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return new global::System.ComponentModel.DataAnnotations.ValidationResult("The argument 'referenceField' must not be null.", global::Thinktecture.SingleItem.Collection(nameof(global::Thinktecture.Tests.TestValueObject.ReferenceField)));
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = Validate(referenceField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(referenceField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      string global::Thinktecture.IKeyedValueObject<string>.GetKey()
      {
         return this.ReferenceField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="string"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="ReferenceField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="string"/>.
      /// </summary>
      /// <param name="referenceField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("referenceField")]
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out result!);
         return validationResult is null;
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, int>))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IFormattable, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IAdditionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.ISubtractionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IMultiplyOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IDivisionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IComparisonOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IKeyedValueObject<int>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, int>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<int, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static structField => global::Thinktecture.Tests.TestValueObject.Create(structField);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static structField => new global::Thinktecture.Tests.TestValueObject(structField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, int>(static item => item.StructField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         int structField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(structField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(int structField)
      {
         var validationResult = Validate(structField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         int structField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(structField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref int structField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      int global::Thinktecture.IKeyedValueObject<int>.GetKey()
      {
         return this.StructField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator int?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.StructField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static explicit operator int(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(obj is null)
            throw new global::System.NullReferenceException();

         return obj.StructField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="int"/>.
      /// </summary>
      /// <param name="structField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(int structField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(structField);
      }

      private TestValueObject(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, global::System.IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var key = int.Parse(s, provider);
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(key, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         if(!int.TryParse(s, provider, out var key))
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(key, out result!);
         return validationResult is null;
      }

      /// <inheritdoc cref="global::System.Numerics.IAdditionOperators{TSelf, TOther, TResult}.op_Addition(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator +(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField + right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IAdditionOperators{TSelf, TOther, TResult}.op_Addition(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked +(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField + right.StructField));

      /// <inheritdoc cref="global::System.Numerics.ISubtractionOperators{TSelf, TOther, TResult}.op_Subtraction(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator -(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField - right.StructField);

      /// <inheritdoc cref="global::System.Numerics.ISubtractionOperators{TSelf, TOther, TResult}.op_Subtraction(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked -(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField - right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IMultiplyOperators{TSelf, TOther, TResult}.op_Multiply(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator *(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField * right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IMultiplyOperators{TSelf, TOther, TResult}.op_Multiply(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked *(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField * right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IDivisionOperators{TSelf, TOther, TResult}.op_Division(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator /(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField / right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IDivisionOperators{TSelf, TOther, TResult}.op_Division(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked /(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField / right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThan(TSelf, TOther)" />
      public static bool operator <(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField < right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThanOrEqual(TSelf, TOther)" />
      public static bool operator <=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField <= right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThan(TSelf, TOther)" />
      public static bool operator >(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField > right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThanOrEqual(TSelf, TOther)" />
      public static bool operator >=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField >= right.StructField;
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member_and_NullInFactoryMethodsYieldsNull()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::Thinktecture.IKeyedValueObject<string>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, string>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<string, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string? referenceField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("referenceField")]
      public static global::Thinktecture.Tests.TestValueObject? Create(string? referenceField)
      {
         var validationResult = Validate(referenceField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj;
      }

      public static bool TryCreate(
         string? referenceField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(referenceField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      string global::Thinktecture.IKeyedValueObject<string>.GetKey()
      {
         return this.ReferenceField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="string"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="ReferenceField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="string"/>.
      /// </summary>
      /// <param name="referenceField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("referenceField")]
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out result!);
         return validationResult is null;
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_string_key_member_and_EmptyStringInFactoryMethodsYieldsNull()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(EmptyStringInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::Thinktecture.IKeyedValueObject<string>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, string>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<string, global::Thinktecture.Tests.TestValueObject?> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject?>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string? referenceField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(global::System.String.IsNullOrWhiteSpace(referenceField))
         {
            obj = default;
            return global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject? Create(string? referenceField)
      {
         var validationResult = Validate(referenceField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj;
      }

      public static bool TryCreate(
         string? referenceField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(referenceField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      string global::Thinktecture.IKeyedValueObject<string>.GetKey()
      {
         return this.ReferenceField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="string"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="ReferenceField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="string"/>.
      /// </summary>
      /// <param name="referenceField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out result!);
         return validationResult is null;
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, int>))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IFormattable, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IAdditionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.ISubtractionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IMultiplyOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IDivisionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IComparisonOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IKeyedValueObject<int>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, int>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<int, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static structField => global::Thinktecture.Tests.TestValueObject.Create(structField);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static structField => new global::Thinktecture.Tests.TestValueObject(structField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, int>(static item => item.StructField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         int structField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(structField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(int structField)
      {
         var validationResult = Validate(structField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         int structField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(structField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref int structField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      int global::Thinktecture.IKeyedValueObject<int>.GetKey()
      {
         return this.StructField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator int?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.StructField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static explicit operator int(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(obj is null)
            throw new global::System.NullReferenceException();

         return obj.StructField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="int"/>.
      /// </summary>
      /// <param name="structField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(int structField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(structField);
      }

      private TestValueObject(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, global::System.IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var key = int.Parse(s, provider);
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(key, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         if(!int.TryParse(s, provider, out var key))
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(key, out result!);
         return validationResult is null;
      }

      /// <inheritdoc cref="global::System.Numerics.IAdditionOperators{TSelf, TOther, TResult}.op_Addition(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator +(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField + right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IAdditionOperators{TSelf, TOther, TResult}.op_Addition(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked +(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField + right.StructField));

      /// <inheritdoc cref="global::System.Numerics.ISubtractionOperators{TSelf, TOther, TResult}.op_Subtraction(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator -(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField - right.StructField);

      /// <inheritdoc cref="global::System.Numerics.ISubtractionOperators{TSelf, TOther, TResult}.op_Subtraction(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked -(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField - right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IMultiplyOperators{TSelf, TOther, TResult}.op_Multiply(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator *(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField * right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IMultiplyOperators{TSelf, TOther, TResult}.op_Multiply(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked *(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField * right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IDivisionOperators{TSelf, TOther, TResult}.op_Division(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator /(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField / right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IDivisionOperators{TSelf, TOther, TResult}.op_Division(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked /(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField / right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThan(TSelf, TOther)" />
      public static bool operator <(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField < right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThanOrEqual(TSelf, TOther)" />
      public static bool operator <=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField <= right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThan(TSelf, TOther)" />
      public static bool operator >(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField > right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThanOrEqual(TSelf, TOther)" />
      public static bool operator >=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField >= right.StructField;
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_and_EmptyStringInFactoryMethodsYieldsNull_should_be_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject(EmptyStringInFactoryMethodsYieldsNull = true)]
	public partial class TestValueObject
	{
      public readonly int StructField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, int>))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IFormattable, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IAdditionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.ISubtractionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IMultiplyOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IDivisionOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject>, global::System.Numerics.IComparisonOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IKeyedValueObject<int>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, int>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<int, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static structField => global::Thinktecture.Tests.TestValueObject.Create(structField);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static structField => new global::Thinktecture.Tests.TestValueObject(structField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, int>(static item => item.StructField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, int>> convertToKeyExpression = static obj => obj.StructField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         int structField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(structField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(int structField)
      {
         var validationResult = Validate(structField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         int structField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(structField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref int structField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      int global::Thinktecture.IKeyedValueObject<int>.GetKey()
      {
         return this.StructField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator int?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.StructField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="StructField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static explicit operator int(global::Thinktecture.Tests.TestValueObject obj)
      {
         if(obj is null)
            throw new global::System.NullReferenceException();

         return obj.StructField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="int"/>.
      /// </summary>
      /// <param name="structField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests.TestValueObject(int structField)
      {
         return global::Thinktecture.Tests.TestValueObject.Create(structField);
      }

      private TestValueObject(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, global::System.IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var key = int.Parse(s, provider);
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(key, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         if(!int.TryParse(s, provider, out var key))
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(key, out result!);
         return validationResult is null;
      }

      /// <inheritdoc cref="global::System.Numerics.IAdditionOperators{TSelf, TOther, TResult}.op_Addition(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator +(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField + right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IAdditionOperators{TSelf, TOther, TResult}.op_Addition(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked +(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField + right.StructField));

      /// <inheritdoc cref="global::System.Numerics.ISubtractionOperators{TSelf, TOther, TResult}.op_Subtraction(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator -(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField - right.StructField);

      /// <inheritdoc cref="global::System.Numerics.ISubtractionOperators{TSelf, TOther, TResult}.op_Subtraction(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked -(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField - right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IMultiplyOperators{TSelf, TOther, TResult}.op_Multiply(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator *(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField * right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IMultiplyOperators{TSelf, TOther, TResult}.op_Multiply(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked *(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField * right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IDivisionOperators{TSelf, TOther, TResult}.op_Division(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator /(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(left.StructField / right.StructField);

      /// <inheritdoc cref="global::System.Numerics.IDivisionOperators{TSelf, TOther, TResult}.op_Division(TSelf, TOther)" />
      public static global::Thinktecture.Tests.TestValueObject operator checked /(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => Create(checked(left.StructField / right.StructField));

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThan(TSelf, TOther)" />
      public static bool operator <(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField < right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_LessThanOrEqual(TSelf, TOther)" />
      public static bool operator <=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField <= right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThan(TSelf, TOther)" />
      public static bool operator >(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField > right.StructField;

      /// <inheritdoc cref="global::System.Numerics.IComparisonOperators{TSelf, TOther, TResult}.op_GreaterThanOrEqual(TSelf, TOther)" />
      public static bool operator >=(global::Thinktecture.Tests.TestValueObject left, global::Thinktecture.Tests.TestValueObject right) => left.StructField >= right.StructField;
   }
}

""");
   }

   [Fact]
   public void Should_generate_keyed_value_type_if_second_member_is_ignored()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;

      [ValueObjectIgnore]
      public readonly string OtherField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                               o.ReferenceField,
                                                                                                               o.OtherField
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string referenceField,
         string otherField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref otherField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField, otherField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField, string otherField)
      {
         var validationResult = Validate(referenceField, otherField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         string referenceField,
         string otherField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(referenceField, otherField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField, ref string otherField);

      partial void FactoryPostInit();

      private TestValueObject(string referenceField, string otherField)
      {
         ValidateConstructorArguments(ref referenceField, ref otherField);

         this.ReferenceField = referenceField;
         this.OtherField = otherField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField, ref string otherField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField))
             && (this.OtherField is null ? other.OtherField is null : this.OtherField.Equals(other.OtherField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(this.ReferenceField,
            this.OtherField);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return $"{{ ReferenceField = {this.ReferenceField}, OtherField = {this.OtherField} }}";
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_int_key_member_having_EqualityMemberAttribute()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectMemberEqualityComparerAttribute<StringComparerOrdinalIgnoreCase, string>]
      [ValueObjectMemberComparer<StringComparerOrdinalIgnoreCase, string>]
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, string>))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::System.IComparable, global::System.IComparable<global::Thinktecture.Tests.TestValueObject>, global::System.IParsable<global::Thinktecture.Tests.TestValueObject>, global::Thinktecture.IKeyedValueObject<string>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, string>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<string, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<string, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, string>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, string>> convertToKeyExpression = static obj => obj.ReferenceField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(string), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string? referenceField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return new global::System.ComponentModel.DataAnnotations.ValidationResult("The argument 'referenceField' must not be null.", global::Thinktecture.SingleItem.Collection(nameof(global::Thinktecture.Tests.TestValueObject.ReferenceField)));
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField)
      {
         var validationResult = Validate(referenceField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         string referenceField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(referenceField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      string global::Thinktecture.IKeyedValueObject<string>.GetKey()
      {
         return this.ReferenceField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="string"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="ReferenceField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator string?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="string"/>.
      /// </summary>
      /// <param name="referenceField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("referenceField")]
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return StringComparerOrdinalIgnoreCase.EqualityComparer.Equals(this.ReferenceField, other.ReferenceField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new global::System.HashCode();
         hashCode.Add(this.ReferenceField, StringComparerOrdinalIgnoreCase.EqualityComparer);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not global::Thinktecture.Tests.TestValueObject item)
            throw new global::System.ArgumentException("Argument must be of type \"TestValueObject\".", nameof(obj));

         return this.CompareTo(item);
      }

      /// <inheritdoc />
      public int CompareTo(global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(obj is null)
            return 1;

         return StringComparerOrdinalIgnoreCase.Comparer.Compare(this.ReferenceField, obj.ReferenceField);
      }

      /// <inheritdoc />
      public static global::Thinktecture.Tests.TestValueObject Parse(string s, global::System.IFormatProvider? provider)
      {
         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out var result);

         if(validationResult is null)
            return result!;

         throw new global::System.FormatException(validationResult.ErrorMessage);
      }

      /// <inheritdoc />
      public static bool TryParse(string? s, global::System.IFormatProvider? provider, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestValueObject result)
      {
         if(s is null)
         {
            result = default;
            return false;
         }

         var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(s, out result!);
         return validationResult is null;
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_IComparable_if_member_is_not_IComparable_but_has_custom_comparer()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectMemberEqualityComparer<ComparerAccessors.Default<Foo>, Foo>]
      public readonly Foo ReferenceField;
   }

   public class Foo
   {
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.Foo>))]
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.Foo>, global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.Foo>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<global::Thinktecture.Tests.Foo, global::Thinktecture.Tests.TestValueObject> convertFromKey = new (global::Thinktecture.Tests.TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.Foo, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpression = static referenceField => global::Thinktecture.Tests.TestValueObject.Create(referenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.Foo, global::Thinktecture.Tests.TestValueObject>> convertFromKeyExpressionViaCtor = static referenceField => new global::Thinktecture.Tests.TestValueObject(referenceField);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.Foo>(static item => item.ReferenceField);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.Foo>> convertToKeyExpression = static obj => obj.ReferenceField;

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(global::Thinktecture.Tests.Foo), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         global::Thinktecture.Tests.Foo? referenceField,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return new global::System.ComponentModel.DataAnnotations.ValidationResult("The argument 'referenceField' must not be null.", global::Thinktecture.SingleItem.Collection(nameof(global::Thinktecture.Tests.TestValueObject.ReferenceField)));
         }

         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(global::Thinktecture.Tests.Foo referenceField)
      {
         var validationResult = Validate(referenceField, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         global::Thinktecture.Tests.Foo referenceField,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(referenceField, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref global::Thinktecture.Tests.Foo referenceField);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      global::Thinktecture.Tests.Foo global::Thinktecture.IKeyedValueObject<global::Thinktecture.Tests.Foo>.GetKey()
      {
         return this.ReferenceField;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="Foo"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="ReferenceField"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator global::Thinktecture.Tests.Foo?(global::Thinktecture.Tests.TestValueObject? obj)
      {
         return obj?.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="Foo"/>.
      /// </summary>
      /// <param name="referenceField">Value to covert.</param>
      /// <returns>An instance of <see cref="TestValueObject"/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("referenceField")]
      public static explicit operator global::Thinktecture.Tests.TestValueObject?(global::Thinktecture.Tests.Foo? referenceField)
      {
         if(referenceField is null)
            return null;

         return global::Thinktecture.Tests.TestValueObject.Create(referenceField);
      }

      private TestValueObject(global::Thinktecture.Tests.Foo referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref global::Thinktecture.Tests.Foo referenceField);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return global::Thinktecture.ComparerAccessors.Default<global::Thinktecture.Tests.Foo>.EqualityComparer.Equals(this.ReferenceField, other.ReferenceField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new global::System.HashCode();
         hashCode.Add(this.ReferenceField, global::Thinktecture.ComparerAccessors.Default<global::Thinktecture.Tests.Foo>.EqualityComparer);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.ReferenceField.ToString();
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_8_members()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      [ValueObjectMemberEqualityComparer<ComparerAccessors.StringOrdinalIgnoreCase, string>]
      public readonly string ReferenceField;

      [ValueObjectMemberEqualityComparer<ComparerAccessors.Default<int>, int>]
      public readonly int StructField;

      public string ReferenceProperty { get; }
      public int StructProperty { get; }

      public int ExpressionBodyProperty => 42;

      public int GetterExpressionProperty
      {
         get => 42;
      }

      public int GetterBodyProperty
      {
         get { return 42; }
      }

      public int SetterProperty
      {
         set { }
      }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                               o.ReferenceField,
                                                                                                               o.StructField,
                                                                                                               o.ReferenceProperty,
                                                                                                               o.StructProperty
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string referenceField,
         int structField,
         string referenceProperty,
         int structProperty,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField, structField, referenceProperty, structProperty);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField, int structField, string referenceProperty, int structProperty)
      {
         var validationResult = Validate(referenceField, structField, referenceProperty, structProperty, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         string referenceField,
         int structField,
         string referenceProperty,
         int structProperty,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(referenceField, structField, referenceProperty, structProperty, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      partial void FactoryPostInit();

      private TestValueObject(string referenceField, int structField, string referenceProperty, int structProperty)
      {
         ValidateConstructorArguments(ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         this.ReferenceField = referenceField;
         this.StructField = structField;
         this.ReferenceProperty = referenceProperty;
         this.StructProperty = structProperty;
      }

      static partial void ValidateConstructorArguments(ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return global::Thinktecture.ComparerAccessors.StringOrdinalIgnoreCase.EqualityComparer.Equals(this.ReferenceField, other.ReferenceField)
             && global::Thinktecture.ComparerAccessors.Default<int>.EqualityComparer.Equals(this.StructField, other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new global::System.HashCode();
         hashCode.Add(this.ReferenceField, global::Thinktecture.ComparerAccessors.StringOrdinalIgnoreCase.EqualityComparer);
         hashCode.Add(this.StructField, global::Thinktecture.ComparerAccessors.Default<int>.EqualityComparer);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return $"{{ ReferenceField = {this.ReferenceField}, StructField = {this.StructField} }}";
      }
   }
}

""");
   }

   [Fact]
   public void Should_generate_class_with_9_members()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField1;
      public readonly string ReferenceField2;
      public readonly string ReferenceField3;
      public readonly string ReferenceField4;
      public readonly string ReferenceField5;
      public readonly string ReferenceField6;
      public readonly string ReferenceField7;
      public readonly string ReferenceField8;
      public readonly string ReferenceField9;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly);
      AssertOutput(output, _GENERATED_HEADER + """

namespace Thinktecture.Tests
{
   partial class TestValueObject : global::System.IEquatable<global::Thinktecture.Tests.TestValueObject?>, global::System.Numerics.IEqualityOperators<global::Thinktecture.Tests.TestValueObject, global::Thinktecture.Tests.TestValueObject, bool>, global::Thinktecture.IComplexValueObject
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Linq.Expressions.Expression<global::System.Func<TestValueObject, object>> action = o => new
                                                                                                            {
                                                                                                               o.ReferenceField1,
                                                                                                               o.ReferenceField2,
                                                                                                               o.ReferenceField3,
                                                                                                               o.ReferenceField4,
                                                                                                               o.ReferenceField5,
                                                                                                               o.ReferenceField6,
                                                                                                               o.ReferenceField7,
                                                                                                               o.ReferenceField8,
                                                                                                               o.ReferenceField9
                                                                                                            };

         var members = new global::System.Collections.Generic.List<global::System.Reflection.MemberInfo>();

         foreach (var arg in ((global::System.Linq.Expressions.NewExpression)action.Body).Arguments)
         {
            members.Add(((global::System.Linq.Expressions.MemberExpression)arg).Member);
         }

         var type = typeof(global::Thinktecture.Tests.TestValueObject);
         var metadata = new global::Thinktecture.Internal.ComplexValueObjectMetadata(type, members.AsReadOnly());

         global::Thinktecture.Internal.ComplexValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly global::System.Type _type = typeof(global::Thinktecture.Tests.TestValueObject);

      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(
         string referenceField1,
         string referenceField2,
         string referenceField3,
         string referenceField4,
         string referenceField5,
         string referenceField6,
         string referenceField7,
         string referenceField8,
         string referenceField9,
         out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         if (validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
         {
            obj = new global::Thinktecture.Tests.TestValueObject(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationResult;
      }

      public static global::Thinktecture.Tests.TestValueObject Create(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {
         var validationResult = Validate(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9, out global::Thinktecture.Tests.TestValueObject? obj);

         if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationResult!.ErrorMessage ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(
         string referenceField1,
         string referenceField2,
         string referenceField3,
         string referenceField4,
         string referenceField5,
         string referenceField6,
         string referenceField7,
         string referenceField8,
         string referenceField9,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests.TestValueObject? obj)
      {
         var validationResult = Validate(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9, out obj);

         return validationResult == global::System.ComponentModel.DataAnnotations.ValidationResult.Success;
      }

      static partial void ValidateFactoryArguments(ref global::System.ComponentModel.DataAnnotations.ValidationResult? validationResult, ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      partial void FactoryPostInit();

      private TestValueObject(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {
         ValidateConstructorArguments(ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         this.ReferenceField1 = referenceField1;
         this.ReferenceField2 = referenceField2;
         this.ReferenceField3 = referenceField3;
         this.ReferenceField4 = referenceField4;
         this.ReferenceField5 = referenceField5;
         this.ReferenceField6 = referenceField6;
         this.ReferenceField7 = referenceField7;
         this.ReferenceField8 = referenceField8;
         this.ReferenceField9 = referenceField9;
      }

      static partial void ValidateConstructorArguments(ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref="TestValueObject"/>.
      /// </summary>
      /// <param name="obj">Instance to compare.</param>
      /// <param name="other">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestValueObject? obj, global::Thinktecture.Tests.TestValueObject? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestValueObject? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField1 is null ? other.ReferenceField1 is null : this.ReferenceField1.Equals(other.ReferenceField1))
             && (this.ReferenceField2 is null ? other.ReferenceField2 is null : this.ReferenceField2.Equals(other.ReferenceField2))
             && (this.ReferenceField3 is null ? other.ReferenceField3 is null : this.ReferenceField3.Equals(other.ReferenceField3))
             && (this.ReferenceField4 is null ? other.ReferenceField4 is null : this.ReferenceField4.Equals(other.ReferenceField4))
             && (this.ReferenceField5 is null ? other.ReferenceField5 is null : this.ReferenceField5.Equals(other.ReferenceField5))
             && (this.ReferenceField6 is null ? other.ReferenceField6 is null : this.ReferenceField6.Equals(other.ReferenceField6))
             && (this.ReferenceField7 is null ? other.ReferenceField7 is null : this.ReferenceField7.Equals(other.ReferenceField7))
             && (this.ReferenceField8 is null ? other.ReferenceField8 is null : this.ReferenceField8.Equals(other.ReferenceField8))
             && (this.ReferenceField9 is null ? other.ReferenceField9 is null : this.ReferenceField9.Equals(other.ReferenceField9));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new global::System.HashCode();
         hashCode.Add(this.ReferenceField1);
         hashCode.Add(this.ReferenceField2);
         hashCode.Add(this.ReferenceField3);
         hashCode.Add(this.ReferenceField4);
         hashCode.Add(this.ReferenceField5);
         hashCode.Add(this.ReferenceField6);
         hashCode.Add(this.ReferenceField7);
         hashCode.Add(this.ReferenceField8);
         hashCode.Add(this.ReferenceField9);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return $"{{ ReferenceField1 = {this.ReferenceField1}, ReferenceField2 = {this.ReferenceField2}, ReferenceField3 = {this.ReferenceField3}, ReferenceField4 = {this.ReferenceField4}, ReferenceField5 = {this.ReferenceField5}, ReferenceField6 = {this.ReferenceField6}, ReferenceField7 = {this.ReferenceField7}, ReferenceField8 = {this.ReferenceField8}, ReferenceField9 = {this.ReferenceField9} }}";
      }
   }
}

""");
   }
}
