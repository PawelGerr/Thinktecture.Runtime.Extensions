using System;
using System.Collections.Generic;
using System.Linq;
using FluentAssertions;
using MessagePack;
using Thinktecture.CodeAnalysis;
using Thinktecture.Formatters;
using Xunit;
using Xunit.Abstractions;

namespace Thinktecture.SourceGeneratorTests
{
   public class EnumSourceGeneratorTests : SourceGeneratorTestsBase
   {
      public EnumSourceGeneratorTests(ITestOutputHelper output)
         : base(output)
      {
      }

      private const string _OUTPUT_OF_SIMPLE_ENUM = @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnum_EnumTypeConverter : Thinktecture.EnumTypeConverter<TestEnum, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""key"")]
      protected override TestEnum? ConvertFrom(string? key)
      {
         if(TestEnum.TryGet(key, out var item))
            return item;

         throw new NotSupportedException($""There is no item of type 'TestEnum' with the identifier '{key}'."");
      }
   }

   [System.ComponentModel.TypeConverter(typeof(TestEnum_EnumTypeConverter))]
   partial class TestEnum : IEquatable<TestEnum?>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convert = new Func<string?, TestEnum?>(TestEnum.Get);
         Expression<Func<string?, TestEnum?>> convertExpression = key => TestEnum.Get(key);

         var enumType = typeof(TestEnum);
         var metadata = new EnumMetadata(enumType, typeof(string), convert, convertExpression);

         EnumMetadataLookup.AddEnumMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(TestEnum).GetHashCode() * 397;
      private static readonly IEqualityComparer<string?> _defaultKeyComparerMember = StringComparer.OrdinalIgnoreCase;

      private static IReadOnlyDictionary<string, TestEnum>? _itemsLookup;
      private static IReadOnlyDictionary<string, TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static IReadOnlyList<TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static IReadOnlyList<TestEnum> Items => _items ??= ItemsLookup.Values.ToList().AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [NotNull]
      public string Key { get; }

      private TestEnum(string key)
      {
        if (key is null)
            throw new ArgumentNullException(nameof(key));

         ValidateConstructorArguments(key);

         this.Key = key;
      }

      static partial void ValidateConstructorArguments(string key);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string IEnum<string>.GetKey()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      /// <exception cref=""KeyNotFoundException"">If there is no item with the provided <paramref name=""key""/>.</exception>
      [return: NotNullIfNotNull(""key"")]
      public static TestEnum? Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            throw new KeyNotFoundException($""There is no item of type 'TestEnum' with the identifier '{key}'."");
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([AllowNull] string key, [MaybeNullWhen(false)] out TestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Implicit conversion to the type of <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""Key""/> of provided <paramref name=""item""/> or <c>null</c> if a<paramref name=""item""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""item"")]
      public static implicit operator string?(TestEnum? item)
      {
         return item is null ? default : item.Key;
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestEnum? item1, TestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestEnum? item1, TestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(TestEnum? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return _defaultKeyComparerMember.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _defaultKeyComparerMember.GetHashCode(this.Key);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Key.ToString();
      }

      private static IReadOnlyDictionary<string, TestEnum> GetLookup()
      {
         var lookup = new Dictionary<string, TestEnum>(_defaultKeyComparerMember);

         void AddItem(TestEnum item, string itemName)
         {
            if(item is null)
               throw new ArgumentNullException($""The item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(item.Key is null)
               throw new ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if (lookup.ContainsKey(item.Key))
               throw new ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(Item1, ""Item1"");
         AddItem(Item2, ""Item2"");

         return lookup;
      }
   }
}
";

      [Fact]
      public void Should_generate_simple_class_which_implements_IEnum()
      {
         var source = @"
using System;

namespace Thinktecture.EnumLikeClass
{
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(IEnum<>).Assembly);
         output.Should().Be(_OUTPUT_OF_SIMPLE_ENUM);
      }

      [Fact]
      public void Should_generate_simple_class_which_implements_IEnum_if_IEnum_is_fully_qualified()
      {
         var source = @"
using System;

namespace Thinktecture.EnumLikeClass
{
	public partial class TestEnum : Thinktecture.IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(IEnum<>).Assembly);
         output.Should().Be(_OUTPUT_OF_SIMPLE_ENUM);
      }

      [Fact]
      public void Should_generate_simple_class_which_implements_IValidatableEnum()
      {
         var source = @"
using System;

namespace Thinktecture.EnumLikeClass
{
	public partial class TestEnum : IValidatableEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(IValidatableEnum<>).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnum_EnumTypeConverter : Thinktecture.EnumTypeConverter<TestEnum, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""key"")]
      protected override TestEnum? ConvertFrom(string? key)
      {
         return TestEnum.Get(key);
      }
   }

   [System.ComponentModel.TypeConverter(typeof(TestEnum_EnumTypeConverter))]
   partial class TestEnum : IEquatable<TestEnum?>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convert = new Func<string?, TestEnum?>(TestEnum.Get);
         Expression<Func<string?, TestEnum?>> convertExpression = key => TestEnum.Get(key);

         var enumType = typeof(TestEnum);
         var metadata = new EnumMetadata(enumType, typeof(string), convert, convertExpression);

         EnumMetadataLookup.AddEnumMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(TestEnum).GetHashCode() * 397;
      private static readonly IEqualityComparer<string?> _defaultKeyComparerMember = StringComparer.OrdinalIgnoreCase;

      private static IReadOnlyDictionary<string, TestEnum>? _itemsLookup;
      private static IReadOnlyDictionary<string, TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static IReadOnlyList<TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static IReadOnlyList<TestEnum> Items => _items ??= ItemsLookup.Values.ToList().AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [NotNull]
      public string Key { get; }

      /// <inheritdoc />
      public bool IsValid { get; }

      /// <summary>
      /// Checks whether current enumeration item is valid.
      /// </summary>
      /// <exception cref=""InvalidOperationException"">The enumeration item is not valid.</exception>
      public void EnsureValid()
      {
         if (!IsValid)
            throw new InvalidOperationException($""The current enumeration item of type 'TestEnum' with identifier '{this.Key}' is not valid."");
      }

      private TestEnum(string key)
         : this(key, true)
      {
      }

      private TestEnum(string key, bool isValid)
      {
        if (key is null)
            throw new ArgumentNullException(nameof(key));

         ValidateConstructorArguments(key, isValid);

         this.Key = key;
         this.IsValid = isValid;
      }

      static partial void ValidateConstructorArguments(string key, bool isValid);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string IEnum<string>.GetKey()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      [return: NotNullIfNotNull(""key"")]
      public static TestEnum? Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            item = CreateInvalidItem(key);

            if (item is null)
               throw new Exception(""The implementation of method 'CreateInvalidItem' must not return 'null'."");

            if (item.IsValid)
               throw new Exception(""The implementation of method 'CreateInvalidItem' must return an instance with property 'IsValid' equals to 'false'."");
         }

         return item;
      }

      private static TestEnum CreateInvalidItem(string key)
      {
         return new TestEnum(key, false);
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([AllowNull] string key, [MaybeNullWhen(false)] out TestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Implicit conversion to the type of <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""Key""/> of provided <paramref name=""item""/> or <c>null</c> if a<paramref name=""item""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""item"")]
      public static implicit operator string?(TestEnum? item)
      {
         return item is null ? default : item.Key;
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestEnum? item1, TestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestEnum? item1, TestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(TestEnum? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         if (this.IsValid != other.IsValid)
            return false;

         return _defaultKeyComparerMember.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _defaultKeyComparerMember.GetHashCode(this.Key);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Key.ToString();
      }

      private static IReadOnlyDictionary<string, TestEnum> GetLookup()
      {
         var lookup = new Dictionary<string, TestEnum>(_defaultKeyComparerMember);

         void AddItem(TestEnum item, string itemName)
         {
            if(item is null)
               throw new ArgumentNullException($""The item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(item.Key is null)
               throw new ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(!item.IsValid)
               throw new ArgumentException($""All 'public static readonly' fields of type \""TestEnum\"" must be valid but the item \""{itemName}\"" with the identifier \""{item.Key}\"" is not."");

            if (lookup.ContainsKey(item.Key))
               throw new ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(Item1, ""Item1"");
         AddItem(Item2, ""Item2"");

         return lookup;
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_simple_struct_which_implements_IValidatableEnum()
      {
         var source = @"
using System;

namespace Thinktecture.EnumLikeClass
{
	public readonly partial struct TestEnum : IValidatableEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(IValidatableEnum<>).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnum_EnumTypeConverter : Thinktecture.EnumTypeConverter<TestEnum, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""key"")]
      protected override TestEnum ConvertFrom(string? key)
      {
         return TestEnum.Get(key);
      }
   }

   [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
   [System.ComponentModel.TypeConverter(typeof(TestEnum_EnumTypeConverter))]
   partial struct TestEnum : IEquatable<TestEnum>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convert = new Func<string?, TestEnum>(TestEnum.Get);
         Expression<Func<string?, TestEnum>> convertExpression = key => TestEnum.Get(key);

         var enumType = typeof(TestEnum);
         var metadata = new EnumMetadata(enumType, typeof(string), convert, convertExpression);

         EnumMetadataLookup.AddEnumMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(TestEnum).GetHashCode() * 397;
      private static readonly IEqualityComparer<string?> _defaultKeyComparerMember = StringComparer.OrdinalIgnoreCase;

      private static IReadOnlyDictionary<string, TestEnum>? _itemsLookup;
      private static IReadOnlyDictionary<string, TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static IReadOnlyList<TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static IReadOnlyList<TestEnum> Items => _items ??= ItemsLookup.Values.ToList().AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [NotNull]
      public string Key { get; }

      /// <inheritdoc />
      public bool IsValid { get; }

      /// <summary>
      /// Checks whether current enumeration item is valid.
      /// </summary>
      /// <exception cref=""InvalidOperationException"">The enumeration item is not valid.</exception>
      public void EnsureValid()
      {
         if (!IsValid)
            throw new InvalidOperationException($""The current enumeration item of type 'TestEnum' with identifier '{this.Key}' is not valid."");
      }

      private TestEnum(string key)
         : this(key, true)
      {
      }

      private TestEnum(string key, bool isValid)
      {
        if (key is null)
            throw new ArgumentNullException(nameof(key));

         ValidateConstructorArguments(key, isValid);

         this.Key = key;
         this.IsValid = isValid;
      }

      static partial void ValidateConstructorArguments(string key, bool isValid);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string IEnum<string>.GetKey()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      [return: NotNullIfNotNull(""key"")]
      public static TestEnum Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            item = CreateInvalidItem(key);

            if (item.IsValid)
               throw new Exception(""The implementation of method 'CreateInvalidItem' must return an instance with property 'IsValid' equals to 'false'."");
         }

         return item;
      }

      private static TestEnum CreateInvalidItem(string key)
      {
         return new TestEnum(key, false);
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([AllowNull] string key, [MaybeNullWhen(false)] out TestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Implicit conversion to the type of <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""Key""/> of provided <paramref name=""item""/> or <c>null</c> if a<paramref name=""item""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""item"")]
      public static implicit operator string?(TestEnum item)
      {
         return item.Key;
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestEnum item1, TestEnum item2)
      {
         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestEnum item1, TestEnum item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(TestEnum other)
      {
         if (this.IsValid != other.IsValid)
            return false;

         return _defaultKeyComparerMember.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _defaultKeyComparerMember.GetHashCode(this.Key);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Key?.ToString();
      }

      private static IReadOnlyDictionary<string, TestEnum> GetLookup()
      {
         var lookup = new Dictionary<string, TestEnum>(_defaultKeyComparerMember);

         void AddItem(TestEnum item, string itemName)
         {
            if(item.Key is null)
               throw new ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(!item.IsValid)
               throw new ArgumentException($""All 'public static readonly' fields of type \""TestEnum\"" must be valid but the item \""{itemName}\"" with the identifier \""{item.Key}\"" is not."");

            if (lookup.ContainsKey(item.Key))
               throw new ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(Item1, ""Item1"");
         AddItem(Item2, ""Item2"");

         return lookup;
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_advanced_class_which_implements_IValidatableEnum()
      {
         var source = @"
using System;

namespace Thinktecture.EnumLikeClass
{
   [EnumGeneration(KeyPropertyName = ""Name"", KeyComparerProvidingMember = ""_testEqualityComparer"")]
	public partial class TestEnum : IValidatableEnum<string>
	{
      private static readonly IEqualityComparer<string> _testEqualityComparer = StringComparer.Ordinal;

		public static readonly TestEnum Item1 = new(""Item1"", 1, -1, ""ReferenceProperty1"", ""NullableReferenceProperty1"", 11, ""ReferenceField1"");
      public static readonly TestEnum Item2 = new DerivedEnum(""Item2"", 2, 2, ""ReferenceProperty2"", ""NullableReferenceProperty2"", 22, ""ReferenceField2"");

      public int StructProperty { get; }
      public int? NullableStructProperty { get; }
      public string ReferenceProperty { get; }
      public string? NullableReferenceProperty { get; }
      public readonly int StructField;
      public readonly string ReferenceField;

      static partial void ValidateConstructorArguments(
         int name, bool isValid,
         int structProperty, int? nullableStructProperty,
         string referenceProperty, string? nullableReferenceProperty,
         int structField, string referenceField)
      {
      }

      private static ProductCategory CreateInvalidItem(string name)
      {
         return new(name, false, 0, null, String.Empty, null, 0, null);
      }

      private class DerivedEnum : EnumWithDerivedType
      {
         public DerivedEnum(
            int name, bool isValid,
            int structProperty, int? nullableStructProperty,
            string referenceProperty, string? nullableReferenceProperty,
            int structField, string referenceField)
            : base(name, isValid, structProperty, nullableStructProperty, referenceProperty, nullableReferenceProperty, structField, referenceField)
         {
         }
      }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(IValidatableEnum<>).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnum_EnumTypeConverter : Thinktecture.EnumTypeConverter<TestEnum, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""name"")]
      protected override TestEnum? ConvertFrom(string? name)
      {
         return TestEnum.Get(name);
      }
   }

   [System.ComponentModel.TypeConverter(typeof(TestEnum_EnumTypeConverter))]
   partial class TestEnum : IEquatable<TestEnum?>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convert = new Func<string?, TestEnum?>(TestEnum.Get);
         Expression<Func<string?, TestEnum?>> convertExpression = name => TestEnum.Get(name);

         var enumType = typeof(TestEnum);
         var metadata = new EnumMetadata(enumType, typeof(string), convert, convertExpression);

         EnumMetadataLookup.AddEnumMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(TestEnum).GetHashCode() * 397;

      private static IReadOnlyDictionary<string, TestEnum>? _itemsLookup;
      private static IReadOnlyDictionary<string, TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static IReadOnlyList<TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static IReadOnlyList<TestEnum> Items => _items ??= ItemsLookup.Values.ToList().AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [NotNull]
      public string Name { get; }

      /// <inheritdoc />
      public bool IsValid { get; }

      /// <summary>
      /// Checks whether current enumeration item is valid.
      /// </summary>
      /// <exception cref=""InvalidOperationException"">The enumeration item is not valid.</exception>
      public void EnsureValid()
      {
         if (!IsValid)
            throw new InvalidOperationException($""The current enumeration item of type 'TestEnum' with identifier '{this.Name}' is not valid."");
      }

      private TestEnum(string name, int structProperty, int? nullableStructProperty, string referenceProperty, string? nullableReferenceProperty, int structField, string referenceField)
         : this(name, true, structProperty, nullableStructProperty, referenceProperty, nullableReferenceProperty, structField, referenceField)
      {
      }

      private TestEnum(string name, bool isValid, int structProperty, int? nullableStructProperty, string referenceProperty, string? nullableReferenceProperty, int structField, string referenceField)
      {
        if (name is null)
            throw new ArgumentNullException(nameof(name));

         ValidateConstructorArguments(name, isValid, ref structProperty, ref nullableStructProperty, ref referenceProperty, ref nullableReferenceProperty, ref structField, ref referenceField);

         this.Name = name;
         this.IsValid = isValid;
         this.StructProperty = structProperty;
         this.NullableStructProperty = nullableStructProperty;
         this.ReferenceProperty = referenceProperty;
         this.NullableReferenceProperty = nullableReferenceProperty;
         this.StructField = structField;
         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(string name, bool isValid, ref int structProperty, ref int? nullableStructProperty, ref string referenceProperty, ref string? nullableReferenceProperty, ref int structField, ref string referenceField);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string IEnum<string>.GetKey()
      {
         return this.Name;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""name""/>.
      /// </summary>
      /// <param name=""name"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""name""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      [return: NotNullIfNotNull(""name"")]
      public static TestEnum? Get(string? name)
      {
        if (name is null)
            return default;

         if (!ItemsLookup.TryGetValue(name, out var item))
         {
            item = CreateInvalidItem(name);

            if (item is null)
               throw new Exception(""The implementation of method 'CreateInvalidItem' must not return 'null'."");

            if (item.IsValid)
               throw new Exception(""The implementation of method 'CreateInvalidItem' must return an instance with property 'IsValid' equals to 'false'."");
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""name""/> if a valid item exists.
      /// </summary>
      /// <param name=""name"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""name""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([AllowNull] string name, [MaybeNullWhen(false)] out TestEnum item)
      {
         if (name is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(name, out item);
      }

      /// <summary>
      /// Implicit conversion to the type of <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""Name""/> of provided <paramref name=""item""/> or <c>null</c> if a<paramref name=""item""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""item"")]
      public static implicit operator string?(TestEnum? item)
      {
         return item is null ? default : item.Name;
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestEnum? item1, TestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestEnum? item1, TestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(TestEnum? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         if (this.IsValid != other.IsValid)
            return false;

         return _testEqualityComparer.Equals(this.Name, other.Name);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _testEqualityComparer.GetHashCode(this.Name);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Name.ToString();
      }

      private static IReadOnlyDictionary<string, TestEnum> GetLookup()
      {
         var lookup = new Dictionary<string, TestEnum>(_testEqualityComparer);

         void AddItem(TestEnum item, string itemName)
         {
            if(item is null)
               throw new ArgumentNullException($""The item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(item.Name is null)
               throw new ArgumentException($""The \""Name\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(!item.IsValid)
               throw new ArgumentException($""All 'public static readonly' fields of type \""TestEnum\"" must be valid but the item \""{itemName}\"" with the identifier \""{item.Name}\"" is not."");

            if (lookup.ContainsKey(item.Name))
               throw new ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Name}\""."");

            lookup.Add(item.Name, item);
         }

         AddItem(Item1, ""Item1"");
         AddItem(Item2, ""Item2"");

         return lookup;
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_JsonConverter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;

namespace Thinktecture.EnumLikeClass
{
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(Thinktecture.Text.Json.Serialization.EnumJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text.Json.Serialization;
using Thinktecture;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnum_EnumJsonConverter : Thinktecture.Text.Json.Serialization.EnumJsonConverter<TestEnum, string>
   {
      public TestEnum_EnumJsonConverter()
         : this(null)
      {
      }

      public TestEnum_EnumJsonConverter(
         JsonConverter<string>? keyConverter)
         : base(TestEnum.Get, keyConverter)
      {
      }
   }

   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(TestEnum_EnumJsonConverter))]
   partial class TestEnum
   {
   }
}
");
      }

      [Fact]
      public void Should_not_generate_JsonConverter_and_attribute_if_Attribute_is_present()
      {
         var source = @"
using System;
using System.Text.Json.Serialization;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnumJsonConverter : Thinktecture.Text.Json.Serialization.EnumJsonConverter<TestEnum, string>
   {
      public TestEnum_EnumJsonConverter()
         : this(null)
      {
      }

      public TestEnum_EnumJsonConverter(
         JsonConverter<string>? keyConverter)
         : base(TestEnum.Get, keyConverter)
      {
      }
   }

   [JsonConverter(typeof(TestEnumJsonConverter))]
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(Thinktecture.Text.Json.Serialization.EnumJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

         output.Should().BeNull();
      }

      [Fact]
      public void Should_generate_NewtonsoftJsonConverter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;

namespace Thinktecture.EnumLikeClass
{
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(Json.EnumJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnum_EnumNewtonsoftJsonConverter : Thinktecture.Json.EnumJsonConverter<TestEnum, string>
   {
      public TestEnum_EnumNewtonsoftJsonConverter()
         : base(TestEnum.Get)
      {
      }
   }

   [Newtonsoft.Json.JsonConverterAttribute(typeof(TestEnum_EnumNewtonsoftJsonConverter))]
   partial class TestEnum
   {
   }
}
");
      }

      [Fact]
      public void Should_not_generate_NewtonsoftJsonConverter_and_attribute_if_Attribute_is_present()
      {
         var source = @"
using System;
using Newtonsoft.Json;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnum_EnumNewtonsoftJsonConverter : Thinktecture.Json.EnumJsonConverter<TestEnum, string>
   {
      public TestEnum_EnumNewtonsoftJsonConverter()
         : base(TestEnum.Get)
      {
      }
   }

   [JsonConverterAttribute(typeof(TestEnum_EnumNewtonsoftJsonConverter))]
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(Json.EnumJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

         output.Should().BeNull();
      }

      [Fact]
      public void Should_generate_MessagePackFormatter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;

namespace Thinktecture.EnumLikeClass
{
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(EnumMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnum_EnumMessagePackFormatter : Thinktecture.Formatters.EnumMessagePackFormatter<TestEnum, string>
   {
      public TestEnum_EnumMessagePackFormatter()
         : base(TestEnum.Get)
      {
      }
   }

   [MessagePack.MessagePackFormatter(typeof(TestEnum_EnumMessagePackFormatter))]
   partial class TestEnum
   {
   }

}
");
      }

      [Fact]
      public void Should_not_generate_MessagePackFormatter_and_attribute_if_Attribute_is_present()
      {
         var source = @"
using System;
using MessagePack;

namespace Thinktecture.EnumLikeClass
{
   public class TestEnumMessagePackFormatter : Thinktecture.Formatters.EnumMessagePackFormatter<TestEnum, string>
   {
      public TestEnumMessagePackFormatter()
         : base(TestEnum.Get)
      {
      }
   }

   [MessagePackFormatter(typeof(TestEnumMessagePackFormatter))]
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
         var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(EnumMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

         output.Should().BeNull();
      }
   }
}
