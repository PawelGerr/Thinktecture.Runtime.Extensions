using Thinktecture.CodeAnalysis;
using Thinktecture.Runtime.Tests.TestEnums;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class EnumSourceGeneratorTests : SourceGeneratorTestsBase
{
   public EnumSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   private const string _GENERATED_HEADER = @"// <auto-generated />
#nullable enable
";

   private const string _OUTPUT_OF_SIMPLE_ENUM = _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestEnum_EnumTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestEnum, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      protected override global::Thinktecture.Tests.TestEnum? ConvertFrom(string? key)
      {
         if(key is null)
            return default;

         if(global::Thinktecture.Tests.TestEnum.TryGet(key, out var item))
            return item;

         throw new global::System.FormatException($""There is no item of type 'TestEnum' with the identifier '{key}'."");
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestEnum item)
      {
         return item.Key;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(Key))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestEnum_EnumTypeConverter))]
   partial class TestEnum : global::System.IEquatable<global::Thinktecture.Tests.TestEnum?>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string?, global::Thinktecture.Tests.TestEnum?>(global::Thinktecture.Tests.TestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<string?, global::Thinktecture.Tests.TestEnum?>> convertFromKeyExpression = key => global::Thinktecture.Tests.TestEnum.Get(key);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestEnum, string?>(item => item.Key);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestEnum, string?>> convertToKeyExpression = item => item.Key;

         var validate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestEnum, string>(global::Thinktecture.Tests.TestEnum.Validate);

         var enumType = typeof(global::Thinktecture.Tests.TestEnum);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(enumType, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, validate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::Thinktecture.Tests.TestEnum).GetHashCode() * 397;
      private static readonly global::System.Collections.Generic.IEqualityComparer<string?> _defaultKeyComparerMember = global::System.StringComparer.OrdinalIgnoreCase;

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum>? _itemsLookup;
      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> Items => _items ??= global::System.Linq.Enumerable.ToList(ItemsLookup.Values).AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [global::System.Diagnostics.CodeAnalysis.NotNull]
      public string Key { get; }

      private TestEnum(string key)
      {
         ValidateConstructorArguments(ref key);

         if (key is null)
            throw new global::System.ArgumentNullException(nameof(key));

         this.Key = key;
      }

      static partial void ValidateConstructorArguments(ref string key);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string global::Thinktecture.IEnum<string>.GetKey()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      /// <exception cref=""Thinktecture.UnknownEnumIdentifierException"">If there is no item with the provided <paramref name=""key""/>.</exception>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static global::Thinktecture.Tests.TestEnum? Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            throw new global::Thinktecture.UnknownEnumIdentifierException(typeof(global::Thinktecture.Tests.TestEnum), key);
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] string key, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name=""key""/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns> <see cref=""System.ComponentModel.DataAnnotations.ValidationResult.Success""/> if a valid item with provided <paramref name=""key""/> exists; <see cref=""System.ComponentModel.DataAnnotations.ValidationResult""/> with an error message otherwise.</returns>
      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(string key, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestEnum item)
      {
         return global::Thinktecture.Tests.TestEnum.TryGet(key, out item)
               ? global::System.ComponentModel.DataAnnotations.ValidationResult.Success
               : new global::System.ComponentModel.DataAnnotations.ValidationResult($""The enumeration item of type \""TestEnum\"" with identifier \""{key}\"" is not valid."");
      }

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""TestEnum.Key""/> of provided <paramref name=""item""/> or <c>default</c> if <paramref name=""item""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""item"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestEnum? item)
      {
         return item is null ? default : item.Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""key"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestEnum""/> if the <paramref name=""key""/> is a known item or implements <see cref=""Thinktecture.IValidatableEnum{TKey}""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static explicit operator global::Thinktecture.Tests.TestEnum?(string? key)
      {
         return global::Thinktecture.Tests.TestEnum.Get(key);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestEnum? item1, global::Thinktecture.Tests.TestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestEnum? item1, global::Thinktecture.Tests.TestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestEnum? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return _defaultKeyComparerMember.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _defaultKeyComparerMember.GetHashCode(this.Key);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Key.ToString();
      }

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> GetLookup()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<string, global::Thinktecture.Tests.TestEnum>(2, _defaultKeyComparerMember);

         void AddItem(global::Thinktecture.Tests.TestEnum item, string itemName)
         {
            if(item is null)
               throw new global::System.ArgumentNullException($""The item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(item.Key is null)
               throw new global::System.ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if (lookup.ContainsKey(item.Key))
               throw new global::System.ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(Item1, nameof(Item1));
         AddItem(Item2, nameof(Item2));

         return lookup;
      }
   }
}
";

   [Fact]
   public void Should_not_generate_if_class_is_not_partial()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
	public class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_not_generate_if_generic()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
	public partial class TestEnum<T> : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly);
      AssertOutput(output, null);
   }

   [Fact]
   public void Should_generate_simple_class_which_implements_IEnum()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly);
      AssertOutput(output, _OUTPUT_OF_SIMPLE_ENUM);
   }

   [Fact]
   public void Should_generate_simple_class_which_implements_IEnum_if_IEnum_is_fully_qualified()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
	public partial class TestEnum : Thinktecture.IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly);
      AssertOutput(output, _OUTPUT_OF_SIMPLE_ENUM);
   }

   [Fact]
   public void Should_generate_simple_enum_which_has_no_namespace()
   {
      var source = @"
using System;
using Thinktecture;

public partial class TestEnum : IEnum<string>
{
   public static readonly TestEnum Item1 = new(""Item1"");
   public static readonly TestEnum Item2 = new(""Item2"");
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
   public class TestEnum_EnumTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::TestEnum, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      protected override global::TestEnum? ConvertFrom(string? key)
      {
         if(key is null)
            return default;

         if(global::TestEnum.TryGet(key, out var item))
            return item;

         throw new global::System.FormatException($""There is no item of type 'TestEnum' with the identifier '{key}'."");
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::TestEnum item)
      {
         return item.Key;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(Key))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::TestEnum_EnumTypeConverter))]
   partial class TestEnum : global::System.IEquatable<global::TestEnum?>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string?, global::TestEnum?>(global::TestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<string?, global::TestEnum?>> convertFromKeyExpression = key => global::TestEnum.Get(key);

         var convertToKey = new global::System.Func<global::TestEnum, string?>(item => item.Key);
         global::System.Linq.Expressions.Expression<global::System.Func<global::TestEnum, string?>> convertToKeyExpression = item => item.Key;

         var validate = new global::Thinktecture.Internal.Validate<global::TestEnum, string>(global::TestEnum.Validate);

         var enumType = typeof(global::TestEnum);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(enumType, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, validate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::TestEnum).GetHashCode() * 397;
      private static readonly global::System.Collections.Generic.IEqualityComparer<string?> _defaultKeyComparerMember = global::System.StringComparer.OrdinalIgnoreCase;

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::TestEnum>? _itemsLookup;
      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static global::System.Collections.Generic.IReadOnlyList<global::TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::TestEnum> Items => _items ??= global::System.Linq.Enumerable.ToList(ItemsLookup.Values).AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [global::System.Diagnostics.CodeAnalysis.NotNull]
      public string Key { get; }

      private TestEnum(string key)
      {
         ValidateConstructorArguments(ref key);

         if (key is null)
            throw new global::System.ArgumentNullException(nameof(key));

         this.Key = key;
      }

      static partial void ValidateConstructorArguments(ref string key);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string global::Thinktecture.IEnum<string>.GetKey()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      /// <exception cref=""Thinktecture.UnknownEnumIdentifierException"">If there is no item with the provided <paramref name=""key""/>.</exception>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static global::TestEnum? Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            throw new global::Thinktecture.UnknownEnumIdentifierException(typeof(global::TestEnum), key);
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] string key, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::TestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name=""key""/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns> <see cref=""System.ComponentModel.DataAnnotations.ValidationResult.Success""/> if a valid item with provided <paramref name=""key""/> exists; <see cref=""System.ComponentModel.DataAnnotations.ValidationResult""/> with an error message otherwise.</returns>
      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(string key, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::TestEnum item)
      {
         return global::TestEnum.TryGet(key, out item)
               ? global::System.ComponentModel.DataAnnotations.ValidationResult.Success
               : new global::System.ComponentModel.DataAnnotations.ValidationResult($""The enumeration item of type \""TestEnum\"" with identifier \""{key}\"" is not valid."");
      }

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""TestEnum.Key""/> of provided <paramref name=""item""/> or <c>default</c> if <paramref name=""item""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""item"")]
      public static implicit operator string?(global::TestEnum? item)
      {
         return item is null ? default : item.Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""key"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestEnum""/> if the <paramref name=""key""/> is a known item or implements <see cref=""Thinktecture.IValidatableEnum{TKey}""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static explicit operator global::TestEnum?(string? key)
      {
         return global::TestEnum.Get(key);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::TestEnum? item1, global::TestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::TestEnum? item1, global::TestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(global::TestEnum? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return _defaultKeyComparerMember.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _defaultKeyComparerMember.GetHashCode(this.Key);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Key.ToString();
      }

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::TestEnum> GetLookup()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<string, global::TestEnum>(2, _defaultKeyComparerMember);

         void AddItem(global::TestEnum item, string itemName)
         {
            if(item is null)
               throw new global::System.ArgumentNullException($""The item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(item.Key is null)
               throw new global::System.ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if (lookup.ContainsKey(item.Key))
               throw new global::System.ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(Item1, nameof(Item1));
         AddItem(Item2, nameof(Item2));

         return lookup;
      }
   }
");
   }

   [Fact]
   public void Should_generate_simple_extensible_class_which_implements_IEnum()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
   [EnumGeneration(IsExtensible = true)]
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestEnum_EnumTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestEnum, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      protected override global::Thinktecture.Tests.TestEnum? ConvertFrom(string? key)
      {
         if(key is null)
            return default;

         if(global::Thinktecture.Tests.TestEnum.TryGet(key, out var item))
            return item;

         throw new global::System.FormatException($""There is no item of type '{GetType().Name}' with the identifier '{key}'."");
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestEnum item)
      {
         return item.Key;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(Key))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestEnum_EnumTypeConverter))]
   partial class TestEnum : global::System.IEquatable<global::Thinktecture.Tests.TestEnum?>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string?, global::Thinktecture.Tests.TestEnum?>(global::Thinktecture.Tests.TestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<string?, global::Thinktecture.Tests.TestEnum?>> convertFromKeyExpression = key => global::Thinktecture.Tests.TestEnum.Get(key);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestEnum, string?>(item => item.Key);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestEnum, string?>> convertToKeyExpression = item => item.Key;

         var validate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestEnum, string>(global::Thinktecture.Tests.TestEnum.Validate);

         var enumType = typeof(global::Thinktecture.Tests.TestEnum);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(enumType, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, validate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::Thinktecture.Tests.TestEnum).GetHashCode() * 397;
      protected static readonly global::System.Collections.Generic.IEqualityComparer<string?> _defaultKeyComparerMember = global::System.StringComparer.OrdinalIgnoreCase;

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum>? _itemsLookup;
      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> Items => _items ??= global::System.Linq.Enumerable.ToList(ItemsLookup.Values).AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [global::System.Diagnostics.CodeAnalysis.NotNull]
      public string Key { get; }

      protected TestEnum(string key)
      {
         ValidateConstructorArguments(ref key);

         if (key is null)
            throw new global::System.ArgumentNullException(nameof(key));

         this.Key = key;
      }

      static partial void ValidateConstructorArguments(ref string key);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string global::Thinktecture.IEnum<string>.GetKey()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      /// <exception cref=""Thinktecture.UnknownEnumIdentifierException"">If there is no item with the provided <paramref name=""key""/>.</exception>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static global::Thinktecture.Tests.TestEnum? Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            throw new global::Thinktecture.UnknownEnumIdentifierException(typeof(global::Thinktecture.Tests.TestEnum), key);
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] string key, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name=""key""/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns> <see cref=""System.ComponentModel.DataAnnotations.ValidationResult.Success""/> if a valid item with provided <paramref name=""key""/> exists; <see cref=""System.ComponentModel.DataAnnotations.ValidationResult""/> with an error message otherwise.</returns>
      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(string key, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestEnum item)
      {
         return global::Thinktecture.Tests.TestEnum.TryGet(key, out item)
               ? global::System.ComponentModel.DataAnnotations.ValidationResult.Success
               : new global::System.ComponentModel.DataAnnotations.ValidationResult($""The enumeration item of type \""TestEnum\"" with identifier \""{key}\"" is not valid."");
      }

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""TestEnum.Key""/> of provided <paramref name=""item""/> or <c>default</c> if <paramref name=""item""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""item"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestEnum? item)
      {
         return item is null ? default : item.Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""key"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestEnum""/> if the <paramref name=""key""/> is a known item or implements <see cref=""Thinktecture.IValidatableEnum{TKey}""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static explicit operator global::Thinktecture.Tests.TestEnum?(string? key)
      {
         return global::Thinktecture.Tests.TestEnum.Get(key);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestEnum? item1, global::Thinktecture.Tests.TestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestEnum? item1, global::Thinktecture.Tests.TestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public virtual bool Equals(global::Thinktecture.Tests.TestEnum? other)
      {
         if (other is null)
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return _defaultKeyComparerMember.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _defaultKeyComparerMember.GetHashCode(this.Key);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Key.ToString();
      }

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> GetLookup()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<string, global::Thinktecture.Tests.TestEnum>(2, _defaultKeyComparerMember);

         void AddItem(global::Thinktecture.Tests.TestEnum item, string itemName)
         {
            if(item is null)
               throw new global::System.ArgumentNullException($""The item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(item.Key is null)
               throw new global::System.ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if (lookup.ContainsKey(item.Key))
               throw new global::System.ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(Item1, nameof(Item1));
         AddItem(Item2, nameof(Item2));

         return lookup;
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_simple_extended_class_from_other_assembly()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
   [EnumGeneration]
   public partial class ExtendedTestEnum : Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum
   {
      public static readonly ExtendedTestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(ExtensibleTestEnum).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class ExtendedTestEnum_EnumTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.ExtendedTestEnum, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""id"")]
      protected override global::Thinktecture.Tests.ExtendedTestEnum? ConvertFrom(string? id)
      {
         if(id is null)
            return default;

         if(global::Thinktecture.Tests.ExtendedTestEnum.TryGet(id, out var item))
            return item;

         throw new global::System.FormatException($""There is no item of type 'ExtendedTestEnum' with the identifier '{id}'."");
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.ExtendedTestEnum item)
      {
         return item.Id;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(Id))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.ExtendedTestEnum_EnumTypeConverter))]
   partial class ExtendedTestEnum : global::System.IEquatable<global::Thinktecture.Tests.ExtendedTestEnum?>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string?, global::Thinktecture.Tests.ExtendedTestEnum?>(global::Thinktecture.Tests.ExtendedTestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<string?, global::Thinktecture.Tests.ExtendedTestEnum?>> convertFromKeyExpression = id => global::Thinktecture.Tests.ExtendedTestEnum.Get(id);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.ExtendedTestEnum, string?>(item => item.Id);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.ExtendedTestEnum, string?>> convertToKeyExpression = item => item.Id;

         var validate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.ExtendedTestEnum, string>(global::Thinktecture.Tests.ExtendedTestEnum.Validate);

         var enumType = typeof(global::Thinktecture.Tests.ExtendedTestEnum);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(enumType, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, validate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum).GetHashCode() * 397;

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.ExtendedTestEnum>? _itemsLookup;
      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.ExtendedTestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.ExtendedTestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public new static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.ExtendedTestEnum> Items => _items ??= global::System.Linq.Enumerable.ToList(ItemsLookup.Values).AsReadOnly();

      private readonly bool _isBaseEnumItem;

      public new static readonly global::Thinktecture.Tests.ExtendedTestEnum DerivedItem = new global::Thinktecture.Tests.ExtendedTestEnum(global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum.DerivedItem.Id, global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum.DerivedItem.Foo);
      public new static readonly global::Thinktecture.Tests.ExtendedTestEnum Item1 = new global::Thinktecture.Tests.ExtendedTestEnum(global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum.Item1.Id, global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum.Item1.Foo);

      private ExtendedTestEnum(string id, System.Action foo)
         : base(id, foo)
      {
         ValidateConstructorArguments(ref id, ref foo);

         this._isBaseEnumItem = global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum.TryGet(id, out _);
      }

      static partial void ValidateConstructorArguments(ref string id, ref System.Action foo);

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""id""/>.
      /// </summary>
      /// <param name=""id"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""ExtendedTestEnum"" /> if <paramref name=""id""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      /// <exception cref=""Thinktecture.UnknownEnumIdentifierException"">If there is no item with the provided <paramref name=""id""/>.</exception>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""id"")]
      public new static global::Thinktecture.Tests.ExtendedTestEnum? Get(string? id)
      {
        if (id is null)
            return default;

         if (!ItemsLookup.TryGetValue(id, out var item))
         {
            throw new global::Thinktecture.UnknownEnumIdentifierException(typeof(global::Thinktecture.Tests.ExtendedTestEnum), id);
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""id""/> if a valid item exists.
      /// </summary>
      /// <param name=""id"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""ExtendedTestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""id""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] string id, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.ExtendedTestEnum item)
      {
         if (id is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(id, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name=""id""/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name=""id"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""ExtendedTestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns> <see cref=""System.ComponentModel.DataAnnotations.ValidationResult.Success""/> if a valid item with provided <paramref name=""id""/> exists; <see cref=""System.ComponentModel.DataAnnotations.ValidationResult""/> with an error message otherwise.</returns>
      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(string id, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.ExtendedTestEnum item)
      {
         return global::Thinktecture.Tests.ExtendedTestEnum.TryGet(id, out item)
               ? global::System.ComponentModel.DataAnnotations.ValidationResult.Success
               : new global::System.ComponentModel.DataAnnotations.ValidationResult($""The enumeration item of type \""ExtendedTestEnum\"" with identifier \""{id}\"" is not valid."");
      }

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""ExtensibleTestEnum.Id""/> of provided <paramref name=""item""/> or <c>default</c> if <paramref name=""item""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""item"")]
      public static implicit operator string?(global::Thinktecture.Tests.ExtendedTestEnum? item)
      {
         return item is null ? default : item.Id;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""id"">Value to covert.</param>
      /// <returns>An instance of <see cref=""ExtendedTestEnum""/> if the <paramref name=""id""/> is a known item or implements <see cref=""Thinktecture.IValidatableEnum{TKey}""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""id"")]
      public static explicit operator global::Thinktecture.Tests.ExtendedTestEnum?(string? id)
      {
         return global::Thinktecture.Tests.ExtendedTestEnum.Get(id);
      }

      /// <summary>
      /// Compares to instances of <see cref=""ExtendedTestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.ExtendedTestEnum? item1, global::Thinktecture.Tests.ExtendedTestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""ExtendedTestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.ExtendedTestEnum? item1, global::Thinktecture.Tests.ExtendedTestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.ExtendedTestEnum? other)
      {
         return Equals((global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum?)other);
      }

      /// <inheritdoc />
      public override bool Equals(global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()) && !this._isBaseEnumItem)
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return EqualityComparer.Equals(this.Id, other.Id);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Runtime.Tests.TestEnums.ExtensibleTestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ EqualityComparer.GetHashCode(this.Id);
      }

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.ExtendedTestEnum> GetLookup()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<string, global::Thinktecture.Tests.ExtendedTestEnum>(3, EqualityComparer);

         void AddItem(global::Thinktecture.Tests.ExtendedTestEnum item, string itemName)
         {
            if(item is null)
               throw new global::System.ArgumentNullException($""The item \""{itemName}\"" of type \""ExtendedTestEnum\"" must not be null."");

            if(item.Id is null)
               throw new global::System.ArgumentException($""The \""Id\"" of the item \""{itemName}\"" of type \""ExtendedTestEnum\"" must not be null."");

            if (lookup.ContainsKey(item.Id))
               throw new global::System.ArgumentException($""The type \""ExtendedTestEnum\"" has multiple items with the identifier \""{item.Id}\""."");

            lookup.Add(item.Id, item);
         }

         AddItem(DerivedItem, nameof(DerivedItem));
         AddItem(Item1, nameof(Item1));
         AddItem(Item2, nameof(Item2));

         return lookup;
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_simple_extended_class_from_same_assembly()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
   [EnumGeneration(IsExtensible = true, KeyComparer = ""EqualityComparer"")]
   public partial class ExtensibleTestEnum : IEnum<string>
   {
      protected static readonly System.Collections.Generic.IEqualityComparer<string> EqualityComparer = System.StringComparer.OrdinalIgnoreCase;

      public static readonly ExtensibleTestEnum DerivedItem = new(""DerivedItem"", Empty.Action);
      public static readonly ExtensibleTestEnum Item1 = new(""Item1"", Empty.Action);

      [EnumGenerationMember(MapsToMember = nameof(Foo))]
      private readonly Action _foo;

      public void Foo()
      {
         _foo();
      }
   }

   [EnumGeneration]
   public partial class ExtendedTestEnum : ExtensibleTestEnum
   {
      public static readonly ExtendedTestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly);
      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class ExtendedTestEnum_EnumTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.ExtendedTestEnum, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      protected override global::Thinktecture.Tests.ExtendedTestEnum? ConvertFrom(string? key)
      {
         if(key is null)
            return default;

         if(global::Thinktecture.Tests.ExtendedTestEnum.TryGet(key, out var item))
            return item;

         throw new global::System.FormatException($""There is no item of type 'ExtendedTestEnum' with the identifier '{key}'."");
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.ExtendedTestEnum item)
      {
         return item.Key;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(Key))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.ExtendedTestEnum_EnumTypeConverter))]
   partial class ExtendedTestEnum : global::System.IEquatable<global::Thinktecture.Tests.ExtendedTestEnum?>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal new static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string?, global::Thinktecture.Tests.ExtendedTestEnum?>(global::Thinktecture.Tests.ExtendedTestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<string?, global::Thinktecture.Tests.ExtendedTestEnum?>> convertFromKeyExpression = key => global::Thinktecture.Tests.ExtendedTestEnum.Get(key);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.ExtendedTestEnum, string?>(item => item.Key);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.ExtendedTestEnum, string?>> convertToKeyExpression = item => item.Key;

         var validate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.ExtendedTestEnum, string>(global::Thinktecture.Tests.ExtendedTestEnum.Validate);

         var enumType = typeof(global::Thinktecture.Tests.ExtendedTestEnum);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(enumType, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, validate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::Thinktecture.Tests.ExtensibleTestEnum).GetHashCode() * 397;

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.ExtendedTestEnum>? _itemsLookup;
      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.ExtendedTestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.ExtendedTestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public new static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.ExtendedTestEnum> Items => _items ??= global::System.Linq.Enumerable.ToList(ItemsLookup.Values).AsReadOnly();

      private readonly bool _isBaseEnumItem;

      public new static readonly global::Thinktecture.Tests.ExtendedTestEnum DerivedItem = new global::Thinktecture.Tests.ExtendedTestEnum(global::Thinktecture.Tests.ExtensibleTestEnum.DerivedItem.Key, global::Thinktecture.Tests.ExtensibleTestEnum.DerivedItem.Foo);
      public new static readonly global::Thinktecture.Tests.ExtendedTestEnum Item1 = new global::Thinktecture.Tests.ExtendedTestEnum(global::Thinktecture.Tests.ExtensibleTestEnum.Item1.Key, global::Thinktecture.Tests.ExtensibleTestEnum.Item1.Foo);

      private ExtendedTestEnum(string key, System.Action foo)
         : base(key, foo)
      {
         ValidateConstructorArguments(ref key, ref foo);

         this._isBaseEnumItem = global::Thinktecture.Tests.ExtensibleTestEnum.TryGet(key, out _);
      }

      static partial void ValidateConstructorArguments(ref string key, ref System.Action foo);

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""ExtendedTestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      /// <exception cref=""Thinktecture.UnknownEnumIdentifierException"">If there is no item with the provided <paramref name=""key""/>.</exception>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public new static global::Thinktecture.Tests.ExtendedTestEnum? Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            throw new global::Thinktecture.UnknownEnumIdentifierException(typeof(global::Thinktecture.Tests.ExtendedTestEnum), key);
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""ExtendedTestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] string key, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.ExtendedTestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name=""key""/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""ExtendedTestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns> <see cref=""System.ComponentModel.DataAnnotations.ValidationResult.Success""/> if a valid item with provided <paramref name=""key""/> exists; <see cref=""System.ComponentModel.DataAnnotations.ValidationResult""/> with an error message otherwise.</returns>
      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(string key, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.ExtendedTestEnum item)
      {
         return global::Thinktecture.Tests.ExtendedTestEnum.TryGet(key, out item)
               ? global::System.ComponentModel.DataAnnotations.ValidationResult.Success
               : new global::System.ComponentModel.DataAnnotations.ValidationResult($""The enumeration item of type \""ExtendedTestEnum\"" with identifier \""{key}\"" is not valid."");
      }

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""ExtensibleTestEnum.Key""/> of provided <paramref name=""item""/> or <c>default</c> if <paramref name=""item""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""item"")]
      public static implicit operator string?(global::Thinktecture.Tests.ExtendedTestEnum? item)
      {
         return item is null ? default : item.Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""key"">Value to covert.</param>
      /// <returns>An instance of <see cref=""ExtendedTestEnum""/> if the <paramref name=""key""/> is a known item or implements <see cref=""Thinktecture.IValidatableEnum{TKey}""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static explicit operator global::Thinktecture.Tests.ExtendedTestEnum?(string? key)
      {
         return global::Thinktecture.Tests.ExtendedTestEnum.Get(key);
      }

      /// <summary>
      /// Compares to instances of <see cref=""ExtendedTestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.ExtendedTestEnum? item1, global::Thinktecture.Tests.ExtendedTestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""ExtendedTestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.ExtendedTestEnum? item1, global::Thinktecture.Tests.ExtendedTestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.ExtendedTestEnum? other)
      {
         return Equals((global::Thinktecture.Tests.ExtensibleTestEnum?)other);
      }

      /// <inheritdoc />
      public override bool Equals(global::Thinktecture.Tests.ExtensibleTestEnum? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()) && !this._isBaseEnumItem)
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return EqualityComparer.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.ExtensibleTestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ EqualityComparer.GetHashCode(this.Key);
      }

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.ExtendedTestEnum> GetLookup()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<string, global::Thinktecture.Tests.ExtendedTestEnum>(3, EqualityComparer);

         void AddItem(global::Thinktecture.Tests.ExtendedTestEnum item, string itemName)
         {
            if(item is null)
               throw new global::System.ArgumentNullException($""The item \""{itemName}\"" of type \""ExtendedTestEnum\"" must not be null."");

            if(item.Key is null)
               throw new global::System.ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""ExtendedTestEnum\"" must not be null."");

            if (lookup.ContainsKey(item.Key))
               throw new global::System.ArgumentException($""The type \""ExtendedTestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(DerivedItem, nameof(DerivedItem));
         AddItem(Item1, nameof(Item1));
         AddItem(Item2, nameof(Item2));

         return lookup;
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_simple_class_which_implements_IValidatableEnum()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
	public partial class TestEnum : IValidatableEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IValidatableEnum<>).Assembly);

      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestEnum_EnumTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestEnum, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      protected override global::Thinktecture.Tests.TestEnum? ConvertFrom(string? key)
      {
         return global::Thinktecture.Tests.TestEnum.Get(key);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestEnum item)
      {
         return item.Key;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(Key))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestEnum_EnumTypeConverter))]
   partial class TestEnum : global::System.IEquatable<global::Thinktecture.Tests.TestEnum?>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string?, global::Thinktecture.Tests.TestEnum?>(global::Thinktecture.Tests.TestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<string?, global::Thinktecture.Tests.TestEnum?>> convertFromKeyExpression = key => global::Thinktecture.Tests.TestEnum.Get(key);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestEnum, string?>(item => item.Key);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestEnum, string?>> convertToKeyExpression = item => item.Key;

         var validate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestEnum, string>(global::Thinktecture.Tests.TestEnum.Validate);

         var enumType = typeof(global::Thinktecture.Tests.TestEnum);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(enumType, typeof(string), true, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, validate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::Thinktecture.Tests.TestEnum).GetHashCode() * 397;
      private static readonly global::System.Collections.Generic.IEqualityComparer<string?> _defaultKeyComparerMember = global::System.StringComparer.OrdinalIgnoreCase;

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum>? _itemsLookup;
      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> Items => _items ??= global::System.Linq.Enumerable.ToList(ItemsLookup.Values).AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [global::System.Diagnostics.CodeAnalysis.NotNull]
      public string Key { get; }

      /// <inheritdoc />
      public bool IsValid { get; }

      /// <summary>
      /// Checks whether current enumeration item is valid.
      /// </summary>
      /// <exception cref=""System.InvalidOperationException"">The enumeration item is not valid.</exception>
      public void EnsureValid()
      {
         if (!IsValid)
            throw new global::System.InvalidOperationException($""The current enumeration item of type \""TestEnum\"" with identifier \""{this.Key}\"" is not valid."");
      }

      private TestEnum(string key)
         : this(key, true)
      {
      }

      private TestEnum(string key, bool isValid)
      {
         ValidateConstructorArguments(ref key, isValid);

         if (key is null)
            throw new global::System.ArgumentNullException(nameof(key));

         this.Key = key;
         this.IsValid = isValid;
      }

      static partial void ValidateConstructorArguments(ref string key, bool isValid);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string global::Thinktecture.IEnum<string>.GetKey()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static global::Thinktecture.Tests.TestEnum? Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            item = CreateInvalidItem(key);

            if (item is null)
               throw new global::System.Exception(""The implementation of method 'CreateInvalidItem' must not return 'null'."");

            if (item.IsValid)
               throw new global::System.Exception(""The implementation of method 'CreateInvalidItem' must return an instance with property 'IsValid' equals to 'false'."");
         }

         return item;
      }

      private static global::Thinktecture.Tests.TestEnum CreateInvalidItem(string key)
      {
         return new global::Thinktecture.Tests.TestEnum(key, false);
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] string key, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name=""key""/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns> <see cref=""System.ComponentModel.DataAnnotations.ValidationResult.Success""/> if a valid item with provided <paramref name=""key""/> exists; <see cref=""System.ComponentModel.DataAnnotations.ValidationResult""/> with an error message otherwise.</returns>
      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(string key, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestEnum item)
      {
         return global::Thinktecture.Tests.TestEnum.TryGet(key, out item)
               ? global::System.ComponentModel.DataAnnotations.ValidationResult.Success
               : new global::System.ComponentModel.DataAnnotations.ValidationResult($""The enumeration item of type \""TestEnum\"" with identifier \""{key}\"" is not valid."");
      }

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""TestEnum.Key""/> of provided <paramref name=""item""/> or <c>default</c> if <paramref name=""item""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""item"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestEnum? item)
      {
         return item is null ? default : item.Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""key"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestEnum""/> if the <paramref name=""key""/> is a known item or implements <see cref=""Thinktecture.IValidatableEnum{TKey}""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static explicit operator global::Thinktecture.Tests.TestEnum?(string? key)
      {
         return global::Thinktecture.Tests.TestEnum.Get(key);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestEnum? item1, global::Thinktecture.Tests.TestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestEnum? item1, global::Thinktecture.Tests.TestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestEnum? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         if (this.IsValid != other.IsValid)
            return false;

         return _defaultKeyComparerMember.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _defaultKeyComparerMember.GetHashCode(this.Key);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Key.ToString();
      }

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> GetLookup()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<string, global::Thinktecture.Tests.TestEnum>(2, _defaultKeyComparerMember);

         void AddItem(global::Thinktecture.Tests.TestEnum item, string itemName)
         {
            if(item is null)
               throw new global::System.ArgumentNullException($""The item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(item.Key is null)
               throw new global::System.ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(!item.IsValid)
               throw new global::System.ArgumentException($""All \""public static readonly\"" fields of type \""TestEnum\"" must be valid but the item \""{itemName}\"" with the identifier \""{item.Key}\"" is not."");

            if (lookup.ContainsKey(item.Key))
               throw new global::System.ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(Item1, nameof(Item1));
         AddItem(Item2, nameof(Item2));

         return lookup;
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_simple_struct_which_implements_IValidatableEnum()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
	public readonly partial struct TestEnum : IValidatableEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IValidatableEnum<>).Assembly);

      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestEnum_EnumTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestEnum, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      protected override global::Thinktecture.Tests.TestEnum ConvertFrom(string? key)
      {
         return global::Thinktecture.Tests.TestEnum.Get(key);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestEnum item)
      {
         return item.Key;
      }
   }

   [global::System.Runtime.InteropServices.StructLayout(global::System.Runtime.InteropServices.LayoutKind.Auto)]
   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(Key))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestEnum_EnumTypeConverter))]
   partial struct TestEnum : global::System.IEquatable<global::Thinktecture.Tests.TestEnum>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string?, global::Thinktecture.Tests.TestEnum>(global::Thinktecture.Tests.TestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<string?, global::Thinktecture.Tests.TestEnum>> convertFromKeyExpression = key => global::Thinktecture.Tests.TestEnum.Get(key);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestEnum, string?>(item => item.Key);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestEnum, string?>> convertToKeyExpression = item => item.Key;

         var validate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestEnum, string>(global::Thinktecture.Tests.TestEnum.Validate);

         var enumType = typeof(global::Thinktecture.Tests.TestEnum);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(enumType, typeof(string), true, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, validate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::Thinktecture.Tests.TestEnum).GetHashCode() * 397;
      private static readonly global::System.Collections.Generic.IEqualityComparer<string?> _defaultKeyComparerMember = global::System.StringComparer.OrdinalIgnoreCase;

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum>? _itemsLookup;
      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> Items => _items ??= global::System.Linq.Enumerable.ToList(ItemsLookup.Values).AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [global::System.Diagnostics.CodeAnalysis.NotNull]
      public string Key { get; }

      /// <inheritdoc />
      public bool IsValid { get; }

      /// <summary>
      /// Checks whether current enumeration item is valid.
      /// </summary>
      /// <exception cref=""System.InvalidOperationException"">The enumeration item is not valid.</exception>
      public void EnsureValid()
      {
         if (!IsValid)
            throw new global::System.InvalidOperationException($""The current enumeration item of type \""TestEnum\"" with identifier \""{this.Key}\"" is not valid."");
      }

      private TestEnum(string key)
         : this(key, true)
      {
      }

      private TestEnum(string key, bool isValid)
      {
         ValidateConstructorArguments(ref key, isValid);

         if (key is null)
            throw new global::System.ArgumentNullException(nameof(key));

         this.Key = key;
         this.IsValid = isValid;
      }

      static partial void ValidateConstructorArguments(ref string key, bool isValid);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string global::Thinktecture.IEnum<string>.GetKey()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""key""/>.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""key""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static global::Thinktecture.Tests.TestEnum Get(string? key)
      {
        if (key is null)
            return default;

         if (!ItemsLookup.TryGetValue(key, out var item))
         {
            item = CreateInvalidItem(key);

            if (item.IsValid)
               throw new global::System.Exception(""The implementation of method 'CreateInvalidItem' must return an instance with property 'IsValid' equals to 'false'."");
         }

         return item;
      }

      private static global::Thinktecture.Tests.TestEnum CreateInvalidItem(string key)
      {
         return new global::Thinktecture.Tests.TestEnum(key, false);
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""key""/> if a valid item exists.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""key""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] string key, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestEnum item)
      {
         if (key is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(key, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name=""key""/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name=""key"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns> <see cref=""System.ComponentModel.DataAnnotations.ValidationResult.Success""/> if a valid item with provided <paramref name=""key""/> exists; <see cref=""System.ComponentModel.DataAnnotations.ValidationResult""/> with an error message otherwise.</returns>
      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(string key, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestEnum item)
      {
         return global::Thinktecture.Tests.TestEnum.TryGet(key, out item)
               ? global::System.ComponentModel.DataAnnotations.ValidationResult.Success
               : new global::System.ComponentModel.DataAnnotations.ValidationResult($""The enumeration item of type \""TestEnum\"" with identifier \""{key}\"" is not valid."");
      }

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""TestEnum.Key""/> of provided <paramref name=""item""/> or <c>default</c> if <paramref name=""item""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""item"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestEnum item)
      {
         return item.Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""key"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestEnum""/> if the <paramref name=""key""/> is a known item or implements <see cref=""Thinktecture.IValidatableEnum{TKey}""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""key"")]
      public static explicit operator global::Thinktecture.Tests.TestEnum(string? key)
      {
         return global::Thinktecture.Tests.TestEnum.Get(key);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestEnum item1, global::Thinktecture.Tests.TestEnum item2)
      {
         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestEnum item1, global::Thinktecture.Tests.TestEnum item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestEnum other)
      {
         if (this.IsValid != other.IsValid)
            return false;

         return _defaultKeyComparerMember.Equals(this.Key, other.Key);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _defaultKeyComparerMember.GetHashCode(this.Key);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Key?.ToString();
      }

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> GetLookup()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<string, global::Thinktecture.Tests.TestEnum>(2, _defaultKeyComparerMember);

         void AddItem(global::Thinktecture.Tests.TestEnum item, string itemName)
         {
            if(item.Key is null)
               throw new global::System.ArgumentException($""The \""Key\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(!item.IsValid)
               throw new global::System.ArgumentException($""All \""public static readonly\"" fields of type \""TestEnum\"" must be valid but the item \""{itemName}\"" with the identifier \""{item.Key}\"" is not."");

            if (lookup.ContainsKey(item.Key))
               throw new global::System.ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Key}\""."");

            lookup.Add(item.Key, item);
         }

         AddItem(Item1, nameof(Item1));
         AddItem(Item2, nameof(Item2));

         return lookup;
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_advanced_class_which_implements_IValidatableEnum()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
   [EnumGeneration(KeyPropertyName = ""Name"", KeyComparer = ""_testEqualityComparer"")]
	public partial class TestEnum : IValidatableEnum<string>
	{
      private static readonly System.Collections.Generic.IEqualityComparer<string> _testEqualityComparer = StringComparer.Ordinal;

		public static readonly TestEnum Item1 = new(""Item1"", 1, -1, ""ReferenceProperty1"", ""NullableReferenceProperty1"", 11, ""ReferenceField1"");
      public static readonly TestEnum Item2 = new DerivedEnum(""Item2"", 2, 2, ""ReferenceProperty2"", ""NullableReferenceProperty2"", 22, ""ReferenceField2"");

      public int StructProperty { get; }
      public int? NullableStructProperty { get; }
      public string ReferenceProperty { get; }
      public string? NullableReferenceProperty { get; }
      public readonly int StructField;
      public readonly string ReferenceField;

      static partial void ValidateConstructorArguments(
         int name, bool isValid,
         int structProperty, int? nullableStructProperty,
         string referenceProperty, string? nullableReferenceProperty,
         int structField, string referenceField)
      {
      }

      private static ProductCategory CreateInvalidItem(string name)
      {
         return new(name, false, 0, null, String.Empty, null, 0, null);
      }

      private class DerivedEnum : EnumWithDerivedType
      {
         public DerivedEnum(
            int name, bool isValid,
            int structProperty, int? nullableStructProperty,
            string referenceProperty, string? nullableReferenceProperty,
            int structField, string referenceField)
            : base(name, isValid, structProperty, nullableStructProperty, referenceProperty, nullableReferenceProperty, structField, referenceField)
         {
         }
      }
   }
}
";
      var output = GetGeneratedOutput<SmartEnumSourceGenerator>(source, typeof(IValidatableEnum<>).Assembly);

      AssertOutput(output, _GENERATED_HEADER + @"
namespace Thinktecture.Tests
{
   public class TestEnum_EnumTypeConverter : global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests.TestEnum, string>
   {
      /// <inheritdoc />
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""name"")]
      protected override global::Thinktecture.Tests.TestEnum? ConvertFrom(string? name)
      {
         return global::Thinktecture.Tests.TestEnum.Get(name);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(global::Thinktecture.Tests.TestEnum item)
      {
         return item.Name;
      }
   }

   [global::Thinktecture.Internal.ValueObjectConstructor(nameof(Name), nameof(StructProperty), nameof(NullableStructProperty), nameof(ReferenceProperty), nameof(NullableReferenceProperty), nameof(StructField), nameof(ReferenceField))]
   [global::Thinktecture.Internal.KeyedValueObject]
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.Tests.TestEnum_EnumTypeConverter))]
   partial class TestEnum : global::System.IEquatable<global::Thinktecture.Tests.TestEnum?>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<string?, global::Thinktecture.Tests.TestEnum?>(global::Thinktecture.Tests.TestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<string?, global::Thinktecture.Tests.TestEnum?>> convertFromKeyExpression = name => global::Thinktecture.Tests.TestEnum.Get(name);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests.TestEnum, string?>(item => item.Name);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests.TestEnum, string?>> convertToKeyExpression = item => item.Name;

         var validate = new global::Thinktecture.Internal.Validate<global::Thinktecture.Tests.TestEnum, string>(global::Thinktecture.Tests.TestEnum.Validate);

         var enumType = typeof(global::Thinktecture.Tests.TestEnum);
         var metadata = new global::Thinktecture.Internal.ValueObjectMetadata(enumType, typeof(string), true, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, validate);

         global::Thinktecture.Internal.ValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::Thinktecture.Tests.TestEnum).GetHashCode() * 397;

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum>? _itemsLookup;
      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> ItemsLookup => _itemsLookup ??= GetLookup();

      private static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum>? _items;

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> Items => _items ??= global::System.Linq.Enumerable.ToList(ItemsLookup.Values).AsReadOnly();

      /// <summary>
      /// The identifier of the item.
      /// </summary>
      [global::System.Diagnostics.CodeAnalysis.NotNull]
      public string Name { get; }

      /// <inheritdoc />
      public bool IsValid { get; }

      /// <summary>
      /// Checks whether current enumeration item is valid.
      /// </summary>
      /// <exception cref=""System.InvalidOperationException"">The enumeration item is not valid.</exception>
      public void EnsureValid()
      {
         if (!IsValid)
            throw new global::System.InvalidOperationException($""The current enumeration item of type \""TestEnum\"" with identifier \""{this.Name}\"" is not valid."");
      }

      private TestEnum(string name, int structProperty, int? nullableStructProperty, string referenceProperty, string? nullableReferenceProperty, int structField, string referenceField)
         : this(name, true, structProperty, nullableStructProperty, referenceProperty, nullableReferenceProperty, structField, referenceField)
      {
      }

      private TestEnum(string name, bool isValid, int structProperty, int? nullableStructProperty, string referenceProperty, string? nullableReferenceProperty, int structField, string referenceField)
      {
         ValidateConstructorArguments(ref name, isValid, ref structProperty, ref nullableStructProperty, ref referenceProperty, ref nullableReferenceProperty, ref structField, ref referenceField);

         if (name is null)
            throw new global::System.ArgumentNullException(nameof(name));

         this.Name = name;
         this.IsValid = isValid;
         this.StructProperty = structProperty;
         this.NullableStructProperty = nullableStructProperty;
         this.ReferenceProperty = referenceProperty;
         this.NullableReferenceProperty = nullableReferenceProperty;
         this.StructField = structField;
         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string name, bool isValid, ref int structProperty, ref int? nullableStructProperty, ref string referenceProperty, ref string? nullableReferenceProperty, ref int structField, ref string referenceField);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      string global::Thinktecture.IEnum<string>.GetKey()
      {
         return this.Name;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name=""name""/>.
      /// </summary>
      /// <param name=""name"">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref=""TestEnum"" /> if <paramref name=""name""/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""name"")]
      public static global::Thinktecture.Tests.TestEnum? Get(string? name)
      {
        if (name is null)
            return default;

         if (!ItemsLookup.TryGetValue(name, out var item))
         {
            item = CreateInvalidItem(name);

            if (item is null)
               throw new global::System.Exception(""The implementation of method 'CreateInvalidItem' must not return 'null'."");

            if (item.IsValid)
               throw new global::System.Exception(""The implementation of method 'CreateInvalidItem' must return an instance with property 'IsValid' equals to 'false'."");

            if (global::Thinktecture.Tests.TestEnum.TryGet(item.Name, out _))
               throw new global::System.Exception(""The implementation of method 'CreateInvalidItem' must not return an instance with property 'Name' equals to one of a valid item."");
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name=""name""/> if a valid item exists.
      /// </summary>
      /// <param name=""name"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name=""name""/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] string name, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestEnum item)
      {
         if (name is null)
         {
            item = default;
            return false;
         }

         return ItemsLookup.TryGetValue(name, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name=""name""/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name=""name"">The identifier to return an enumeration item for.</param>
      /// <param name=""item"">A valid instance of <see cref=""TestEnum""/>; otherwise <c>null</c>.</param>
      /// <returns> <see cref=""System.ComponentModel.DataAnnotations.ValidationResult.Success""/> if a valid item with provided <paramref name=""name""/> exists; <see cref=""System.ComponentModel.DataAnnotations.ValidationResult""/> with an error message otherwise.</returns>
      public static global::System.ComponentModel.DataAnnotations.ValidationResult? Validate(string name, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestEnum item)
      {
         return global::Thinktecture.Tests.TestEnum.TryGet(name, out item)
               ? global::System.ComponentModel.DataAnnotations.ValidationResult.Success
               : new global::System.ComponentModel.DataAnnotations.ValidationResult($""The enumeration item of type \""TestEnum\"" with identifier \""{name}\"" is not valid."");
      }

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""item"">Item to covert.</param>
      /// <returns>The <see cref=""TestEnum.Name""/> of provided <paramref name=""item""/> or <c>default</c> if <paramref name=""item""/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""item"")]
      public static implicit operator string?(global::Thinktecture.Tests.TestEnum? item)
      {
         return item is null ? default : item.Name;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""name"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestEnum""/> if the <paramref name=""name""/> is a known item or implements <see cref=""Thinktecture.IValidatableEnum{TKey}""/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull(""name"")]
      public static explicit operator global::Thinktecture.Tests.TestEnum?(string? name)
      {
         return global::Thinktecture.Tests.TestEnum.Get(name);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>true</c> if items are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(global::Thinktecture.Tests.TestEnum? item1, global::Thinktecture.Tests.TestEnum? item2)
      {
         if (item1 is null)
            return item2 is null;

         return item1.Equals(item2);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestEnum""/>.
      /// </summary>
      /// <param name=""item1"">Instance to compare.</param>
      /// <param name=""item2"">Another instance to compare.</param>
      /// <returns><c>false</c> if items are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(global::Thinktecture.Tests.TestEnum? item1, global::Thinktecture.Tests.TestEnum? item2)
      {
         return !(item1 == item2);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestEnum? other)
      {
         if (other is null)
            return false;

         if (!global::System.Object.ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         if (this.IsValid != other.IsValid)
            return false;

         return _testEqualityComparer.Equals(this.Name, other.Name);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _typeHashCode ^ _testEqualityComparer.GetHashCode(this.Name);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.Name.ToString();
      }

      private static global::System.Collections.Generic.IReadOnlyDictionary<string, global::Thinktecture.Tests.TestEnum> GetLookup()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<string, global::Thinktecture.Tests.TestEnum>(2, _testEqualityComparer);

         void AddItem(global::Thinktecture.Tests.TestEnum item, string itemName)
         {
            if(item is null)
               throw new global::System.ArgumentNullException($""The item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(item.Name is null)
               throw new global::System.ArgumentException($""The \""Name\"" of the item \""{itemName}\"" of type \""TestEnum\"" must not be null."");

            if(!item.IsValid)
               throw new global::System.ArgumentException($""All \""public static readonly\"" fields of type \""TestEnum\"" must be valid but the item \""{itemName}\"" with the identifier \""{item.Name}\"" is not."");

            if (lookup.ContainsKey(item.Name))
               throw new global::System.ArgumentException($""The type \""TestEnum\"" has multiple items with the identifier \""{item.Name}\""."");

            lookup.Add(item.Name, item);
         }

         AddItem(Item1, nameof(Item1));
         AddItem(Item2, nameof(Item2));

         return lookup;
      }
   }
}
");
   }
}
