// <auto-generated />
#nullable enable

namespace Thinktecture.Tests
{
   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("ThinktectureRuntimeExtensionsAnalyzer", "TTRESG1000:Internal Thinktecture.Runtime.Extensions API usage")]
   sealed partial class TestEnum :
      global::Thinktecture.Internal.IMetadataOwner,
      global::System.IEquatable<global::Thinktecture.Tests.TestEnum?>
   {
      static global::Thinktecture.Internal.Metadata global::Thinktecture.Internal.IMetadataOwner.Metadata { get; }
         = new global::Thinktecture.Internal.Metadata.KeylessSmartEnum(typeof(global::Thinktecture.Tests.TestEnum))
         {
            Items = new global::System.Lazy<global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Internal.KeylessSmartEnumItemMetadata>>(
                     () => new global::System.Collections.Generic.List<global::Thinktecture.Internal.KeylessSmartEnumItemMetadata>(
                        global::System.Linq.Enumerable.Select(global::Thinktecture.Tests.TestEnum.Items, (item, index) =>
                        {
                           string identifier = index switch
                           {
                              0 => "Item1", 
                              1 => "Item2", 
                              _ => throw new global::System.ArgumentOutOfRangeException($"Unknown item at index {index}.")
                           };

                           return new global::Thinktecture.Internal.KeylessSmartEnumItemMetadata
                           {
                              Item = item,
                              Identifier = identifier
                           };
                        })).AsReadOnly()),
         };

      private static readonly global::System.Lazy<global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum>> _items
                                             = new global::System.Lazy<global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum>>(GetItems, global::System.Threading.LazyThreadSafetyMode.ExecutionAndPublication);

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> Items => _items.Value;

      private readonly int _hashCode;
      private readonly global::Thinktecture.Internal.WriteOnceInt _itemIndex;

      private TestEnum()
      {
         ValidateConstructorArguments();

         this._itemIndex = new global::Thinktecture.Internal.WriteOnceInt();
         this._hashCode = base.GetHashCode();
      }

      static partial void ValidateConstructorArguments();

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestEnum? other)
      {
         return global::System.Object.ReferenceEquals(this, other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _hashCode;
      }

      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      private int GetItemIndex()
      {
         var index = _itemIndex.Value; // fast-path (may be stale)

         if (index >= 0)
            return index;

         _ = Items;
         return _itemIndex.ReadVolatile();
      }

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes an action depending on the current item.
      /// </summary>
      /// <param name="item1">The action to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The action to execute if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public void Switch(
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item1,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item2)
      {
         switch (GetItemIndex())
         {
            case 0:
               @item1();
               return;
            case 1:
               @item2();
               return;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes an action depending on the current item.
      /// </summary>
      /// <param name="default">The action to execute if no item-specific action is provided.</param>
      /// <param name="item1">The action to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The action to execute if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public void SwitchPartially(
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.TestEnum>? @default = null,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action? @item1 = null,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action? @item2 = null)
      {
         switch (GetItemIndex())
         {
            case 0:
               if (@item1 is null)
                  break;

               @item1();
               return;
            case 1:
               if (@item2 is null)
                  break;

               @item2();
               return;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }

         @default?.Invoke(this);
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes an action depending on the current item.
      /// </summary>
      /// <param name="state">State to be passed to the callbacks.</param>
      /// <param name="item1">The action to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The action to execute if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public void Switch<TState>(
         TState @state,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item1,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item2)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               @item1(@state);
               return;
            case 1:
               @item2(@state);
               return;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes an action depending on the current item.
      /// </summary>
      /// <param name="state">State to be passed to the callbacks.</param>
      /// <param name="default">The action to execute if no item-specific action is provided.</param>
      /// <param name="item1">The action to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The action to execute if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public void SwitchPartially<TState>(
         TState @state,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.TestEnum>? @default = null,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState>? @item1 = null,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState>? @item2 = null)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               if (@item1 is null)
                  break;

               @item1(@state);
               return;
            case 1:
               if (@item2 is null)
                  break;

               @item2(@state);
               return;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }

         @default?.Invoke(@state, this);
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes a function depending on the current item.
      /// </summary>
      /// <param name="item1">The function to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The function to execute if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult Switch<TResult>(
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item1,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item2)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               return @item1();
            case 1:
               return @item2();
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes a function depending on the current item.
      /// </summary>
      /// <param name="default">The function to execute if no item-specific action is provided.</param>
      /// <param name="item1">The function to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The function to execute if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult SwitchPartially<TResult>(
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.TestEnum, TResult> @default,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult>? @item1 = null,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult>? @item2 = null)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               if (@item1 is null)
                  break;

               return @item1();
            case 1:
               if (@item2 is null)
                  break;

               return @item2();
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }

         return @default(this);
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes a function depending on the current item.
      /// </summary>
      /// <param name="state">State to be passed to the callbacks.</param>
      /// <param name="item1">The function to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The function to execute if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult Switch<TState, TResult>(
         TState @state,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item1,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item2)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
		   where TState : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               return @item1(@state);
            case 1:
               return @item2(@state);
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes a function depending on the current item.
      /// </summary>
      /// <param name="state">State to be passed to the callbacks.</param>
      /// <param name="default">The function to execute if no item-specific action is provided.</param>
      /// <param name="item1">The function to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The function to execute if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult SwitchPartially<TState, TResult>(
         TState @state,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.TestEnum, TResult> @default,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult>? @item1 = null,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult>? @item2 = null)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
		   where TState : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               if (@item1 is null)
                  break;

               return @item1(@state);
            case 1:
               if (@item2 is null)
                  break;

               return @item2(@state);
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }

         return @default(@state, this);
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

      /// <summary>
      /// Maps an item to an instance of type <typeparamref name="TResult"/>.
      /// </summary>
      /// <param name="item1">The instance to return if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The instance to return if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult Map<TResult>(
         TResult @item1,
         TResult @item2)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               return @item1;
            case 1:
               return @item2;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }

      /// <summary>
      /// Maps an item to an instance of type <typeparamref name="TResult"/>.
      /// </summary>
      /// <param name="default">The instance to return if no value is provided for current item.</param>
      /// <param name="item1">The instance to return if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The instance to return if the current item is equal to <see cref="Item2"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult MapPartially<TResult>(
         TResult @default,
         global::Thinktecture.Argument<TResult> @item1 = default,
         global::Thinktecture.Argument<TResult> @item2 = default)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               if (!@item1.IsSet)
                  break;

               return @item1.Value;
            case 1:
               if (!@item2.IsSet)
                  break;

               return @item2.Value;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }

         return @default;
      }

      private static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> GetItems()
      {
         var list = new global::System.Collections.Generic.List<global::Thinktecture.Tests.TestEnum>(2);

         void AddItem(global::Thinktecture.Tests.TestEnum item, string itemName)
         {
            if (item is null)
               throw new global::System.ArgumentNullException($"The item \"{itemName}\" of type \"TestEnum\" must not be null.");

            item._itemIndex.Set(list.Count);
            list.Add(item);
         }

         AddItem(@Item1, nameof(@Item1));
         AddItem(@Item2, nameof(@Item2));

         return list.AsReadOnly();
      }
   }
}
