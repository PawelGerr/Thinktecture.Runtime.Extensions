using Thinktecture.CodeAnalysis;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class NewtonsoftJsonValueObjectSourceGeneratorTests : SourceGeneratorTestsBase
{
   public NewtonsoftJsonValueObjectSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_and_Attribute_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<NewtonsoftJsonValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial class TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Thinktecture.Json.ValueObjectNewtonsoftJsonConverter<TestValueObject, string>
      {
         public ValueObjectNewtonsoftJsonConverter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_for_keyed_value_object_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
   public readonly string ReferenceField;
}
";
      var output = GetGeneratedOutput<NewtonsoftJsonValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial class TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Thinktecture.Json.ValueObjectNewtonsoftJsonConverter<TestValueObject, string>
      {
         public ValueObjectNewtonsoftJsonConverter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_struct_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<NewtonsoftJsonValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial struct TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Thinktecture.Json.ValueObjectNewtonsoftJsonConverter<TestValueObject, string>
      {
         public ValueObjectNewtonsoftJsonConverter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<NewtonsoftJsonValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Thinktecture;
using JsonException = Newtonsoft.Json.JsonException;
using JsonToken = Newtonsoft.Json.JsonToken;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial class TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Newtonsoft.Json.JsonConverter<TestValueObject?>
      {
         /// <inheritdoc />
         public override TestValueObject? ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, TestValueObject? existingValue, bool hasExistingValue, Newtonsoft.Json.JsonSerializer serializer)
         {
            if (reader is null)
               throw new System.ArgumentNullException(nameof(reader));
            if (serializer is null)
               throw new System.ArgumentNullException(nameof(serializer));

            if (reader.TokenType == JsonToken.Null)
               return default;

            if (reader.TokenType != JsonToken.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = System.StringComparer.OrdinalIgnoreCase;

            while (reader.Read())
            {
               if (reader.TokenType == JsonToken.EndObject)
                  break;

               if (reader.TokenType != JsonToken.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.PropertyName}'."");

               var propName = reader.Value!.ToString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueObject'."");

               if (comparer.Equals(propName, ""referenceField""))
               {
                  referenceField = serializer.Deserialize<string>(reader);
               }
               else if (comparer.Equals(propName, ""structProperty""))
               {
                  structProperty = serializer.Deserialize<int>(reader);
               }
               else if (comparer.Equals(propName, ""nullableStructProperty""))
               {
                  nullableStructProperty = serializer.Deserialize<decimal?>(reader);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueObject'."");
               }
            }

            var validationResult = TestValueObject.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void WriteJson(Newtonsoft.Json.JsonWriter writer, TestValueObject? value, Newtonsoft.Json.JsonSerializer serializer)
         {
            if (value == null)
            {
               writer.WriteNull();
               return;
            }

            var resolver = serializer.ContractResolver as Newtonsoft.Json.Serialization.DefaultContractResolver;

            writer.WriteStartObject();
            var referenceFieldPropertyValue = value.ReferenceField;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""ReferenceField"") : ""ReferenceField"");
               writer.WriteValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""StructProperty"") : ""StructProperty"");
            writer.WriteValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""NullableStructProperty"") : ""NullableStructProperty"");
               serializer.Serialize(writer, nullableStructPropertyPropertyValue);
            }
            writer.WriteEndObject();
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_for_non_key_value_object_whithout_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
   public readonly string ReferenceField;
   public int StructProperty { get; }
   public decimal? NullableStructProperty { get; }
}
";
      var output = GetGeneratedOutput<NewtonsoftJsonValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Thinktecture;
using JsonException = Newtonsoft.Json.JsonException;
using JsonToken = Newtonsoft.Json.JsonToken;

   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial class TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Newtonsoft.Json.JsonConverter<TestValueObject?>
      {
         /// <inheritdoc />
         public override TestValueObject? ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, TestValueObject? existingValue, bool hasExistingValue, Newtonsoft.Json.JsonSerializer serializer)
         {
            if (reader is null)
               throw new System.ArgumentNullException(nameof(reader));
            if (serializer is null)
               throw new System.ArgumentNullException(nameof(serializer));

            if (reader.TokenType == JsonToken.Null)
               return default;

            if (reader.TokenType != JsonToken.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = System.StringComparer.OrdinalIgnoreCase;

            while (reader.Read())
            {
               if (reader.TokenType == JsonToken.EndObject)
                  break;

               if (reader.TokenType != JsonToken.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.PropertyName}'."");

               var propName = reader.Value!.ToString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueObject'."");

               if (comparer.Equals(propName, ""referenceField""))
               {
                  referenceField = serializer.Deserialize<string>(reader);
               }
               else if (comparer.Equals(propName, ""structProperty""))
               {
                  structProperty = serializer.Deserialize<int>(reader);
               }
               else if (comparer.Equals(propName, ""nullableStructProperty""))
               {
                  nullableStructProperty = serializer.Deserialize<decimal?>(reader);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueObject'."");
               }
            }

            var validationResult = TestValueObject.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void WriteJson(Newtonsoft.Json.JsonWriter writer, TestValueObject? value, Newtonsoft.Json.JsonSerializer serializer)
         {
            if (value == null)
            {
               writer.WriteNull();
               return;
            }

            var resolver = serializer.ContractResolver as Newtonsoft.Json.Serialization.DefaultContractResolver;

            writer.WriteStartObject();
            var referenceFieldPropertyValue = value.ReferenceField;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""ReferenceField"") : ""ReferenceField"");
               writer.WriteValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""StructProperty"") : ""StructProperty"");
            writer.WriteValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""NullableStructProperty"") : ""NullableStructProperty"");
               serializer.Serialize(writer, nullableStructPropertyPropertyValue);
            }
            writer.WriteEndObject();
         }
      }
   }
");
   }

   [Fact]
   public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<NewtonsoftJsonValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(Json.ValueObjectNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Thinktecture;
using JsonException = Newtonsoft.Json.JsonException;
using JsonToken = Newtonsoft.Json.JsonToken;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueObjectNewtonsoftJsonConverter))]
   partial struct TestValueObject
   {
      public class ValueObjectNewtonsoftJsonConverter : Newtonsoft.Json.JsonConverter<TestValueObject>
      {
         /// <inheritdoc />
         public override TestValueObject ReadJson(Newtonsoft.Json.JsonReader reader, System.Type objectType, TestValueObject existingValue, bool hasExistingValue, Newtonsoft.Json.JsonSerializer serializer)
         {
            if (reader is null)
               throw new System.ArgumentNullException(nameof(reader));
            if (serializer is null)
               throw new System.ArgumentNullException(nameof(serializer));

            if (reader.TokenType == JsonToken.Null)
               return default;

            if (reader.TokenType != JsonToken.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = System.StringComparer.OrdinalIgnoreCase;

            while (reader.Read())
            {
               if (reader.TokenType == JsonToken.EndObject)
                  break;

               if (reader.TokenType != JsonToken.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueObject'. Expected token: '{JsonToken.PropertyName}'."");

               var propName = reader.Value!.ToString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueObject'."");

               if (comparer.Equals(propName, ""referenceField""))
               {
                  referenceField = serializer.Deserialize<string>(reader);
               }
               else if (comparer.Equals(propName, ""structProperty""))
               {
                  structProperty = serializer.Deserialize<int>(reader);
               }
               else if (comparer.Equals(propName, ""nullableStructProperty""))
               {
                  nullableStructProperty = serializer.Deserialize<decimal?>(reader);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueObject'."");
               }
            }

            var validationResult = TestValueObject.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void WriteJson(Newtonsoft.Json.JsonWriter writer, TestValueObject value, Newtonsoft.Json.JsonSerializer serializer)
         {
            var resolver = serializer.ContractResolver as Newtonsoft.Json.Serialization.DefaultContractResolver;

            writer.WriteStartObject();
            var referenceFieldPropertyValue = value.ReferenceField;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""ReferenceField"") : ""ReferenceField"");
               writer.WriteValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""StructProperty"") : ""StructProperty"");
            writer.WriteValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(serializer.NullValueHandling != Newtonsoft.Json.NullValueHandling.Ignore || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""NullableStructProperty"") : ""NullableStructProperty"");
               serializer.Serialize(writer, nullableStructPropertyPropertyValue);
            }
            writer.WriteEndObject();
         }
      }
   }
}
");
   }
}
