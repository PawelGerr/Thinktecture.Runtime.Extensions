using Thinktecture.CodeAnalysis;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class JsonSmartEnumSourceGeneratorTests : SourceGeneratorTestsBase
{
   public JsonSmartEnumSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   [Fact]
   public void Should_generate_JsonConverter_and_Attribute_if_Attribute_is_missing()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<JsonSmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

namespace Thinktecture.Tests
{
   [global::System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueObjectJsonConverterFactory))]
   partial class TestEnum
   {
      public class ValueObjectJsonConverterFactory : global::System.Text.Json.Serialization.JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(global::System.Type typeToConvert)
         {
            return typeof(global::Thinktecture.Tests.TestEnum).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override global::System.Text.Json.Serialization.JsonConverter CreateConverter(global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new global::System.ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new global::System.ArgumentNullException(nameof(options));

            return new global::Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<global::Thinktecture.Tests.TestEnum, string>(global::Thinktecture.Tests.TestEnum.Get, static obj => obj.Key, options);
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_JsonConverter_for_enum_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

public partial class TestEnum : IEnum<string>
{
   public static readonly TestEnum Item1 = new(""Item1"");
   public static readonly TestEnum Item2 = new(""Item2"");
}
";
      var output = GetGeneratedOutput<JsonSmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

   [global::System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueObjectJsonConverterFactory))]
   partial class TestEnum
   {
      public class ValueObjectJsonConverterFactory : global::System.Text.Json.Serialization.JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(global::System.Type typeToConvert)
         {
            return typeof(global::TestEnum).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override global::System.Text.Json.Serialization.JsonConverter CreateConverter(global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new global::System.ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new global::System.ArgumentNullException(nameof(options));

            return new global::Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<global::TestEnum, string>(global::TestEnum.Get, static obj => obj.Key, options);
         }
      }
   }
");
   }

   [Fact]
   public void Should_generate_JsonConverter_and_Attribute_for_struct_if_Attribute_is_missing()
   {
      var source = @"
using System;

namespace Thinktecture.Tests
{
	public readonly partial struct TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<JsonSmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

namespace Thinktecture.Tests
{
   [global::System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueObjectJsonConverterFactory))]
   partial struct TestEnum
   {
      public class ValueObjectJsonConverterFactory : global::System.Text.Json.Serialization.JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(global::System.Type typeToConvert)
         {
            return typeof(global::Thinktecture.Tests.TestEnum).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override global::System.Text.Json.Serialization.JsonConverter CreateConverter(global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new global::System.ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new global::System.ArgumentNullException(nameof(options));

            return new global::Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<global::Thinktecture.Tests.TestEnum, string>(global::Thinktecture.Tests.TestEnum.Get, static obj => obj.Key, options);
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_not_generate_JsonConverter_and_attribute_if_Attribute_is_present()
   {
      var source = @"
using System;
using System.Text.Json.Serialization;

namespace Thinktecture.Tests
{
   public class TestEnumJsonConverter : Thinktecture.Text.Json.Serialization.EnumJsonConverter<TestEnum, string>
   {
      public TestEnum_EnumJsonConverter()
         : this(null)
      {
      }

      public TestEnum_EnumJsonConverter(
         JsonConverter<string>? keyConverter)
         : base(TestEnum.Get, keyConverter)
      {
      }
   }

   [JsonConverter(typeof(TestEnumJsonConverter))]
	public partial class TestEnum : IEnum<string>
	{
      public static readonly TestEnum Item1 = new(""Item1"");
      public static readonly TestEnum Item2 = new(""Item2"");
   }
}
";
      var output = GetGeneratedOutput<JsonSmartEnumSourceGenerator>(source, typeof(IEnum<>).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueObjectJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

      output.Should().BeNull();
   }
}
