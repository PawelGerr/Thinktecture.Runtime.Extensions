using FluentAssertions;
using MessagePack;
using Thinktecture.CodeAnalysis;
using Thinktecture.Formatters;
using Xunit;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests
{
   public class ValueTypeSourceGeneratorTests : SourceGeneratorTestsBase
   {
      public ValueTypeSourceGeneratorTests(ITestOutputHelper output)
         : base(output)
      {
      }

      private const string _SIMPLE_VALUE_TYPE_OUTPUT = @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Thinktecture.Internal.ValueTypeConstructor()]
   partial class TestValueType : System.IEquatable<TestValueType?>
   {
      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create()
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType();
      }

      public static ValidationResult? TryCreate(
         [MaybeNull] out TestValueType? obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType()
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueType"";
      }
   }
}
";

      [Fact]
      public void Should_generate_simple_class_with_ValueTypeAttribute()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(_SIMPLE_VALUE_TYPE_OUTPUT);
      }

      [Fact]
      public void Should_generate_simple_class_with_ValueTypeAttribute_using_long_form()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueTypeAttribute]
	public partial class TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(_SIMPLE_VALUE_TYPE_OUTPUT);
      }

      [Fact]
      public void Should_generate_simple_class_with_fully_qualified_ValueTypeAttribute()
      {
         var source = @"
using System;

namespace Thinktecture.Tests
{
   [Thinktecture.ValueType]
	public partial class TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(_SIMPLE_VALUE_TYPE_OUTPUT);
      }

      [Fact]
      public void Should_not_generate_factory_methods_if_SkipFactoryMethods_is_true()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType(SkipFactoryMethods = true)]
	public partial class TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Thinktecture.Internal.ValueTypeConstructor()]
   partial class TestValueType : System.IEquatable<TestValueType?>
   {
      private static readonly Type _type = typeof(TestValueType);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueType"";
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_simple_struct_with_ValueTypeAttribute()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Thinktecture.Internal.ValueTypeConstructor()]
   partial struct TestValueType : System.IEquatable<TestValueType>
   {
      private static readonly Type _type = typeof(TestValueType);

      public static readonly TestValueType Empty = default;

      public static TestValueType Create()
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType();
      }

      public static ValidationResult? TryCreate(
         [MaybeNull] out TestValueType obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType()
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType obj, TestValueType other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType obj, TestValueType other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType other)
      {
         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueType"";
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_struct_with_string_key_member()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueType ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(TestValueType);

         return TestValueType.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueType obj)
      {
         return (string) obj;
      }
   }

   [Thinktecture.Internal.ValueTypeConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueType]
   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial struct TestValueType : System.IEquatable<TestValueType>, System.IComparable, System.IComparable<TestValueType>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<string, TestValueType>(TestValueType.Create);
         Expression<Func<string, TestValueType>> convertFromKeyExpression = referenceField => new TestValueType(referenceField);

         var convertToKey = new Func<TestValueType, string>(item => item.ReferenceField);
         Expression<Func<TestValueType, string>> convertToKeyExpression = obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueType, string>(TestValueType.TryCreate);

         var type = typeof(TestValueType);
         var metadata = new Thinktecture.Internal.ValueTypeMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static readonly TestValueType Empty = default;

      public static TestValueType Create(string referenceField)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(referenceField);
      }

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueType obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(referenceField)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueType obj)
      {
         return obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      public static explicit operator TestValueType(string referenceField)
      {
         return TestValueType.Create(referenceField);
      }

      private TestValueType(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType obj, TestValueType other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType obj, TestValueType other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType other)
      {
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not TestValueType valueType)
            throw new ArgumentException(""Argument must be of type 'TestValueType'."", nameof(obj));

         return this.CompareTo(valueType);
      }

      /// <inheritdoc />
      public int CompareTo(TestValueType obj)
      {
         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_struct_with_string_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType(NullInFactoryMethodsYieldsNull = true)]
	public readonly partial struct TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueType ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(TestValueType);

         return TestValueType.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueType obj)
      {
         return (string) obj;
      }
   }

   [Thinktecture.Internal.ValueTypeConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueType]
   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial struct TestValueType : System.IEquatable<TestValueType>, System.IComparable, System.IComparable<TestValueType>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<string, TestValueType>(TestValueType.Create);
         Expression<Func<string, TestValueType>> convertFromKeyExpression = referenceField => new TestValueType(referenceField);

         var convertToKey = new Func<TestValueType, string>(item => item.ReferenceField);
         Expression<Func<TestValueType, string>> convertToKeyExpression = obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueType, string>(TestValueType.TryCreate);

         var type = typeof(TestValueType);
         var metadata = new Thinktecture.Internal.ValueTypeMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static readonly TestValueType Empty = default;

      public static TestValueType Create(string referenceField)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(referenceField);
      }

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueType obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(referenceField)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueType obj)
      {
         return obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      public static explicit operator TestValueType(string referenceField)
      {
         return TestValueType.Create(referenceField);
      }

      private TestValueType(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType obj, TestValueType other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType obj, TestValueType other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType other)
      {
         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not TestValueType valueType)
            throw new ArgumentException(""Argument must be of type 'TestValueType'."", nameof(obj));

         return this.CompareTo(valueType);
      }

      /// <inheritdoc />
      public int CompareTo(TestValueType obj)
      {
         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_string_key_member()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueType? ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(TestValueType);

         return TestValueType.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueType obj)
      {
         return (string) obj;
      }
   }

   [Thinktecture.Internal.ValueTypeConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueType]
   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial class TestValueType : System.IEquatable<TestValueType?>, System.IComparable, System.IComparable<TestValueType>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<string, TestValueType>(TestValueType.Create);
         Expression<Func<string, TestValueType>> convertFromKeyExpression = referenceField => new TestValueType(referenceField);

         var convertToKey = new Func<TestValueType, string>(item => item.ReferenceField);
         Expression<Func<TestValueType, string>> convertToKeyExpression = obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueType, string>(TestValueType.TryCreate);

         var type = typeof(TestValueType);
         var metadata = new Thinktecture.Internal.ValueTypeMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(string referenceField)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(referenceField);
      }

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueType? obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(referenceField)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueType? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueType?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return TestValueType.Create(referenceField);
      }

      private TestValueType(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not TestValueType valueType)
            throw new ArgumentException(""Argument must be of type 'TestValueType'."", nameof(obj));

         return this.CompareTo(valueType);
      }

      /// <inheritdoc />
      public int CompareTo(TestValueType? obj)
      {
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_int_key_member()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly int StructField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, int>
   {
      /// <inheritdoc />
      protected override TestValueType ConvertFrom(int structField)
      {
         return TestValueType.Create(structField);
      }

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueType obj)
      {
         return (int) obj;
      }
   }

   [Thinktecture.Internal.ValueTypeConstructor(nameof(StructField))]
   [Thinktecture.Internal.KeyedValueType]
   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial class TestValueType : System.IEquatable<TestValueType?>, System.IFormattable, System.IComparable, System.IComparable<TestValueType>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<int, TestValueType>(TestValueType.Create);
         Expression<Func<int, TestValueType>> convertFromKeyExpression = structField => new TestValueType(structField);

         var convertToKey = new Func<TestValueType, int>(item => item.StructField);
         Expression<Func<TestValueType, int>> convertToKeyExpression = obj => obj.StructField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueType, int>(TestValueType.TryCreate);

         var type = typeof(TestValueType);
         var metadata = new Thinktecture.Internal.ValueTypeMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(int structField)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(structField);
      }

      public static ValidationResult? TryCreate(
         int structField,
         [MaybeNull] out TestValueType? obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(structField)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int structField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueType? obj)
      {
         return obj is null ? null : obj.StructField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueType obj)
      {
         if(obj is null)
            throw new NullReferenceException();

         return obj.StructField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""structField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      public static explicit operator TestValueType(int structField)
      {
         return TestValueType.Create(structField);
      }

      private TestValueType(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not TestValueType valueType)
            throw new ArgumentException(""Argument must be of type 'TestValueType'."", nameof(obj));

         return this.CompareTo(valueType);
      }

      /// <inheritdoc />
      public int CompareTo(TestValueType? obj)
      {
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_string_key_member_and_NullInFactoryMethodsYieldsNull()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueType? ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(TestValueType);

         return TestValueType.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueType obj)
      {
         return (string) obj;
      }
   }

   [Thinktecture.Internal.ValueTypeConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueType]
   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial class TestValueType : System.IEquatable<TestValueType?>, System.IComparable, System.IComparable<TestValueType>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<string, TestValueType>(TestValueType.Create);
         Expression<Func<string, TestValueType>> convertFromKeyExpression = referenceField => new TestValueType(referenceField);

         var convertToKey = new Func<TestValueType, string>(item => item.ReferenceField);
         Expression<Func<TestValueType, string>> convertToKeyExpression = obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueType, string>(TestValueType.TryCreate);

         var type = typeof(TestValueType);
         var metadata = new Thinktecture.Internal.ValueTypeMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      [return: NotNullIfNotNull(""referenceField"")]
      public static TestValueType? Create(string? referenceField)
      {
         if(referenceField is null)
            return default;

         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(referenceField);
      }

      public static ValidationResult? TryCreate(
         string? referenceField,
         [MaybeNull] out TestValueType? obj)
      {
         if(referenceField is null)
         {
            obj = default;
            return null;
         }

         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(referenceField)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueType? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueType?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return TestValueType.Create(referenceField);
      }

      private TestValueType(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not TestValueType valueType)
            throw new ArgumentException(""Argument must be of type 'TestValueType'."", nameof(obj));

         return this.CompareTo(valueType);
      }

      /// <inheritdoc />
      public int CompareTo(TestValueType? obj)
      {
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_int_key_member_and_NullInFactoryMethodsYieldsNull_should_be_ignored()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType(NullInFactoryMethodsYieldsNull = true)]
	public partial class TestValueType
	{
      public readonly int StructField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, int>
   {
      /// <inheritdoc />
      protected override TestValueType ConvertFrom(int structField)
      {
         return TestValueType.Create(structField);
      }

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueType obj)
      {
         return (int) obj;
      }
   }

   [Thinktecture.Internal.ValueTypeConstructor(nameof(StructField))]
   [Thinktecture.Internal.KeyedValueType]
   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial class TestValueType : System.IEquatable<TestValueType?>, System.IFormattable, System.IComparable, System.IComparable<TestValueType>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<int, TestValueType>(TestValueType.Create);
         Expression<Func<int, TestValueType>> convertFromKeyExpression = structField => new TestValueType(structField);

         var convertToKey = new Func<TestValueType, int>(item => item.StructField);
         Expression<Func<TestValueType, int>> convertToKeyExpression = obj => obj.StructField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueType, int>(TestValueType.TryCreate);

         var type = typeof(TestValueType);
         var metadata = new Thinktecture.Internal.ValueTypeMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(int structField)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(structField);
      }

      public static ValidationResult? TryCreate(
         int structField,
         [MaybeNull] out TestValueType? obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref structField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(structField)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int structField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueType? obj)
      {
         return obj is null ? null : obj.StructField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""StructField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueType obj)
      {
         if(obj is null)
            throw new NullReferenceException();

         return obj.StructField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""structField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      public static explicit operator TestValueType(int structField)
      {
         return TestValueType.Create(structField);
      }

      private TestValueType(int structField)
      {
         ValidateConstructorArguments(ref structField);

         this.StructField = structField;
      }

      static partial void ValidateConstructorArguments(ref int structField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return HashCode.Combine(this.StructField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.StructField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {
         return this.StructField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not TestValueType valueType)
            throw new ArgumentException(""Argument must be of type 'TestValueType'."", nameof(obj));

         return this.CompareTo(valueType);
      }

      /// <inheritdoc />
      public int CompareTo(TestValueType? obj)
      {
         if(obj is null)
            return 1;

         return this.StructField.CompareTo(obj.StructField);
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_keyed_value_type_if_second_member_is_ignored()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;

      [ValueTypeIgnore]
      public readonly string OtherField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueType? ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(TestValueType);

         return TestValueType.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueType obj)
      {
         return (string) obj;
      }
   }

   [Thinktecture.Internal.ValueTypeConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueType]
   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial class TestValueType : System.IEquatable<TestValueType?>, System.IComparable, System.IComparable<TestValueType>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<string, TestValueType>(TestValueType.Create);
         Expression<Func<string, TestValueType>> convertFromKeyExpression = referenceField => new TestValueType(referenceField);

         var convertToKey = new Func<TestValueType, string>(item => item.ReferenceField);
         Expression<Func<TestValueType, string>> convertToKeyExpression = obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueType, string>(TestValueType.TryCreate);

         var type = typeof(TestValueType);
         var metadata = new Thinktecture.Internal.ValueTypeMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(string referenceField)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(referenceField);
      }

      public static ValidationResult? TryCreate(
         string referenceField,
         [MaybeNull] out TestValueType? obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(referenceField)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueType? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      [return: NotNullIfNotNull(""referenceField"")]
      public static explicit operator TestValueType?(string? referenceField)
      {
         if(referenceField is null)
            return null;

         return TestValueType.Create(referenceField);
      }

      private TestValueType(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not TestValueType valueType)
            throw new ArgumentException(""Argument must be of type 'TestValueType'."", nameof(obj));

         return this.CompareTo(valueType);
      }

      /// <inheritdoc />
      public int CompareTo(TestValueType? obj)
      {
         if(obj is null)
            return 1;

         if(this.ReferenceField is null)
            return obj.ReferenceField is null ? 0 : -1;

         return this.ReferenceField.CompareTo(obj.ReferenceField);
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_int_key_member_having_EqualityMemberAttribute()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      [ValueTypeEqualityMember(EqualityComparer = ""EqualityComparer<int>.Default"", Comparer = ""Comparer<int>.Default"")]
      public readonly int ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, int>
   {
      /// <inheritdoc />
      protected override TestValueType ConvertFrom(int referenceField)
      {
         return TestValueType.Create(referenceField);
      }

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueType obj)
      {
         return (int) obj;
      }
   }

   [Thinktecture.Internal.ValueTypeConstructor(nameof(ReferenceField))]
   [Thinktecture.Internal.KeyedValueType]
   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial class TestValueType : System.IEquatable<TestValueType?>, System.IFormattable, System.IComparable, System.IComparable<TestValueType>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<int, TestValueType>(TestValueType.Create);
         Expression<Func<int, TestValueType>> convertFromKeyExpression = referenceField => new TestValueType(referenceField);

         var convertToKey = new Func<TestValueType, int>(item => item.ReferenceField);
         Expression<Func<TestValueType, int>> convertToKeyExpression = obj => obj.ReferenceField;

         var tryCreate = new Thinktecture.Internal.Validate<TestValueType, int>(TestValueType.TryCreate);

         var type = typeof(TestValueType);
         var metadata = new Thinktecture.Internal.ValueTypeMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression, tryCreate);

         Thinktecture.Internal.ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(int referenceField)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(referenceField);
      }

      public static ValidationResult? TryCreate(
         int referenceField,
         [MaybeNull] out TestValueType? obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(referenceField)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref int referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int?(TestValueType? obj)
      {
         return obj is null ? null : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static explicit operator int(TestValueType obj)
      {
         if(obj is null)
            throw new NullReferenceException();

         return obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      public static explicit operator TestValueType(int referenceField)
      {
         return TestValueType.Create(referenceField);
      }

      private TestValueType(int referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref int referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return EqualityComparer<int>.Default.Equals(this.ReferenceField, other.ReferenceField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField, EqualityComparer<int>.Default);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField.ToString();
      }

      /// <inheritdoc />
      public string ToString(string? format, IFormatProvider? formatProvider = null)
      {
         return this.ReferenceField.ToString(format, formatProvider);
      }

      /// <inheritdoc />
      public int CompareTo(object? obj)
      {
         if(obj is null)
            return 1;

         if(obj is not TestValueType valueType)
            throw new ArgumentException(""Argument must be of type 'TestValueType'."", nameof(obj));

         return this.CompareTo(valueType);
      }

      /// <inheritdoc />
      public int CompareTo(TestValueType? obj)
      {
         if(obj is null)
            return 1;

         return Comparer<int>.Default.Compare(this.ReferenceField, obj.ReferenceField);
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_8_members()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      [ValueTypeEqualityMember(EqualityComparer = nameof(StringComparer.OrdinalIgnoreCase))]
      public readonly string ReferenceField;

      [ValueTypeEqualityMember]
      public readonly int StructField;

      public string ReferenceProperty { get; }
      public int StructProperty { get; }

      public int ExpressionBodyProperty => 42;

      public int GetterExpressionProperty
      {
         get => 42;
      }

      public int GetterBodyProperty
      {
         get { return 42; }
      }

      public int SetterProperty
      {
         set { }
      }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Thinktecture.Internal.ValueTypeConstructor(nameof(ReferenceField), nameof(StructField), nameof(ReferenceProperty), nameof(StructProperty))]
   partial class TestValueType : System.IEquatable<TestValueType?>
   {
      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(string referenceField, int structField, string referenceProperty, int structProperty)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(referenceField, structField, referenceProperty, structProperty);
      }

      public static ValidationResult? TryCreate(
         string referenceField,
         int structField,
         string referenceProperty,
         int structProperty,
         [MaybeNull] out TestValueType? obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(referenceField, structField, referenceProperty, structProperty)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      private TestValueType(string referenceField, int structField, string referenceProperty, int structProperty)
      {
         ValidateConstructorArguments(ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         this.ReferenceField = referenceField;
         this.StructField = structField;
         this.ReferenceProperty = referenceProperty;
         this.StructProperty = structProperty;
      }

      static partial void ValidateConstructorArguments(ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return StringComparer.OrdinalIgnoreCase.Equals(this.ReferenceField, other.ReferenceField)
             && this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField, StringComparer.OrdinalIgnoreCase);
         hashCode.Add(this.StructField);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return $""{{ ReferenceField = {this.ReferenceField}, StructField = {this.StructField} }}"";
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_9_members()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField1;
      public readonly string ReferenceField2;
      public readonly string ReferenceField3;
      public readonly string ReferenceField4;
      public readonly string ReferenceField5;
      public readonly string ReferenceField6;
      public readonly string ReferenceField7;
      public readonly string ReferenceField8;
      public readonly string ReferenceField9;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using System.ComponentModel.DataAnnotations;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Thinktecture.Internal.ValueTypeConstructor(nameof(ReferenceField1), nameof(ReferenceField2), nameof(ReferenceField3), nameof(ReferenceField4), nameof(ReferenceField5), nameof(ReferenceField6), nameof(ReferenceField7), nameof(ReferenceField8), nameof(ReferenceField9))]
   partial class TestValueType : System.IEquatable<TestValueType?>
   {
      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         if(validationResult != ValidationResult.Success)
            throw new ValidationException(validationResult!.ErrorMessage ?? ""Validation failed."");

         return new TestValueType(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9);
      }

      public static ValidationResult? TryCreate(
         string referenceField1,
         string referenceField2,
         string referenceField3,
         string referenceField4,
         string referenceField5,
         string referenceField6,
         string referenceField7,
         string referenceField8,
         string referenceField9,
         [MaybeNull] out TestValueType? obj)
      {
         var validationResult = ValidationResult.Success;
         ValidateFactoryArguments(ref validationResult, ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         obj = validationResult == ValidationResult.Success
               ? new TestValueType(referenceField1, referenceField2, referenceField3, referenceField4, referenceField5, referenceField6, referenceField7, referenceField8, referenceField9)
               : default;

         return validationResult;
      }

      static partial void ValidateFactoryArguments(ref ValidationResult? validationResult, ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      private TestValueType(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {
         ValidateConstructorArguments(ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         this.ReferenceField1 = referenceField1;
         this.ReferenceField2 = referenceField2;
         this.ReferenceField3 = referenceField3;
         this.ReferenceField4 = referenceField4;
         this.ReferenceField5 = referenceField5;
         this.ReferenceField6 = referenceField6;
         this.ReferenceField7 = referenceField7;
         this.ReferenceField8 = referenceField8;
         this.ReferenceField9 = referenceField9;
      }

      static partial void ValidateConstructorArguments(ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField1 is null ? other.ReferenceField1 is null : this.ReferenceField1.Equals(other.ReferenceField1))
             && (this.ReferenceField2 is null ? other.ReferenceField2 is null : this.ReferenceField2.Equals(other.ReferenceField2))
             && (this.ReferenceField3 is null ? other.ReferenceField3 is null : this.ReferenceField3.Equals(other.ReferenceField3))
             && (this.ReferenceField4 is null ? other.ReferenceField4 is null : this.ReferenceField4.Equals(other.ReferenceField4))
             && (this.ReferenceField5 is null ? other.ReferenceField5 is null : this.ReferenceField5.Equals(other.ReferenceField5))
             && (this.ReferenceField6 is null ? other.ReferenceField6 is null : this.ReferenceField6.Equals(other.ReferenceField6))
             && (this.ReferenceField7 is null ? other.ReferenceField7 is null : this.ReferenceField7.Equals(other.ReferenceField7))
             && (this.ReferenceField8 is null ? other.ReferenceField8 is null : this.ReferenceField8.Equals(other.ReferenceField8))
             && (this.ReferenceField9 is null ? other.ReferenceField9 is null : this.ReferenceField9.Equals(other.ReferenceField9));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField1);
         hashCode.Add(this.ReferenceField2);
         hashCode.Add(this.ReferenceField3);
         hashCode.Add(this.ReferenceField4);
         hashCode.Add(this.ReferenceField5);
         hashCode.Add(this.ReferenceField6);
         hashCode.Add(this.ReferenceField7);
         hashCode.Add(this.ReferenceField8);
         hashCode.Add(this.ReferenceField9);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return $""{{ ReferenceField1 = {this.ReferenceField1}, ReferenceField2 = {this.ReferenceField2}, ReferenceField3 = {this.ReferenceField3}, ReferenceField4 = {this.ReferenceField4}, ReferenceField5 = {this.ReferenceField5}, ReferenceField6 = {this.ReferenceField6}, ReferenceField7 = {this.ReferenceField7}, ReferenceField8 = {this.ReferenceField8}, ReferenceField9 = {this.ReferenceField9} }}"";
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_JsonConverter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueTypeJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Thinktecture;

namespace Thinktecture.Tests
{
   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueTypeJsonConverterFactory))]
   partial class TestValueType
   {
      public class ValueTypeJsonConverterFactory : JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(Type typeToConvert)
         {
            return typeof(TestValueType).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new ArgumentNullException(nameof(options));

            return new Thinktecture.Text.Json.Serialization.ValueTypeJsonConverter<TestValueType, string>(TestValueType.Create, obj => obj.ReferenceField, options);
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_JsonConverter_and_Attribute_for_struct_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueTypeJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Thinktecture;

namespace Thinktecture.Tests
{
   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueTypeJsonConverterFactory))]
   partial struct TestValueType
   {
      public class ValueTypeJsonConverterFactory : JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(Type typeToConvert)
         {
            return typeof(TestValueType).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new ArgumentNullException(nameof(options));

            return new Thinktecture.Text.Json.Serialization.ValueTypeJsonConverter<TestValueType, string>(TestValueType.Create, obj => obj.ReferenceField, options);
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_JsonConverter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueTypeJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Thinktecture.Text.Json.Serialization;

namespace Thinktecture.Tests
{
   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueTypeJsonConverterFactory))]
   partial class TestValueType
   {
      public class ValueTypeJsonConverter : JsonConverter<TestValueType>
      {
         private readonly string _referenceFieldPropertyName;
         private readonly string _structPropertyPropertyName;
         private readonly JsonConverter<decimal?> _nullableStructPropertyConverter;
         private readonly string _nullableStructPropertyPropertyName;

         public ValueTypeJsonConverter(JsonSerializerOptions options)
         {
            if(options is null)
               throw new ArgumentNullException(nameof(options));

            var namingPolicy = options.PropertyNamingPolicy;

            this._referenceFieldPropertyName = namingPolicy?.ConvertName(""ReferenceField"") ?? ""ReferenceField"";
            this._structPropertyPropertyName = namingPolicy?.ConvertName(""StructProperty"") ?? ""StructProperty"";
            this._nullableStructPropertyConverter = (JsonConverter<decimal?>)options.GetConverter(typeof(decimal?));
            this._nullableStructPropertyPropertyName = namingPolicy?.ConvertName(""NullableStructProperty"") ?? ""NullableStructProperty"";
         }

         /// <inheritdoc />
         public override TestValueType? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
         {
            if (reader.TokenType == JsonTokenType.Null)
               return default;

            if (reader.TokenType != JsonTokenType.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueType'. Expected token: '{JsonTokenType.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = options.PropertyNameCaseInsensitive ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal;

            while (reader.Read())
            {
               if (reader.TokenType == JsonTokenType.EndObject)
                  break;

               if (reader.TokenType != JsonTokenType.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueType'. Expected token: '{JsonTokenType.PropertyName}'."");

               var propName = reader.GetString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueType'."");

               if (comparer.Equals(propName, this._referenceFieldPropertyName))
               {
                  referenceField = reader.GetString();
               }
               else if (comparer.Equals(propName, this._structPropertyPropertyName))
               {
                  structProperty = reader.GetInt32();
               }
               else if (comparer.Equals(propName, this._nullableStructPropertyPropertyName))
               {
                  nullableStructProperty = this._nullableStructPropertyConverter.Read(ref reader, typeof(decimal?), options);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueType'."");
               }
            }

            var validationResult = TestValueType.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueType'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void Write(Utf8JsonWriter writer, TestValueType value, JsonSerializerOptions options)
         {
            writer.WriteStartObject();

            var ignoreNullValues = options.IgnoreNullValues;

            var referenceFieldPropertyValue = value.ReferenceField;

            if(!ignoreNullValues || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName(this._referenceFieldPropertyName);
               writer.WriteStringValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName(this._structPropertyPropertyName);
            writer.WriteNumberValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(!ignoreNullValues || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName(this._nullableStructPropertyPropertyName);
               this._nullableStructPropertyConverter.Write(writer, nullableStructPropertyPropertyValue, options);
            }
            writer.WriteEndObject();
         }
      }

      public class ValueTypeJsonConverterFactory : JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(Type typeToConvert)
         {
            return typeof(TestValueType).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new ArgumentNullException(nameof(options));

            return new ValueTypeJsonConverter(options);
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_JsonConverter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueTypeJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using System.Text.Json;
using System.Text.Json.Serialization;
using Thinktecture.Text.Json.Serialization;

namespace Thinktecture.Tests
{
   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(ValueTypeJsonConverterFactory))]
   partial struct TestValueType
   {
      public class ValueTypeJsonConverter : JsonConverter<TestValueType>
      {
         private readonly string _referenceFieldPropertyName;
         private readonly string _structPropertyPropertyName;
         private readonly JsonConverter<decimal?> _nullableStructPropertyConverter;
         private readonly string _nullableStructPropertyPropertyName;

         public ValueTypeJsonConverter(JsonSerializerOptions options)
         {
            if(options is null)
               throw new ArgumentNullException(nameof(options));

            var namingPolicy = options.PropertyNamingPolicy;

            this._referenceFieldPropertyName = namingPolicy?.ConvertName(""ReferenceField"") ?? ""ReferenceField"";
            this._structPropertyPropertyName = namingPolicy?.ConvertName(""StructProperty"") ?? ""StructProperty"";
            this._nullableStructPropertyConverter = (JsonConverter<decimal?>)options.GetConverter(typeof(decimal?));
            this._nullableStructPropertyPropertyName = namingPolicy?.ConvertName(""NullableStructProperty"") ?? ""NullableStructProperty"";
         }

         /// <inheritdoc />
         public override TestValueType Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
         {
            if (reader.TokenType == JsonTokenType.Null)
               return default;

            if (reader.TokenType != JsonTokenType.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueType'. Expected token: '{JsonTokenType.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = options.PropertyNameCaseInsensitive ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal;

            while (reader.Read())
            {
               if (reader.TokenType == JsonTokenType.EndObject)
                  break;

               if (reader.TokenType != JsonTokenType.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueType'. Expected token: '{JsonTokenType.PropertyName}'."");

               var propName = reader.GetString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueType'."");

               if (comparer.Equals(propName, this._referenceFieldPropertyName))
               {
                  referenceField = reader.GetString();
               }
               else if (comparer.Equals(propName, this._structPropertyPropertyName))
               {
                  structProperty = reader.GetInt32();
               }
               else if (comparer.Equals(propName, this._nullableStructPropertyPropertyName))
               {
                  nullableStructProperty = this._nullableStructPropertyConverter.Read(ref reader, typeof(decimal?), options);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueType'."");
               }
            }

            var validationResult = TestValueType.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueType'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void Write(Utf8JsonWriter writer, TestValueType value, JsonSerializerOptions options)
         {
            writer.WriteStartObject();

            var ignoreNullValues = options.IgnoreNullValues;

            var referenceFieldPropertyValue = value.ReferenceField;

            if(!ignoreNullValues || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName(this._referenceFieldPropertyName);
               writer.WriteStringValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName(this._structPropertyPropertyName);
            writer.WriteNumberValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(!ignoreNullValues || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName(this._nullableStructPropertyPropertyName);
               this._nullableStructPropertyConverter.Write(writer, nullableStructPropertyPropertyValue, options);
            }
            writer.WriteEndObject();
         }
      }

      public class ValueTypeJsonConverterFactory : JsonConverterFactory
      {
         /// <inheritdoc />
         public override bool CanConvert(Type typeToConvert)
         {
            return typeof(TestValueType).IsAssignableFrom(typeToConvert);
         }

         /// <inheritdoc />
         public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
         {
            if (typeToConvert is null)
               throw new ArgumentNullException(nameof(typeToConvert));
            if (options is null)
               throw new ArgumentNullException(nameof(options));

            return new ValueTypeJsonConverter(options);
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_NewtonsoftJsonConverter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Json.ValueTypeNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueTypeNewtonsoftJsonConverter))]
   partial class TestValueType
   {
      public class ValueTypeNewtonsoftJsonConverter : Thinktecture.Json.ValueTypeNewtonsoftJsonConverter<TestValueType, string>
      {
         public ValueTypeNewtonsoftJsonConverter()
            : base(TestValueType.Create, obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_struct_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Json.ValueTypeNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueTypeNewtonsoftJsonConverter))]
   partial struct TestValueType
   {
      public class ValueTypeNewtonsoftJsonConverter : Thinktecture.Json.ValueTypeNewtonsoftJsonConverter<TestValueType, string>
      {
         public ValueTypeNewtonsoftJsonConverter()
            : base(TestValueType.Create, obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Json.ValueTypeNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueTypeNewtonsoftJsonConverter))]
   partial class TestValueType
   {
      public class ValueTypeNewtonsoftJsonConverter : JsonConverter<TestValueType?>
      {
         /// <inheritdoc />
         public override TestValueType? ReadJson(JsonReader reader, Type objectType, TestValueType? existingValue, bool hasExistingValue, JsonSerializer serializer)
         {
            if (reader is null)
               throw new ArgumentNullException(nameof(reader));
            if (serializer is null)
               throw new ArgumentNullException(nameof(serializer));

            if (reader.TokenType == JsonToken.Null)
               return default;

            if (reader.TokenType != JsonToken.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueType'. Expected token: '{JsonToken.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = StringComparer.OrdinalIgnoreCase;

            while (reader.Read())
            {
               if (reader.TokenType == JsonToken.EndObject)
                  break;

               if (reader.TokenType != JsonToken.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueType'. Expected token: '{JsonToken.PropertyName}'."");

               var propName = reader.Value!.ToString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueType'."");

               if (comparer.Equals(propName, ""referenceField""))
               {
                  referenceField = serializer.Deserialize<string>(reader);
               }
               else if (comparer.Equals(propName, ""structProperty""))
               {
                  structProperty = serializer.Deserialize<int>(reader);
               }
               else if (comparer.Equals(propName, ""nullableStructProperty""))
               {
                  nullableStructProperty = serializer.Deserialize<decimal?>(reader);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueType'."");
               }
            }

            var validationResult = TestValueType.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueType'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void WriteJson(JsonWriter writer, TestValueType? value, JsonSerializer serializer)
         {
            if (value == null)
            {
               writer.WriteNull();
               return;
            }

            var resolver = serializer.ContractResolver as DefaultContractResolver;

            writer.WriteStartObject();
            var referenceFieldPropertyValue = value.ReferenceField;

            if(serializer.NullValueHandling != NullValueHandling.Ignore || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""ReferenceField"") : ""ReferenceField"");
               writer.WriteValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""StructProperty"") : ""StructProperty"");
            writer.WriteValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(serializer.NullValueHandling != NullValueHandling.Ignore || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""NullableStructProperty"") : ""NullableStructProperty"");
               serializer.Serialize(writer, nullableStructPropertyPropertyValue);
            }
            writer.WriteEndObject();
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_NewtonsoftJsonConverter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Json.ValueTypeNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Serialization;
using Thinktecture;

namespace Thinktecture.Tests
{
   [Newtonsoft.Json.JsonConverterAttribute(typeof(ValueTypeNewtonsoftJsonConverter))]
   partial struct TestValueType
   {
      public class ValueTypeNewtonsoftJsonConverter : JsonConverter<TestValueType>
      {
         /// <inheritdoc />
         public override TestValueType ReadJson(JsonReader reader, Type objectType, TestValueType existingValue, bool hasExistingValue, JsonSerializer serializer)
         {
            if (reader is null)
               throw new ArgumentNullException(nameof(reader));
            if (serializer is null)
               throw new ArgumentNullException(nameof(serializer));

            if (reader.TokenType == JsonToken.Null)
               return default;

            if (reader.TokenType != JsonToken.StartObject)
               throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueType'. Expected token: '{JsonToken.StartObject}'."");

            string? referenceField = default;
            int structProperty = default;
            decimal? nullableStructProperty = default;

            var comparer = StringComparer.OrdinalIgnoreCase;

            while (reader.Read())
            {
               if (reader.TokenType == JsonToken.EndObject)
                  break;

               if (reader.TokenType != JsonToken.PropertyName)
                  throw new JsonException($""Unexpected token '{reader.TokenType}' when trying to deserialize 'TestValueType'. Expected token: '{JsonToken.PropertyName}'."");

               var propName = reader.Value!.ToString();

               if(!reader.Read())
                  throw new JsonException($""Unexpected end of the JSON message when trying the read the value of '{propName}' during deserialization of 'TestValueType'."");

               if (comparer.Equals(propName, ""referenceField""))
               {
                  referenceField = serializer.Deserialize<string>(reader);
               }
               else if (comparer.Equals(propName, ""structProperty""))
               {
                  structProperty = serializer.Deserialize<int>(reader);
               }
               else if (comparer.Equals(propName, ""nullableStructProperty""))
               {
                  nullableStructProperty = serializer.Deserialize<decimal?>(reader);
               }
               else
               {
                  throw new JsonException($""Unknown member '{propName}' encountered when trying to deserialize 'TestValueType'."");
               }
            }

            var validationResult = TestValueType.TryCreate(
                                       referenceField!,
                                       structProperty!,
                                       nullableStructProperty!,
                                       out var obj);

            if (validationResult != ValidationResult.Success)
               throw new JsonException($""Unable to deserialize 'TestValueType'. Error: {validationResult!.ErrorMessage}."");

            return obj;
         }

         /// <inheritdoc />
         public override void WriteJson(JsonWriter writer, TestValueType value, JsonSerializer serializer)
         {
            var resolver = serializer.ContractResolver as DefaultContractResolver;

            writer.WriteStartObject();
            var referenceFieldPropertyValue = value.ReferenceField;

            if(serializer.NullValueHandling != NullValueHandling.Ignore || referenceFieldPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""ReferenceField"") : ""ReferenceField"");
               writer.WriteValue(referenceFieldPropertyValue);
            }
            var structPropertyPropertyValue = value.StructProperty;

            writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""StructProperty"") : ""StructProperty"");
            writer.WriteValue(structPropertyPropertyValue);
            var nullableStructPropertyPropertyValue = value.NullableStructProperty;

            if(serializer.NullValueHandling != NullValueHandling.Ignore || nullableStructPropertyPropertyValue is not null)
            {
               writer.WritePropertyName((resolver != null) ? resolver.GetResolvedPropertyName(""NullableStructProperty"") : ""NullableStructProperty"");
               serializer.Serialize(writer, nullableStructPropertyPropertyValue);
            }
            writer.WriteEndObject();
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_MessagePackFormatter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(ValueTypeMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueTypeMessagePackFormatter))]
   partial class TestValueType
   {
      public class ValueTypeMessagePackFormatter : Thinktecture.Formatters.ValueTypeMessagePackFormatter<TestValueType, string>
      {
         public ValueTypeMessagePackFormatter()
            : base(TestValueType.Create, obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_MessagePackFormatter_and_Attribute_for_struct_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(ValueTypeMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueTypeMessagePackFormatter))]
   partial struct TestValueType
   {
      public class ValueTypeMessagePackFormatter : Thinktecture.Formatters.ValueTypeMessagePackFormatter<TestValueType, string>
      {
         public ValueTypeMessagePackFormatter()
            : base(TestValueType.Create, obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_MessagePackFormatter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(ValueTypeMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using MessagePack;
using MessagePack.Formatters;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueTypeMessagePackFormatter))]
   partial class TestValueType
   {
      public class ValueTypeMessagePackFormatter : IMessagePackFormatter<TestValueType?>
      {
         /// <inheritdoc />
         public TestValueType? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
         {
            if (reader.TryReadNil())
               return default;

            var count = reader.ReadArrayHeader();

            if (count != 3)
               throw new MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

            IFormatterResolver resolver = options.Resolver;
            options.Security.DepthStep(ref reader);

            try
            {

               var referenceField = reader.ReadString()!;
               var structProperty = reader.ReadInt32()!;
               var nullableStructProperty = resolver.GetFormatterWithVerify<decimal?>().Deserialize(ref reader, options)!;

               var validationResult = TestValueType.TryCreate(
                                          referenceField,
                                          structProperty,
                                          nullableStructProperty,
                                          out var obj);

               if (validationResult != ValidationResult.Success)
                  throw new MessagePackSerializationException($""Unable to deserialize 'TestValueType'. Error: {validationResult!.ErrorMessage}."");

               return obj;
            }
            finally
            {
              reader.Depth--;
            }
         }

         /// <inheritdoc />
         public void Serialize(ref MessagePackWriter writer, TestValueType? value, MessagePackSerializerOptions options)
         {
            if(value is null)
            {
               writer.WriteNil();
               return;
            }

            writer.WriteArrayHeader(3);

            var resolver = options.Resolver;
            writer.Write(value.ReferenceField);
            writer.Write(value.StructProperty);
            resolver.GetFormatterWithVerify<decimal?>().Serialize(ref writer, value.NullableStructProperty, options);
         }
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_MessagePackFormatter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(ValueTypeMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using MessagePack;
using MessagePack.Formatters;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueTypeMessagePackFormatter))]
   partial struct TestValueType
   {
      public class ValueTypeMessagePackFormatter : IMessagePackFormatter<TestValueType>
      {
         /// <inheritdoc />
         public TestValueType Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)
         {
            if (reader.TryReadNil())
               return default;

            var count = reader.ReadArrayHeader();

            if (count != 3)
               throw new MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

            IFormatterResolver resolver = options.Resolver;
            options.Security.DepthStep(ref reader);

            try
            {

               var referenceField = reader.ReadString()!;
               var structProperty = reader.ReadInt32()!;
               var nullableStructProperty = resolver.GetFormatterWithVerify<decimal?>().Deserialize(ref reader, options)!;

               var validationResult = TestValueType.TryCreate(
                                          referenceField,
                                          structProperty,
                                          nullableStructProperty,
                                          out var obj);

               if (validationResult != ValidationResult.Success)
                  throw new MessagePackSerializationException($""Unable to deserialize 'TestValueType'. Error: {validationResult!.ErrorMessage}."");

               return obj;
            }
            finally
            {
              reader.Depth--;
            }
         }

         /// <inheritdoc />
         public void Serialize(ref MessagePackWriter writer, TestValueType value, MessagePackSerializerOptions options)
         {
            writer.WriteArrayHeader(3);

            var resolver = options.Resolver;
            writer.Write(value.ReferenceField);
            writer.Write(value.StructProperty);
            resolver.GetFormatterWithVerify<decimal?>().Serialize(ref writer, value.NullableStructProperty, options);
         }
      }
   }
}
");
      }
   }
}
