using FluentAssertions;
using MessagePack;
using Thinktecture.CodeAnalysis;
using Thinktecture.Formatters;
using Xunit;
using Xunit.Abstractions;

namespace Thinktecture.SourceGeneratorTests
{
   public class ValueTypeSourceGeneratorTests : SourceGeneratorTestsBase
   {
      public ValueTypeSourceGeneratorTests(ITestOutputHelper output)
         : base(output)
      {
      }

      private const string _SIMPLE_VALUE_TYPE_OUTPUT = @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.Tests
{
   partial class TestValueType : IEquatable<TestValueType?>
   {
      private static readonly Type _type = typeof(TestValueType);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueType"";
      }
   }
}
";

      [Fact]
      public void Should_generate_simple_class_with_ValueTypeAttribute()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(_SIMPLE_VALUE_TYPE_OUTPUT);
      }

      [Fact]
      public void Should_generate_simple_class_with_ValueTypeAttribute_using_long_form()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueTypeAttribute]
	public partial class TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(_SIMPLE_VALUE_TYPE_OUTPUT);
      }

      [Fact]
      public void Should_generate_simple_class_with_fully_qualified_ValueTypeAttribute()
      {
         var source = @"
using System;

namespace Thinktecture.Tests
{
   [Thinktecture.ValueType]
	public partial class TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(_SIMPLE_VALUE_TYPE_OUTPUT);
      }

      [Fact]
      public void Should_generate_simple_struct_with_ValueTypeAttribute()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public readonly partial struct TestValueType
	{
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.Tests
{
   partial struct TestValueType : IEquatable<TestValueType>
   {
      private static readonly Type _type = typeof(TestValueType);

      public static readonly TestValueType Empty = default;

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType obj, TestValueType other)
      {
         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType obj, TestValueType other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType other)
      {
         return true;
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _type.GetHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return ""TestValueType"";
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_key_member()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, string>
   {
      /// <inheritdoc />
      [return: NotNullIfNotNull(""referenceField"")]
      protected override TestValueType? ConvertFrom(string? referenceField)
      {
         if(referenceField is null)
            return default(TestValueType);

         return TestValueType.Create(referenceField);
      }

      /// <inheritdoc />
      protected override string GetKeyValue(TestValueType obj)
      {
         return (string) obj;
      }
   }

   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial class TestValueType : IEquatable<TestValueType?>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<string, TestValueType>(TestValueType.Create);
         Expression<Func<string, TestValueType>> convertFromKeyExpression = referenceField => TestValueType.Create(referenceField);

         var convertToKey = new Func<TestValueType, string>(item => item.ReferenceField);
         Expression<Func<TestValueType, string>> convertToKeyExpression = obj => obj.ReferenceField;

         var type = typeof(TestValueType);
         var metadata = new ValueTypeMetadata(type, typeof(string), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression);

         ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(string referenceField)
      {
         ValidateFactoryArguments(ref referenceField);

         return new TestValueType(referenceField);
      }

      public static bool TryCreate(
         string referenceField,
         [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TestValueType? obj)
      {
         try
         {
            ValidateFactoryArguments(ref referenceField);
         }
         catch(Exception)
         {
            obj = default;
            return false;
         }

         obj = new TestValueType(referenceField);
         return true;
      }

      static partial void ValidateFactoryArguments(ref string referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator string?(TestValueType? obj)
      {
         return obj is null ? default : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""string""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      public static explicit operator TestValueType(string referenceField)
      {
         return TestValueType.Create(referenceField);
      }

      private TestValueType(string referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref string referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField is null ? other.ReferenceField is null : this.ReferenceField.Equals(other.ReferenceField));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return HashCode.Combine(this.ReferenceField);
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField?.ToString();
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_key_member_having_EqualityMemberAttribute()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      [ValueTypeEqualityMember(Comparer = ""EqualityComparer<int>.Default"")]
      public readonly int ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeConverter : Thinktecture.ValueTypeConverter<TestValueType, int>
   {
      /// <inheritdoc />
      protected override TestValueType ConvertFrom(int referenceField)
      {
         return TestValueType.Create(referenceField);
      }

      /// <inheritdoc />
      protected override int GetKeyValue(TestValueType obj)
      {
         return (int) obj;
      }
   }

   [System.ComponentModel.TypeConverter(typeof(TestValueType_ValueTypeConverter))]
   partial class TestValueType : IEquatable<TestValueType?>
   {
      [System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new Func<int, TestValueType>(TestValueType.Create);
         Expression<Func<int, TestValueType>> convertFromKeyExpression = referenceField => TestValueType.Create(referenceField);

         var convertToKey = new Func<TestValueType, int>(item => item.ReferenceField);
         Expression<Func<TestValueType, int>> convertToKeyExpression = obj => obj.ReferenceField;

         var type = typeof(TestValueType);
         var metadata = new ValueTypeMetadata(type, typeof(int), false, convertFromKey, convertFromKeyExpression, convertToKey, convertToKeyExpression);

         ValueTypeMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly Type _type = typeof(TestValueType);

      public static TestValueType Create(int referenceField)
      {
         ValidateFactoryArguments(ref referenceField);

         return new TestValueType(referenceField);
      }

      public static bool TryCreate(
         int referenceField,
         [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TestValueType? obj)
      {
         try
         {
            ValidateFactoryArguments(ref referenceField);
         }
         catch(Exception)
         {
            obj = default;
            return false;
         }

         obj = new TestValueType(referenceField);
         return true;
      }

      static partial void ValidateFactoryArguments(ref int referenceField);

      /// <summary>
      /// Implicit conversion to the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""obj"">Object to covert.</param>
      /// <returns>The <see cref=""ReferenceField""/> of provided <paramref name=""obj""/> or <c>default</c> if <paramref name=""obj""/> is <c>null</c>.</returns>
      [return: NotNullIfNotNull(""obj"")]
      public static implicit operator int(TestValueType? obj)
      {
         return obj is null ? default : obj.ReferenceField;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref=""int""/>.
      /// </summary>
      /// <param name=""referenceField"">Value to covert.</param>
      /// <returns>An instance of <see cref=""TestValueType""/>.</returns>
      public static explicit operator TestValueType(int referenceField)
      {
         return TestValueType.Create(referenceField);
      }

      private TestValueType(int referenceField)
      {
         ValidateConstructorArguments(ref referenceField);

         this.ReferenceField = referenceField;
      }

      static partial void ValidateConstructorArguments(ref int referenceField);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return EqualityComparer<int>.Default.Equals(this.ReferenceField, other.ReferenceField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField, EqualityComparer<int>.Default);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return this.ReferenceField.ToString();
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_8_members()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      [ValueTypeEqualityMember(Comparer = nameof(StringComparer.OrdinalIgnoreCase))]
      public readonly string ReferenceField;

      [ValueTypeEqualityMember]
      public readonly int StructField;

      public string ReferenceProperty { get; }
      public int StructProperty { get; }

      public int ExpressionBodyProperty => 42;

      public int GetterExpressionProperty
      {
         get => 42;
      }

      public int GetterBodyProperty
      {
         get { return 42; }
      }

      public int SetterProperty
      {
         set { }
      }
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.Tests
{
   partial class TestValueType : IEquatable<TestValueType?>
   {
      private static readonly Type _type = typeof(TestValueType);

      private TestValueType(string referenceField, int structField, string referenceProperty, int structProperty)
      {
         ValidateConstructorArguments(ref referenceField, ref structField, ref referenceProperty, ref structProperty);

         this.ReferenceField = referenceField;
         this.StructField = structField;
         this.ReferenceProperty = referenceProperty;
         this.StructProperty = structProperty;
      }

      static partial void ValidateConstructorArguments(ref string referenceField, ref int structField, ref string referenceProperty, ref int structProperty);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return StringComparer.OrdinalIgnoreCase.Equals(this.ReferenceField, other.ReferenceField)
             && this.StructField.Equals(other.StructField);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField, StringComparer.OrdinalIgnoreCase);
         hashCode.Add(this.StructField);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return $""{{ ReferenceField = {this.ReferenceField}, StructField = {this.StructField} }}"";
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_class_with_9_members()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField1;
      public readonly string ReferenceField2;
      public readonly string ReferenceField3;
      public readonly string ReferenceField4;
      public readonly string ReferenceField5;
      public readonly string ReferenceField6;
      public readonly string ReferenceField7;
      public readonly string ReferenceField8;
      public readonly string ReferenceField9;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureRuntimeExtensionsSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly);
         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Linq.Expressions;
using Thinktecture;

namespace Thinktecture.Tests
{
   partial class TestValueType : IEquatable<TestValueType?>
   {
      private static readonly Type _type = typeof(TestValueType);

      private TestValueType(string referenceField1, string referenceField2, string referenceField3, string referenceField4, string referenceField5, string referenceField6, string referenceField7, string referenceField8, string referenceField9)
      {
         ValidateConstructorArguments(ref referenceField1, ref referenceField2, ref referenceField3, ref referenceField4, ref referenceField5, ref referenceField6, ref referenceField7, ref referenceField8, ref referenceField9);

         this.ReferenceField1 = referenceField1;
         this.ReferenceField2 = referenceField2;
         this.ReferenceField3 = referenceField3;
         this.ReferenceField4 = referenceField4;
         this.ReferenceField5 = referenceField5;
         this.ReferenceField6 = referenceField6;
         this.ReferenceField7 = referenceField7;
         this.ReferenceField8 = referenceField8;
         this.ReferenceField9 = referenceField9;
      }

      static partial void ValidateConstructorArguments(ref string referenceField1, ref string referenceField2, ref string referenceField3, ref string referenceField4, ref string referenceField5, ref string referenceField6, ref string referenceField7, ref string referenceField8, ref string referenceField9);

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>true</c> if objects are equal; otherwise <c>false</c>.</returns>
      public static bool operator ==(TestValueType? obj, TestValueType? other)
      {
         if (obj is null)
            return other is null;

         return obj.Equals(other);
      }

      /// <summary>
      /// Compares to instances of <see cref=""TestValueType""/>.
      /// </summary>
      /// <param name=""obj"">Instance to compare.</param>
      /// <param name=""other"">Another instance to compare.</param>
      /// <returns><c>false</c> if objects are equal; otherwise <c>true</c>.</returns>
      public static bool operator !=(TestValueType? obj, TestValueType? other)
      {
         return !(obj == other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is TestValueType obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(TestValueType? other)
      {
         if (other is null)
            return false;

         if (!ReferenceEquals(GetType(), other.GetType()))
            return false;

         if (ReferenceEquals(this, other))
            return true;

         return (this.ReferenceField1 is null ? other.ReferenceField1 is null : this.ReferenceField1.Equals(other.ReferenceField1))
             && (this.ReferenceField2 is null ? other.ReferenceField2 is null : this.ReferenceField2.Equals(other.ReferenceField2))
             && (this.ReferenceField3 is null ? other.ReferenceField3 is null : this.ReferenceField3.Equals(other.ReferenceField3))
             && (this.ReferenceField4 is null ? other.ReferenceField4 is null : this.ReferenceField4.Equals(other.ReferenceField4))
             && (this.ReferenceField5 is null ? other.ReferenceField5 is null : this.ReferenceField5.Equals(other.ReferenceField5))
             && (this.ReferenceField6 is null ? other.ReferenceField6 is null : this.ReferenceField6.Equals(other.ReferenceField6))
             && (this.ReferenceField7 is null ? other.ReferenceField7 is null : this.ReferenceField7.Equals(other.ReferenceField7))
             && (this.ReferenceField8 is null ? other.ReferenceField8 is null : this.ReferenceField8.Equals(other.ReferenceField8))
             && (this.ReferenceField9 is null ? other.ReferenceField9 is null : this.ReferenceField9.Equals(other.ReferenceField9));
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         var hashCode = new HashCode();
         hashCode.Add(this.ReferenceField1);
         hashCode.Add(this.ReferenceField2);
         hashCode.Add(this.ReferenceField3);
         hashCode.Add(this.ReferenceField4);
         hashCode.Add(this.ReferenceField5);
         hashCode.Add(this.ReferenceField6);
         hashCode.Add(this.ReferenceField7);
         hashCode.Add(this.ReferenceField8);
         hashCode.Add(this.ReferenceField9);
         return hashCode.ToHashCode();
      }

      /// <inheritdoc />
      public override string? ToString()
      {
         return $""{{ ReferenceField1 = {this.ReferenceField1}, ReferenceField2 = {this.ReferenceField2}, ReferenceField3 = {this.ReferenceField3}, ReferenceField4 = {this.ReferenceField4}, ReferenceField5 = {this.ReferenceField5}, ReferenceField6 = {this.ReferenceField6}, ReferenceField7 = {this.ReferenceField7}, ReferenceField8 = {this.ReferenceField8}, ReferenceField9 = {this.ReferenceField9} }}"";
      }
   }
}
");
      }

      [Fact]
      public void Should_generate_JsonConverter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Thinktecture.Text.Json.Serialization.ValueTypeJsonConverter<,>).Assembly, typeof(System.Text.Json.JsonDocument).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using System.Text.Json.Serialization;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeJsonConverter : Thinktecture.Text.Json.Serialization.ValueTypeJsonConverter<TestValueType, string>
   {
      public TestValueType_ValueTypeJsonConverter()
         : this(null)
      {
      }

      public TestValueType_ValueTypeJsonConverter(
         JsonConverter<string>? keyConverter)
         : base(TestValueType.Create, obj => (string) obj, keyConverter)
      {
      }
   }

   [System.Text.Json.Serialization.JsonConverterAttribute(typeof(TestValueType_ValueTypeJsonConverter))]
   partial class TestValueType
   {
   }
}
");
      }

      [Fact]
      public void Should_generate_NewtonsoftJsonConverter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureNewtonsoftJsonConverterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(Json.ValueTypeNewtonsoftJsonConverter).Assembly, typeof(Newtonsoft.Json.JsonToken).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeNewtonsoftJsonConverter : Thinktecture.Json.ValueTypeNewtonsoftJsonConverter<TestValueType, string>
   {
      public TestValueType_ValueTypeNewtonsoftJsonConverter()
         : base(TestValueType.Create, obj => (string) obj)
      {
      }
   }

   [Newtonsoft.Json.JsonConverterAttribute(typeof(TestValueType_ValueTypeNewtonsoftJsonConverter))]
   partial class TestValueType
   {
   }
}
");
      }

      [Fact]
      public void Should_generate_MessagePackFormatter_and_Attribute_if_Attribute_is_missing()
      {
         var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueType]
	public partial class TestValueType
	{
      public readonly string ReferenceField;
   }
}
";
         var output = GetGeneratedOutput<ThinktectureMessagePackFormatterSourceGenerator>(source, typeof(ValueTypeAttribute).Assembly, typeof(ValueTypeMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

         output.Should().Be(@"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   public class TestValueType_ValueTypeMessagePackFormatter : Thinktecture.Formatters.ValueTypeMessagePackFormatter<TestValueType, string>
   {
      public TestValueType_ValueTypeMessagePackFormatter()
         : base(TestValueType.Create, obj => (string) obj)
      {
      }
   }

   [MessagePack.MessagePackFormatter(typeof(TestValueType_ValueTypeMessagePackFormatter))]
   partial class TestValueType
   {
   }
}
");
      }
   }
}
