// <auto-generated />
#nullable enable

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ThinktectureTypeConverter<global::Thinktecture.Tests.TestEnum, int, global::Thinktecture.ValidationError>))]
   [global::System.Diagnostics.CodeAnalysis.SuppressMessage("ThinktectureRuntimeExtensionsAnalyzer", "TTRESG1000:Internal Thinktecture.Runtime.Extensions API usage")]
   sealed partial class TestEnum :
      global::Thinktecture.Internal.IMetadataOwner,
      global::Thinktecture.ISmartEnum<int, global::Thinktecture.Tests.TestEnum, global::Thinktecture.ValidationError>,
      global::System.IEquatable<global::Thinktecture.Tests.TestEnum?>
   {
      static global::Thinktecture.Internal.Metadata global::Thinktecture.Internal.IMetadataOwner.Metadata { get; }
         = new global::Thinktecture.Internal.Metadata.Keyed.SmartEnum(typeof(global::Thinktecture.Tests.TestEnum))
         {
            KeyType = typeof(int),
            ValidationErrorType = typeof(global::Thinktecture.ValidationError),
            DisableSpanBasedJsonConversion = false,
            Items = new global::System.Lazy<global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Internal.SmartEnumItemMetadata>>(
                     () => new global::System.Collections.Generic.List<global::Thinktecture.Internal.SmartEnumItemMetadata>(
                        global::System.Linq.Enumerable.Select(global::Thinktecture.Tests.TestEnum.Items, (item, index) =>
                        {
                           string identifier = index switch
                           {
                              0 => "Item1", 
                              1 => "Item2", 
                              2 => "Item3", 
                              3 => "Item4", 
                              4 => "Item5", 
                              5 => "Item6", 
                              6 => "Item7", 
                              7 => "Item8", 
                              8 => "Item9", 
                              9 => "Item10", 
                              _ => throw new global::System.ArgumentOutOfRangeException($"Unknown item at index {index}.")
                           };

                           return new global::Thinktecture.Internal.SmartEnumItemMetadata
                           {
                              Key = item.Key,
                              Item = item,
                              Identifier = identifier
                           };
                        })).AsReadOnly()),
            ConvertToKey = static int (global::Thinktecture.Tests.TestEnum item) => item.Key,
            ConvertToKeyExpression = static int (global::Thinktecture.Tests.TestEnum item) => item.Key,
            GetKey = static object (object item) => ((global::Thinktecture.Tests.TestEnum)item).Key,
            ConvertFromKey = static global::Thinktecture.Tests.TestEnum (int key) => global::Thinktecture.Tests.TestEnum.Get(key),
            ConvertFromKeyExpression = static global::Thinktecture.Tests.TestEnum (int key) => global::Thinktecture.Tests.TestEnum.Get(key),
            TryGetFromKey =
               (object? key,
                out object? obj,
                [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(true)] out object error) =>
               {
                  error = global::Thinktecture.Tests.TestEnum.Validate(key is int typedKey ? typedKey : default, null, out var item)!;
                  obj = item;

                  return error is null;
               }
         };

      private static readonly global::System.Lazy<Lookups> _lookups = new global::System.Lazy<Lookups>(GetLookups, global::System.Threading.LazyThreadSafetyMode.ExecutionAndPublication);

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> Items => _lookups.Value.List;

      /// <summary>
      /// The identifier of this item.
      /// </summary>
      public int Key { get; }

      private readonly int _hashCode;
      private readonly global::Thinktecture.Internal.WriteOnceInt _itemIndex;

      private TestEnum(
         int @key)
      {
         ValidateConstructorArguments(
            ref @key);

         this.Key = @key;
         this._itemIndex = new global::Thinktecture.Internal.WriteOnceInt();
         this._hashCode = @key.GetHashCode();
      }

      static partial void ValidateConstructorArguments(
         ref int @key);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      int global::Thinktecture.IConvertible<int>.ToValue()
      {
         return this.Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name="key"/>.
      /// </summary>
      /// <param name="key">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref="TestEnum"/> if <paramref name="key"/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      /// <exception cref="Thinktecture.UnknownSmartEnumIdentifierException">If there is no item with the provided <paramref name="key"/>.</exception>
      public static global::Thinktecture.Tests.TestEnum Get(int @key)
      {
         if (!_lookups.Value.Lookup.TryGetValue(@key, out var item))
         {
            throw new global::Thinktecture.UnknownSmartEnumIdentifierException(typeof(global::Thinktecture.Tests.TestEnum), @key);
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name="key"/> if a valid item exists.
      /// </summary>
      /// <param name="key">The identifier to return an enumeration item for.</param>
      /// <param name="item">An instance of <see cref="TestEnum"/>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name="key"/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] int @key, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests.TestEnum item)
      {
         return _lookups.Value.Lookup.TryGetValue(@key, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name="key"/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name="key">The identifier to return an enumeration item for.</param>
      /// <param name="provider">An object that provides culture-specific formatting information.</param>
      /// <param name="item">An instance of <see cref="TestEnum"/>.</param>
      /// <returns><c>null</c> if a valid item with provided <paramref name="key"/> exists; <see cref="global::Thinktecture.ValidationError"/> with an error message otherwise.</returns>
      public static global::Thinktecture.ValidationError? Validate([global::System.Diagnostics.CodeAnalysis.AllowNull] int @key, global::System.IFormatProvider? @provider, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests.TestEnum item)
      {
         if(global::Thinktecture.Tests.TestEnum.TryGet(@key, out item))
         {
            return null;
         }
         else
         {
            return global::Thinktecture.Internal.ValidationErrorCreator.CreateValidationError<global::Thinktecture.ValidationError>($"There is no item of type 'TestEnum' with the identifier '{@key}'.");
         }
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="item">Item to convert.</param>
      /// <returns>The <see cref="TestEnum.Key"/> of provided <paramref name="item"/> or <c>default</c> if <paramref name="item"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("item")]
      public static implicit operator int(global::Thinktecture.Tests.TestEnum? item)
      {
         return item is null ? default : item.Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="int"/>.
      /// </summary>
      /// <param name="key">Value to convert.</param>
      /// <returns>An instance of <see cref="TestEnum"/> if the <paramref name="key"/> is a known item.</returns>
      public static explicit operator global::Thinktecture.Tests.TestEnum(int @key)
      {
         return global::Thinktecture.Tests.TestEnum.Get(@key);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests.TestEnum? other)
      {
         return global::System.Object.ReferenceEquals(this, other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests.TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _hashCode;
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this.Key.ToString();
      }

      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      private int GetItemIndex()
      {
         var index = _itemIndex.Value; // fast-path (may be stale)

         if (index >= 0)
            return index;

         _ = Items;
         return _itemIndex.ReadVolatile();
      }

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes an action depending on the current item.
      /// </summary>
      /// <param name="item1">The action to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The action to execute if the current item is equal to <see cref="Item2"/>.</param>
      /// <param name="item3">The action to execute if the current item is equal to <see cref="Item3"/>.</param>
      /// <param name="item4">The action to execute if the current item is equal to <see cref="Item4"/>.</param>
      /// <param name="item5">The action to execute if the current item is equal to <see cref="Item5"/>.</param>
      /// <param name="item6">The action to execute if the current item is equal to <see cref="Item6"/>.</param>
      /// <param name="item7">The action to execute if the current item is equal to <see cref="Item7"/>.</param>
      /// <param name="item8">The action to execute if the current item is equal to <see cref="Item8"/>.</param>
      /// <param name="item9">The action to execute if the current item is equal to <see cref="Item9"/>.</param>
      /// <param name="item10">The action to execute if the current item is equal to <see cref="Item10"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public void Switch(
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item1,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item2,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item3,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item4,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item5,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item6,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item7,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item8,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item9,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action @item10)
      {
         switch (GetItemIndex())
         {
            case 0:
               @item1();
               return;
            case 1:
               @item2();
               return;
            case 2:
               @item3();
               return;
            case 3:
               @item4();
               return;
            case 4:
               @item5();
               return;
            case 5:
               @item6();
               return;
            case 6:
               @item7();
               return;
            case 7:
               @item8();
               return;
            case 8:
               @item9();
               return;
            case 9:
               @item10();
               return;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes an action depending on the current item.
      /// </summary>
      /// <param name="state">State to be passed to the callbacks.</param>
      /// <param name="item1">The action to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The action to execute if the current item is equal to <see cref="Item2"/>.</param>
      /// <param name="item3">The action to execute if the current item is equal to <see cref="Item3"/>.</param>
      /// <param name="item4">The action to execute if the current item is equal to <see cref="Item4"/>.</param>
      /// <param name="item5">The action to execute if the current item is equal to <see cref="Item5"/>.</param>
      /// <param name="item6">The action to execute if the current item is equal to <see cref="Item6"/>.</param>
      /// <param name="item7">The action to execute if the current item is equal to <see cref="Item7"/>.</param>
      /// <param name="item8">The action to execute if the current item is equal to <see cref="Item8"/>.</param>
      /// <param name="item9">The action to execute if the current item is equal to <see cref="Item9"/>.</param>
      /// <param name="item10">The action to execute if the current item is equal to <see cref="Item10"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public void Switch<TState>(
         TState @state,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item1,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item2,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item3,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item4,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item5,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item6,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item7,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item8,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item9,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState> @item10)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               @item1(@state);
               return;
            case 1:
               @item2(@state);
               return;
            case 2:
               @item3(@state);
               return;
            case 3:
               @item4(@state);
               return;
            case 4:
               @item5(@state);
               return;
            case 5:
               @item6(@state);
               return;
            case 6:
               @item7(@state);
               return;
            case 7:
               @item8(@state);
               return;
            case 8:
               @item9(@state);
               return;
            case 9:
               @item10(@state);
               return;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes a function depending on the current item.
      /// </summary>
      /// <param name="item1">The function to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The function to execute if the current item is equal to <see cref="Item2"/>.</param>
      /// <param name="item3">The function to execute if the current item is equal to <see cref="Item3"/>.</param>
      /// <param name="item4">The function to execute if the current item is equal to <see cref="Item4"/>.</param>
      /// <param name="item5">The function to execute if the current item is equal to <see cref="Item5"/>.</param>
      /// <param name="item6">The function to execute if the current item is equal to <see cref="Item6"/>.</param>
      /// <param name="item7">The function to execute if the current item is equal to <see cref="Item7"/>.</param>
      /// <param name="item8">The function to execute if the current item is equal to <see cref="Item8"/>.</param>
      /// <param name="item9">The function to execute if the current item is equal to <see cref="Item9"/>.</param>
      /// <param name="item10">The function to execute if the current item is equal to <see cref="Item10"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult Switch<TResult>(
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item1,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item2,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item3,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item4,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item5,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item6,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item7,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item8,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item9,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TResult> @item10)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               return @item1();
            case 1:
               return @item2();
            case 2:
               return @item3();
            case 3:
               return @item4();
            case 4:
               return @item5();
            case 5:
               return @item6();
            case 6:
               return @item7();
            case 7:
               return @item8();
            case 8:
               return @item9();
            case 9:
               return @item10();
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
      /// <summary>
      /// Executes a function depending on the current item.
      /// </summary>
      /// <param name="state">State to be passed to the callbacks.</param>
      /// <param name="item1">The function to execute if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The function to execute if the current item is equal to <see cref="Item2"/>.</param>
      /// <param name="item3">The function to execute if the current item is equal to <see cref="Item3"/>.</param>
      /// <param name="item4">The function to execute if the current item is equal to <see cref="Item4"/>.</param>
      /// <param name="item5">The function to execute if the current item is equal to <see cref="Item5"/>.</param>
      /// <param name="item6">The function to execute if the current item is equal to <see cref="Item6"/>.</param>
      /// <param name="item7">The function to execute if the current item is equal to <see cref="Item7"/>.</param>
      /// <param name="item8">The function to execute if the current item is equal to <see cref="Item8"/>.</param>
      /// <param name="item9">The function to execute if the current item is equal to <see cref="Item9"/>.</param>
      /// <param name="item10">The function to execute if the current item is equal to <see cref="Item10"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult Switch<TState, TResult>(
         TState @state,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item1,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item2,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item3,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item4,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item5,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item6,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item7,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item8,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item9,
         [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, TResult> @item10)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
		   where TState : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               return @item1(@state);
            case 1:
               return @item2(@state);
            case 2:
               return @item3(@state);
            case 3:
               return @item4(@state);
            case 4:
               return @item5(@state);
            case 5:
               return @item6(@state);
            case 6:
               return @item7(@state);
            case 7:
               return @item8(@state);
            case 8:
               return @item9(@state);
            case 9:
               return @item10(@state);
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

      /// <summary>
      /// Maps an item to an instance of type <typeparamref name="TResult"/>.
      /// </summary>
      /// <param name="item1">The instance to return if the current item is equal to <see cref="Item1"/>.</param>
      /// <param name="item2">The instance to return if the current item is equal to <see cref="Item2"/>.</param>
      /// <param name="item3">The instance to return if the current item is equal to <see cref="Item3"/>.</param>
      /// <param name="item4">The instance to return if the current item is equal to <see cref="Item4"/>.</param>
      /// <param name="item5">The instance to return if the current item is equal to <see cref="Item5"/>.</param>
      /// <param name="item6">The instance to return if the current item is equal to <see cref="Item6"/>.</param>
      /// <param name="item7">The instance to return if the current item is equal to <see cref="Item7"/>.</param>
      /// <param name="item8">The instance to return if the current item is equal to <see cref="Item8"/>.</param>
      /// <param name="item9">The instance to return if the current item is equal to <see cref="Item9"/>.</param>
      /// <param name="item10">The instance to return if the current item is equal to <see cref="Item10"/>.</param>
      [global::System.Diagnostics.DebuggerStepThroughAttribute]
      public TResult Map<TResult>(
         TResult @item1,
         TResult @item2,
         TResult @item3,
         TResult @item4,
         TResult @item5,
         TResult @item6,
         TResult @item7,
         TResult @item8,
         TResult @item9,
         TResult @item10)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
#endif
      {
         switch (GetItemIndex())
         {
            case 0:
               return @item1;
            case 1:
               return @item2;
            case 2:
               return @item3;
            case 3:
               return @item4;
            case 4:
               return @item5;
            case 5:
               return @item6;
            case 6:
               return @item7;
            case 7:
               return @item8;
            case 8:
               return @item9;
            case 9:
               return @item10;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }

      private static Lookups GetLookups()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<int, global::Thinktecture.Tests.TestEnum>(10);
         var list = new global::System.Collections.Generic.List<global::Thinktecture.Tests.TestEnum>(10);

         void AddItem(global::Thinktecture.Tests.TestEnum item, string itemName)
         {
            if (item is null)
               throw new global::System.ArgumentNullException($"The item \"{itemName}\" of type \"TestEnum\" must not be null.");

            if (lookup.ContainsKey(item.Key))
               throw new global::System.ArgumentException($"The type \"TestEnum\" has multiple items with the identifier \"{item.Key}\".");

            lookup.Add(item.Key, item);
            item._itemIndex.Set(list.Count);
            list.Add(item);
         }

         AddItem(@Item1, nameof(@Item1));
         AddItem(@Item2, nameof(@Item2));
         AddItem(@Item3, nameof(@Item3));
         AddItem(@Item4, nameof(@Item4));
         AddItem(@Item5, nameof(@Item5));
         AddItem(@Item6, nameof(@Item6));
         AddItem(@Item7, nameof(@Item7));
         AddItem(@Item8, nameof(@Item8));
         AddItem(@Item9, nameof(@Item9));
         AddItem(@Item10, nameof(@Item10));

#if NET8_0_OR_GREATER
         var frozenDictionary = global::System.Collections.Frozen.FrozenDictionary.ToFrozenDictionary(lookup);
         return new Lookups(frozenDictionary, list.AsReadOnly());
#else
         return new Lookups(lookup, list.AsReadOnly());
#endif
      }

      private readonly record struct Lookups(
         global::System.Collections.Generic.IReadOnlyDictionary<int, global::Thinktecture.Tests.TestEnum> Lookup,
         global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests.TestEnum> List);
   }
}
