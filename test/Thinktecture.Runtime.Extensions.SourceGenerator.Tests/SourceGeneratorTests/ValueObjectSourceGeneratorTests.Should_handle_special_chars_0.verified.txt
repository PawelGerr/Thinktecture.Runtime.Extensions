// <auto-generated />
#nullable enable

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests._1TestValueObject, int, global::Thinktecture.ValidationError>))]
   sealed partial class _1TestValueObject : global::System.IEquatable<global::Thinktecture.Tests._1TestValueObject?>,
      global::Thinktecture.IKeyedValueObject<int>,
      global::Thinktecture.IValueObjectConvertible<int>,
      global::Thinktecture.IValueObjectFactory<global::Thinktecture.Tests._1TestValueObject, int, global::Thinktecture.ValidationError>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         global::System.Func<int, global::Thinktecture.Tests._1TestValueObject> convertFromKey = new (global::Thinktecture.Tests._1TestValueObject.Create);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests._1TestValueObject>> convertFromKeyExpression = static @_1Key => global::Thinktecture.Tests._1TestValueObject.Create(@_1Key);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests._1TestValueObject>> convertFromKeyExpressionViaCtor = static @_1Key => new global::Thinktecture.Tests._1TestValueObject(@_1Key);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests._1TestValueObject, int>(static item => item._1Key);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests._1TestValueObject, int>> convertToKeyExpression = static obj => obj._1Key;

         var type = typeof(global::Thinktecture.Tests._1TestValueObject);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(type, typeof(int), false, false, convertFromKey, convertFromKeyExpression, convertFromKeyExpressionViaCtor, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(type, metadata);
      }

      private static readonly int _typeHashCode = typeof(global::Thinktecture.Tests._1TestValueObject).GetHashCode();

      /// <summary>
      /// The identifier of this object.
      /// </summary>
      private readonly int _1Key;

      public static global::Thinktecture.ValidationError? Validate(int @_1Key, global::System.IFormatProvider? @provider, out global::Thinktecture.Tests._1TestValueObject? obj)
      {
         global::Thinktecture.ValidationError? validationError = null;
         ValidateFactoryArguments(ref validationError, ref @_1Key);

         if (validationError is null)
         {
            obj = new global::Thinktecture.Tests._1TestValueObject(@_1Key);
            obj.FactoryPostInit();
         }
         else
         {
            obj = default;
         }

         return validationError;
      }

      public static global::Thinktecture.Tests._1TestValueObject Create(int @_1Key)
      {
         var validationError = Validate(@_1Key, null, out global::Thinktecture.Tests._1TestValueObject? obj);

         if (validationError is not null)
            throw new global::System.ComponentModel.DataAnnotations.ValidationException(validationError.ToString() ?? "Validation failed.");

         return obj!;
      }

      public static bool TryCreate(int @_1Key, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests._1TestValueObject? obj)
      {
         return TryCreate(@_1Key, out obj, out _);
      }

      public static bool TryCreate(
         int @_1Key,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out global::Thinktecture.Tests._1TestValueObject? obj,
         [global::System.Diagnostics.CodeAnalysis.NotNullWhen(false)] out global::Thinktecture.ValidationError? validationError)
      {
         validationError = Validate(@_1Key, null, out obj);

         return validationError is null;
      }

      static partial void ValidateFactoryArguments(ref global::Thinktecture.ValidationError? validationError, ref int @_1Key);

      partial void FactoryPostInit();

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      int global::Thinktecture.IValueObjectConvertible<int>.ToValue()
      {
         return this._1Key;
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="_1Key"/> of provided <paramref name="obj"/> or <c>default</c> if <paramref name="obj"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static implicit operator int?(global::Thinktecture.Tests._1TestValueObject? obj)
      {
         return obj?._1Key;
      }

      /// <summary>
      /// Explicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="obj">Object to covert.</param>
      /// <returns>The <see cref="_1Key"/> of provided <paramref name="obj"/>.</returns>
      /// <exception cref="System.NullReferenceException">If <paramref name="obj"/> is <c>null</c>.</exception>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("obj")]
      public static explicit operator int(global::Thinktecture.Tests._1TestValueObject obj)
      {
         if(obj is null)
            throw new global::System.NullReferenceException();

         return obj._1Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="int"/>.
      /// </summary>
      /// <param name="_1Key">Value to covert.</param>
      /// <returns>An instance of <see cref="_1TestValueObject"/>.</returns>
      public static explicit operator global::Thinktecture.Tests._1TestValueObject(int @_1Key)
      {
         return global::Thinktecture.Tests._1TestValueObject.Create(@_1Key);
      }

      private _1TestValueObject(int @_1Key)
      {
         ValidateConstructorArguments(ref @_1Key);

         this._1Key = @_1Key;
      }

      static partial void ValidateConstructorArguments(ref int @_1Key);

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests._1TestValueObject obj && Equals(obj);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests._1TestValueObject? other)
      {
         if (other is null)
            return false;

         if (global::System.Object.ReferenceEquals(this, other))
            return true;

         return this._1Key.Equals(other._1Key);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return global::System.HashCode.Combine(_typeHashCode, this._1Key);
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this._1Key.ToString();
      }
   }
}
