// <auto-generated />
#nullable enable

namespace Thinktecture.Tests
{
   [global::System.ComponentModel.TypeConverter(typeof(global::Thinktecture.ValueObjectTypeConverter<global::Thinktecture.Tests._1TestEnum, int, global::Thinktecture.ValidationError>))]
   sealed partial class _1TestEnum : global::Thinktecture.IEnum<int, global::Thinktecture.Tests._1TestEnum, global::Thinktecture.ValidationError>,
      global::System.IEquatable<global::Thinktecture.Tests._1TestEnum?>
   {
      [global::System.Runtime.CompilerServices.ModuleInitializer]
      internal static void ModuleInit()
      {
         var convertFromKey = new global::System.Func<int, global::Thinktecture.Tests._1TestEnum?>(global::Thinktecture.Tests._1TestEnum.Get);
         global::System.Linq.Expressions.Expression<global::System.Func<int, global::Thinktecture.Tests._1TestEnum?>> convertFromKeyExpression = static @_1Key => global::Thinktecture.Tests._1TestEnum.Get(@_1Key);

         var convertToKey = new global::System.Func<global::Thinktecture.Tests._1TestEnum, int>(static item => item._1Key);
         global::System.Linq.Expressions.Expression<global::System.Func<global::Thinktecture.Tests._1TestEnum, int>> convertToKeyExpression = static item => item._1Key;

         var enumType = typeof(global::Thinktecture.Tests._1TestEnum);
         var metadata = new global::Thinktecture.Internal.KeyedValueObjectMetadata(enumType, typeof(int), true, false, convertFromKey, convertFromKeyExpression, null, convertToKey, convertToKeyExpression);

         global::Thinktecture.Internal.KeyedValueObjectMetadataLookup.AddMetadata(enumType, metadata);
      }

      private static readonly global::System.Lazy<Lookups> _lookups = new global::System.Lazy<Lookups>(GetLookups, global::System.Threading.LazyThreadSafetyMode.PublicationOnly);

      /// <summary>
      /// Gets all valid items.
      /// </summary>
      public static global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests._1TestEnum> Items => _lookups.Value.List;

      /// <summary>
      /// The identifier of this item.
      /// </summary>
      public int _1Key { get; }

      private readonly int _hashCode;
      private readonly global::System.Lazy<int> _itemIndex;

      private _1TestEnum(
         int @_1Key)
      {
         ValidateConstructorArguments(
            ref @_1Key);

         this._1Key = @_1Key;
         this._hashCode = global::System.HashCode.Combine(typeof(global::Thinktecture.Tests._1TestEnum), @_1Key.GetHashCode());
         this._itemIndex = new global::System.Lazy<int>(() =>
                                                        {
                                                           for (var i = 0; i < Items.Count; i++)
                                                           {
                                                              if (this == Items[i])
                                                                 return i;
                                                           }

                                                           throw new global::System.Exception($"Current item '{@_1Key}' not found in 'Items'.");
                                                        }, global::System.Threading.LazyThreadSafetyMode.PublicationOnly);
      }

      static partial void ValidateConstructorArguments(
         ref int @_1Key);

      /// <summary>
      /// Gets the identifier of the item.
      /// </summary>
      [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
      int global::Thinktecture.IValueObjectConvertible<int>.ToValue()
      {
         return this._1Key;
      }

      /// <summary>
      /// Gets an enumeration item for provided <paramref name="_1Key"/>.
      /// </summary>
      /// <param name="_1Key">The identifier to return an enumeration item for.</param>
      /// <returns>An instance of <see cref="_1TestEnum"/> if <paramref name="_1Key"/> is not <c>null</c>; otherwise <c>null</c>.</returns>
      /// <exception cref="Thinktecture.UnknownEnumIdentifierException">If there is no item with the provided <paramref name="_1Key"/>.</exception>
      public static global::Thinktecture.Tests._1TestEnum Get(int @_1Key)
      {
         if (!_lookups.Value.Lookup.TryGetValue(@_1Key, out var item))
         {
            throw new global::Thinktecture.UnknownEnumIdentifierException(typeof(global::Thinktecture.Tests._1TestEnum), @_1Key);
         }

         return item;
      }

      /// <summary>
      /// Gets a valid enumeration item for provided <paramref name="_1Key"/> if a valid item exists.
      /// </summary>
      /// <param name="_1Key">The identifier to return an enumeration item for.</param>
      /// <param name="item">An instance of <see cref="_1TestEnum"/>.</param>
      /// <returns><c>true</c> if a valid item with provided <paramref name="_1Key"/> exists; <c>false</c> otherwise.</returns>
      public static bool TryGet([global::System.Diagnostics.CodeAnalysis.AllowNull] int @_1Key, [global::System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out global::Thinktecture.Tests._1TestEnum item)
      {
         return _lookups.Value.Lookup.TryGetValue(@_1Key, out item);
      }

      /// <summary>
      /// Validates the provided <paramref name="_1Key"/> and returns a valid enumeration item if found.
      /// </summary>
      /// <param name="_1Key">The identifier to return an enumeration item for.</param>
      /// <param name="provider">An object that provides culture-specific formatting information.</param>
      /// <param name="item">An instance of <see cref="_1TestEnum"/>.</param>
      /// <returns><c>null</c> if a valid item with provided <paramref name="_1Key"/> exists; <see cref="global::Thinktecture.ValidationError"/> with an error message otherwise.</returns>
      public static global::Thinktecture.ValidationError? Validate([global::System.Diagnostics.CodeAnalysis.AllowNull] int @_1Key, global::System.IFormatProvider? @provider, [global::System.Diagnostics.CodeAnalysis.MaybeNull] out global::Thinktecture.Tests._1TestEnum item)
      {
         if(global::Thinktecture.Tests._1TestEnum.TryGet(@_1Key, out item))
         {
            return null;
         }
         else
         {
            return global::Thinktecture.Internal.ValidationErrorCreator.CreateValidationError<global::Thinktecture.ValidationError>($"There is no item of type '_1TestEnum' with the identifier '{@_1Key}'.");
         }
      }

      /// <summary>
      /// Implicit conversion to the type <see cref="int"/>.
      /// </summary>
      /// <param name="item">Item to covert.</param>
      /// <returns>The <see cref="_1TestEnum._1Key"/> of provided <paramref name="item"/> or <c>default</c> if <paramref name="item"/> is <c>null</c>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("item")]
      public static implicit operator int(global::Thinktecture.Tests._1TestEnum? item)
      {
         return item is null ? default : item._1Key;
      }

      /// <summary>
      /// Explicit conversion from the type <see cref="int"/>.
      /// </summary>
      /// <param name="_1Key">Value to covert.</param>
      /// <returns>An instance of <see cref="_1TestEnum"/> if the <paramref name="_1Key"/> is a known item or implements <see cref="Thinktecture.IValidatableEnum"/>.</returns>
      [return: global::System.Diagnostics.CodeAnalysis.NotNullIfNotNull("_1Key")]
      public static explicit operator global::Thinktecture.Tests._1TestEnum?(int @_1Key)
      {
         return global::Thinktecture.Tests._1TestEnum.Get(@_1Key);
      }

      /// <inheritdoc />
      public bool Equals(global::Thinktecture.Tests._1TestEnum? other)
      {
         return global::System.Object.ReferenceEquals(this, other);
      }

      /// <inheritdoc />
      public override bool Equals(object? other)
      {
         return other is global::Thinktecture.Tests._1TestEnum item && Equals(item);
      }

      /// <inheritdoc />
      public override int GetHashCode()
      {
         return _hashCode;
      }

      /// <inheritdoc />
      public override string ToString()
      {
         return this._1Key.ToString();
      }

      /// <summary>
      /// Executes an action depending on the current item.
      /// </summary>
      /// <param name="_1Item1">The action to execute if the current item is equal to <see cref="_1Item1"/>.</param>
      public void Switch(
         global::System.Action @_1Item1)
      {
         switch (_itemIndex.Value)
         {
            case 0:
               @_1Item1();
               return;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }

      /// <summary>
      /// Executes an action depending on the current item.
      /// </summary>
      /// <param name="state">State to be passed to the callbacks.</param>
      /// <param name="_1Item1">The action to execute if the current item is equal to <see cref="_1Item1"/>.</param>
      public void Switch<TState>(
         TState @state,
         global::System.Action<TState> @_1Item1)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
      {
         switch (_itemIndex.Value)
         {
            case 0:
               @_1Item1(@state);
               return;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }

      /// <summary>
      /// Executes a function depending on the current item.
      /// </summary>
      /// <param name="_1Item1">The function to execute if the current item is equal to <see cref="_1Item1"/>.</param>
      public TResult Switch<TResult>(
         global::System.Func<TResult> @_1Item1)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
#endif
      {
         switch (_itemIndex.Value)
         {
            case 0:
               return @_1Item1();
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }

      /// <summary>
      /// Executes a function depending on the current item.
      /// </summary>
      /// <param name="state">State to be passed to the callbacks.</param>
      /// <param name="_1Item1">The function to execute if the current item is equal to <see cref="_1Item1"/>.</param>
      public TResult Switch<TState, TResult>(
         TState @state,
         global::System.Func<TState, TResult> @_1Item1)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
		   where TState : allows ref struct
#endif
      {
         switch (_itemIndex.Value)
         {
            case 0:
               return @_1Item1(@state);
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }

      /// <summary>
      /// Maps an item to an instance of type <typeparamref name="TResult"/>.
      /// </summary>
      /// <param name="_1Item1">The instance to return if the current item is equal to <see cref="_1Item1"/>.</param>
      public TResult Map<TResult>(
         TResult @_1Item1)
#if NET9_0_OR_GREATER
		   where TResult : allows ref struct
#endif
      {
         switch (_itemIndex.Value)
         {
            case 0:
               return @_1Item1;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unknown item '{this}'.");
         }
      }

      private static Lookups GetLookups()
      {
         var lookup = new global::System.Collections.Generic.Dictionary<int, global::Thinktecture.Tests._1TestEnum>(1);
         var list = new global::System.Collections.Generic.List<global::Thinktecture.Tests._1TestEnum>(1);

         void AddItem(global::Thinktecture.Tests._1TestEnum item, string itemName)
         {
            if (item is null)
               throw new global::System.ArgumentNullException($"The item \"{itemName}\" of type \"_1TestEnum\" must not be null.");

            if (lookup.ContainsKey(item._1Key))
               throw new global::System.ArgumentException($"The type \"_1TestEnum\" has multiple items with the identifier \"{item._1Key}\".");

            lookup.Add(item._1Key, item);
            list.Add(item);
         }

         AddItem(@_1Item1, nameof(@_1Item1));

#if NET8_0_OR_GREATER
         var frozenDictionary = global::System.Collections.Frozen.FrozenDictionary.ToFrozenDictionary(lookup);
         return new Lookups(frozenDictionary, list.AsReadOnly());
#else
         return new Lookups(lookup, list.AsReadOnly());
#endif
      }

      private readonly record struct Lookups(
         global::System.Collections.Generic.IReadOnlyDictionary<int, global::Thinktecture.Tests._1TestEnum> Lookup,
         global::System.Collections.Generic.IReadOnlyList<global::Thinktecture.Tests._1TestEnum> List);
   }
}
