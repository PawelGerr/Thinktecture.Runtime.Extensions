// <auto-generated />
#nullable enable

namespace Thinktecture.Tests;

[global::System.Diagnostics.CodeAnalysis.SuppressMessage("ThinktectureRuntimeExtensionsAnalyzer", "TTRESG1000:Internal Thinktecture.Runtime.Extensions API usage")]
abstract partial class Response :
   global::Thinktecture.Internal.IMetadataOwner
{
   static global::Thinktecture.Internal.Metadata global::Thinktecture.Internal.IMetadataOwner.Metadata { get; }
      = new global::Thinktecture.Internal.Metadata.RegularUnion(typeof(global::Thinktecture.Tests.Response))
      {
         TypeMembers = new global::System.Collections.Generic.List<global::System.Type>
                       {
                           typeof(global::Thinktecture.Tests.Response.Success),
                           typeof(global::Thinktecture.Tests.Response.ErrorCategory),
                           typeof(global::Thinktecture.Tests.Response.ErrorCategory.ClientError),
                           typeof(global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest),
                           typeof(global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound),
                           typeof(global::Thinktecture.Tests.Response.ErrorCategory.ServerError),
                           typeof(global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError),
                           typeof(global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable)
                       }
                       .AsReadOnly()
      };

   private Response()
   {
   }

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="errorCategoryServerErrorServiceUnavailable">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable"/>.</param>
   /// <param name="errorCategoryServerErrorInternalError">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError"/>.</param>
   /// <param name="errorCategoryClientErrorNotFound">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound"/>.</param>
   /// <param name="errorCategoryClientErrorBadRequest">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest"/>.</param>
   /// <param name="success">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch(
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable> @errorCategoryServerErrorServiceUnavailable,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError> @errorCategoryServerErrorInternalError,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound> @errorCategoryClientErrorNotFound,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest> @errorCategoryClientErrorBadRequest,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.Response.Success> @success)
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable value:
            @errorCategoryServerErrorServiceUnavailable(value);
            return;
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError value:
            @errorCategoryServerErrorInternalError(value);
            return;
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound value:
            @errorCategoryClientErrorNotFound(value);
            return;
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest value:
            @errorCategoryClientErrorBadRequest(value);
            return;
         case global::Thinktecture.Tests.Response.Success value:
            @success(value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="errorCategoryServerErrorServiceUnavailable">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable"/>.</param>
   /// <param name="errorCategoryServerErrorInternalError">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError"/>.</param>
   /// <param name="errorCategoryClientErrorNotFound">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound"/>.</param>
   /// <param name="errorCategoryClientErrorBadRequest">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest"/>.</param>
   /// <param name="success">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch<TState>(
      TState @state,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable> @errorCategoryServerErrorServiceUnavailable,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError> @errorCategoryServerErrorInternalError,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound> @errorCategoryClientErrorNotFound,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest> @errorCategoryClientErrorBadRequest,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.Response.Success> @success)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable value:
            @errorCategoryServerErrorServiceUnavailable(@state, value);
            return;
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError value:
            @errorCategoryServerErrorInternalError(@state, value);
            return;
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound value:
            @errorCategoryClientErrorNotFound(@state, value);
            return;
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest value:
            @errorCategoryClientErrorBadRequest(@state, value);
            return;
         case global::Thinktecture.Tests.Response.Success value:
            @success(@state, value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="errorCategoryServerErrorServiceUnavailable">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable"/>.</param>
   /// <param name="errorCategoryServerErrorInternalError">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError"/>.</param>
   /// <param name="errorCategoryClientErrorNotFound">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound"/>.</param>
   /// <param name="errorCategoryClientErrorBadRequest">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest"/>.</param>
   /// <param name="success">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TResult>(
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable, TResult> @errorCategoryServerErrorServiceUnavailable,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError, TResult> @errorCategoryServerErrorInternalError,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound, TResult> @errorCategoryClientErrorNotFound,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest, TResult> @errorCategoryClientErrorBadRequest,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.Response.Success, TResult> @success)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable value:
            return @errorCategoryServerErrorServiceUnavailable(value);
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError value:
            return @errorCategoryServerErrorInternalError(value);
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound value:
            return @errorCategoryClientErrorNotFound(value);
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest value:
            return @errorCategoryClientErrorBadRequest(value);
         case global::Thinktecture.Tests.Response.Success value:
            return @success(value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="errorCategoryServerErrorServiceUnavailable">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable"/>.</param>
   /// <param name="errorCategoryServerErrorInternalError">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError"/>.</param>
   /// <param name="errorCategoryClientErrorNotFound">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound"/>.</param>
   /// <param name="errorCategoryClientErrorBadRequest">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest"/>.</param>
   /// <param name="success">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TState, TResult>(
      TState @state,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable, TResult> @errorCategoryServerErrorServiceUnavailable,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError, TResult> @errorCategoryServerErrorInternalError,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound, TResult> @errorCategoryClientErrorNotFound,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest, TResult> @errorCategoryClientErrorBadRequest,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.Response.Success, TResult> @success)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable value:
            return @errorCategoryServerErrorServiceUnavailable(@state, value);
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError value:
            return @errorCategoryServerErrorInternalError(@state, value);
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound value:
            return @errorCategoryClientErrorNotFound(@state, value);
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest value:
            return @errorCategoryClientErrorBadRequest(@state, value);
         case global::Thinktecture.Tests.Response.Success value:
            return @success(@state, value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0108 // Map in nested union hides Map from base class
   /// <summary>
   /// Maps current instance to an instance of type <typeparamref name="TResult"/>.
   /// </summary>
   /// <param name="errorCategoryServerErrorServiceUnavailable">The instance to return if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable"/>.</param>
   /// <param name="errorCategoryServerErrorInternalError">The instance to return if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError"/>.</param>
   /// <param name="errorCategoryClientErrorNotFound">The instance to return if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound"/>.</param>
   /// <param name="errorCategoryClientErrorBadRequest">The instance to return if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest"/>.</param>
   /// <param name="success">The instance to return if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Map<TResult>(
      TResult @errorCategoryServerErrorServiceUnavailable,
      TResult @errorCategoryServerErrorInternalError,
      TResult @errorCategoryClientErrorNotFound,
      TResult @errorCategoryClientErrorBadRequest,
      TResult @success)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.ServiceUnavailable value:
               return @errorCategoryServerErrorServiceUnavailable;
         case global::Thinktecture.Tests.Response.ErrorCategory.ServerError.InternalError value:
               return @errorCategoryServerErrorInternalError;
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.NotFound value:
               return @errorCategoryClientErrorNotFound;
         case global::Thinktecture.Tests.Response.ErrorCategory.ClientError.BadRequest value:
               return @errorCategoryClientErrorBadRequest;
         case global::Thinktecture.Tests.Response.Success value:
               return @success;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
         }
   }
#pragma warning restore CS0108 // Map in nested union hides Map from base class

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="success">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   /// <param name="errorCategory">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch(
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.Response.Success> @success,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.Response.ErrorCategory> @errorCategory)
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.Success value:
            @success(value);
            return;
         case global::Thinktecture.Tests.Response.ErrorCategory value:
            @errorCategory(value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="success">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   /// <param name="errorCategory">The action to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch<TState>(
      TState @state,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.Response.Success> @success,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.Response.ErrorCategory> @errorCategory)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.Success value:
            @success(@state, value);
            return;
         case global::Thinktecture.Tests.Response.ErrorCategory value:
            @errorCategory(@state, value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="success">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   /// <param name="errorCategory">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TResult>(
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.Response.Success, TResult> @success,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.Response.ErrorCategory, TResult> @errorCategory)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.Success value:
            return @success(value);
         case global::Thinktecture.Tests.Response.ErrorCategory value:
            return @errorCategory(value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="success">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   /// <param name="errorCategory">The function to execute if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TState, TResult>(
      TState @state,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.Response.Success, TResult> @success,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.Response.ErrorCategory, TResult> @errorCategory)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.Success value:
            return @success(@state, value);
         case global::Thinktecture.Tests.Response.ErrorCategory value:
            return @errorCategory(@state, value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0108 // Map in nested union hides Map from base class
   /// <summary>
   /// Maps current instance to an instance of type <typeparamref name="TResult"/>.
   /// </summary>
   /// <param name="success">The instance to return if the current type is <see cref="global::Thinktecture.Tests.Response.Success"/>.</param>
   /// <param name="errorCategory">The instance to return if the current type is <see cref="global::Thinktecture.Tests.Response.ErrorCategory"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Map<TResult>(
      TResult @success,
      TResult @errorCategory)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.Response.Success value:
               return @success;
         case global::Thinktecture.Tests.Response.ErrorCategory value:
               return @errorCategory;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
         }
   }
#pragma warning restore CS0108 // Map in nested union hides Map from base class
}
