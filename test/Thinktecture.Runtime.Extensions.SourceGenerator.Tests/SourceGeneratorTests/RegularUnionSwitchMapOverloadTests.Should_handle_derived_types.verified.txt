// <auto-generated />
#nullable enable

namespace Thinktecture.Tests;

[global::System.Diagnostics.CodeAnalysis.SuppressMessage("ThinktectureRuntimeExtensionsAnalyzer", "TTRESG1000:Internal Thinktecture.Runtime.Extensions API usage")]
abstract partial class PlaceId :
   global::Thinktecture.Internal.IMetadataOwner
{
   static global::Thinktecture.Internal.Metadata global::Thinktecture.Internal.IMetadataOwner.Metadata { get; }
      = new global::Thinktecture.Internal.Metadata.RegularUnion(typeof(global::Thinktecture.Tests.PlaceId))
      {
         TypeMembers = new global::System.Collections.Generic.List<global::System.Type>
                       {
                           typeof(global::Thinktecture.Tests.PlaceId.Unknown),
                           typeof(global::Thinktecture.Tests.PlaceId.CountryId),
                           typeof(global::Thinktecture.Tests.PlaceId.AbstractRegionId),
                           typeof(global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId),
                           typeof(global::Thinktecture.Tests.PlaceId.RegionId),
                           typeof(global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId),
                           typeof(global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId)
                       }
                       .AsReadOnly()
      };

   private PlaceId()
   {
   }

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="regionIdInnerRegionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch(
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId> @regionIdInnerRegionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId> @abstractRegionIdSpecialRegionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.Unknown> @unknown,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.CountryId> @countryId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.RegionId> @regionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId> @regionIdInnerPlaceId)
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
            @regionIdInnerRegionId(value);
            return;
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
            @abstractRegionIdSpecialRegionId(value);
            return;
         case global::Thinktecture.Tests.PlaceId.Unknown value:
            @unknown(value);
            return;
         case global::Thinktecture.Tests.PlaceId.CountryId value:
            @countryId(value);
            return;
         case global::Thinktecture.Tests.PlaceId.RegionId value:
            @regionId(value);
            return;
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
            @regionIdInnerPlaceId(value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="default">The action to execute if no type-specific action is provided.</param>
   /// <param name="regionIdInnerRegionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void SwitchPartially(
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId>? @default = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId>? @regionIdInnerRegionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId>? @abstractRegionIdSpecialRegionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.Unknown>? @unknown = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.CountryId>? @countryId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.RegionId>? @regionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId>? @regionIdInnerPlaceId = null)
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
            if (@regionIdInnerRegionId is not null)
            {
               @regionIdInnerRegionId(value);
               return;
            }

            if (@regionId is not null)
            {
               @regionId(value);
               return;
            }
            break;
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
            if (@abstractRegionIdSpecialRegionId is not null)
            {
               @abstractRegionIdSpecialRegionId(value);
               return;
            }

            break;
         case global::Thinktecture.Tests.PlaceId.Unknown value:
            if (@unknown is not null)
            {
               @unknown(value);
               return;
            }

            break;
         case global::Thinktecture.Tests.PlaceId.CountryId value:
            if (@countryId is not null)
            {
               @countryId(value);
               return;
            }

            break;
         case global::Thinktecture.Tests.PlaceId.RegionId value:
            if (@regionId is not null)
            {
               @regionId(value);
               return;
            }

            break;
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
            if (@regionIdInnerPlaceId is not null)
            {
               @regionIdInnerPlaceId(value);
               return;
            }

            break;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      @default?.Invoke(this);
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="regionIdInnerRegionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void Switch<TState>(
      TState @state,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId> @regionIdInnerRegionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId> @abstractRegionIdSpecialRegionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.Unknown> @unknown,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.CountryId> @countryId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.RegionId> @regionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId> @regionIdInnerPlaceId)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
            @regionIdInnerRegionId(@state, value);
            return;
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
            @abstractRegionIdSpecialRegionId(@state, value);
            return;
         case global::Thinktecture.Tests.PlaceId.Unknown value:
            @unknown(@state, value);
            return;
         case global::Thinktecture.Tests.PlaceId.CountryId value:
            @countryId(@state, value);
            return;
         case global::Thinktecture.Tests.PlaceId.RegionId value:
            @regionId(@state, value);
            return;
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
            @regionIdInnerPlaceId(@state, value);
            return;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes an action depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="default">The action to execute if no type-specific action is provided.</param>
   /// <param name="regionIdInnerRegionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The action to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public void SwitchPartially<TState>(
      TState @state,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId>? @default = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId>? @regionIdInnerRegionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId>? @abstractRegionIdSpecialRegionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.Unknown>? @unknown = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.CountryId>? @countryId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.RegionId>? @regionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Action<TState, global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId>? @regionIdInnerPlaceId = null)
#if NET9_0_OR_GREATER
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
            if (@regionIdInnerRegionId is not null)
            {
               @regionIdInnerRegionId(@state, value);
               return;
            }

            if (@regionId is not null)
            {
               @regionId(@state, value);
               return;
            }
            break;
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
            if (@abstractRegionIdSpecialRegionId is not null)
            {
               @abstractRegionIdSpecialRegionId(@state, value);
               return;
            }

            break;
         case global::Thinktecture.Tests.PlaceId.Unknown value:
            if (@unknown is not null)
            {
               @unknown(@state, value);
               return;
            }

            break;
         case global::Thinktecture.Tests.PlaceId.CountryId value:
            if (@countryId is not null)
            {
               @countryId(@state, value);
               return;
            }

            break;
         case global::Thinktecture.Tests.PlaceId.RegionId value:
            if (@regionId is not null)
            {
               @regionId(@state, value);
               return;
            }

            break;
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
            if (@regionIdInnerPlaceId is not null)
            {
               @regionIdInnerPlaceId(@state, value);
               return;
            }

            break;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      @default?.Invoke(@state, this);
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="regionIdInnerRegionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TResult>(
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId, TResult> @regionIdInnerRegionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId, TResult> @abstractRegionIdSpecialRegionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.Unknown, TResult> @unknown,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.CountryId, TResult> @countryId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.RegionId, TResult> @regionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId, TResult> @regionIdInnerPlaceId)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
            return @regionIdInnerRegionId(value);
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
            return @abstractRegionIdSpecialRegionId(value);
         case global::Thinktecture.Tests.PlaceId.Unknown value:
            return @unknown(value);
         case global::Thinktecture.Tests.PlaceId.CountryId value:
            return @countryId(value);
         case global::Thinktecture.Tests.PlaceId.RegionId value:
            return @regionId(value);
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
            return @regionIdInnerPlaceId(value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="default">The function to execute if no type-specific action is provided.</param>
   /// <param name="regionIdInnerRegionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult SwitchPartially<TResult>(
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId, TResult> @default,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId, TResult>? @regionIdInnerRegionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId, TResult>? @abstractRegionIdSpecialRegionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.Unknown, TResult>? @unknown = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.CountryId, TResult>? @countryId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.RegionId, TResult>? @regionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId, TResult>? @regionIdInnerPlaceId = null)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
            if (@regionIdInnerRegionId is not null)
            {
               return @regionIdInnerRegionId(value);
            }

            if (@regionId is not null)
            {
               return @regionId(value);
            }
            break;
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
            if (@abstractRegionIdSpecialRegionId is not null)
            {
               return @abstractRegionIdSpecialRegionId(value);
            }

            break;
         case global::Thinktecture.Tests.PlaceId.Unknown value:
            if (@unknown is not null)
            {
               return @unknown(value);
            }

            break;
         case global::Thinktecture.Tests.PlaceId.CountryId value:
            if (@countryId is not null)
            {
               return @countryId(value);
            }

            break;
         case global::Thinktecture.Tests.PlaceId.RegionId value:
            if (@regionId is not null)
            {
               return @regionId(value);
            }

            break;
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
            if (@regionIdInnerPlaceId is not null)
            {
               return @regionIdInnerPlaceId(value);
            }

            break;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      return @default(this);
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="regionIdInnerRegionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Switch<TState, TResult>(
      TState @state,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId, TResult> @regionIdInnerRegionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId, TResult> @abstractRegionIdSpecialRegionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.Unknown, TResult> @unknown,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.CountryId, TResult> @countryId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.RegionId, TResult> @regionId,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId, TResult> @regionIdInnerPlaceId)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
            return @regionIdInnerRegionId(@state, value);
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
            return @abstractRegionIdSpecialRegionId(@state, value);
         case global::Thinktecture.Tests.PlaceId.Unknown value:
            return @unknown(@state, value);
         case global::Thinktecture.Tests.PlaceId.CountryId value:
            return @countryId(@state, value);
         case global::Thinktecture.Tests.PlaceId.RegionId value:
            return @regionId(@state, value);
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
            return @regionIdInnerPlaceId(@state, value);
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0436 // InstantHandleAttribute may come from a different assembly
   /// <summary>
   /// Executes a function depending on the current type.
   /// </summary>
   /// <param name="state">State to be passed to the callbacks.</param>
   /// <param name="default">The function to execute if no type-specific action is provided.</param>
   /// <param name="regionIdInnerRegionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The function to execute if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult SwitchPartially<TState, TResult>(
      TState @state,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId, TResult> @default,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId, TResult>? @regionIdInnerRegionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId, TResult>? @abstractRegionIdSpecialRegionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.Unknown, TResult>? @unknown = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.CountryId, TResult>? @countryId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.RegionId, TResult>? @regionId = null,
      [global::JetBrains.Annotations.InstantHandleAttribute] global::System.Func<TState, global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId, TResult>? @regionIdInnerPlaceId = null)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
		where TState : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
            if (@regionIdInnerRegionId is not null)
            {
               return @regionIdInnerRegionId(@state, value);
            }

            if (@regionId is not null)
            {
               return @regionId(@state, value);
            }
            break;
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
            if (@abstractRegionIdSpecialRegionId is not null)
            {
               return @abstractRegionIdSpecialRegionId(@state, value);
            }

            break;
         case global::Thinktecture.Tests.PlaceId.Unknown value:
            if (@unknown is not null)
            {
               return @unknown(@state, value);
            }

            break;
         case global::Thinktecture.Tests.PlaceId.CountryId value:
            if (@countryId is not null)
            {
               return @countryId(@state, value);
            }

            break;
         case global::Thinktecture.Tests.PlaceId.RegionId value:
            if (@regionId is not null)
            {
               return @regionId(@state, value);
            }

            break;
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
            if (@regionIdInnerPlaceId is not null)
            {
               return @regionIdInnerPlaceId(@state, value);
            }

            break;
         default:
            throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
      }

      return @default(@state, this);
   }
#pragma warning restore CS0436 // InstantHandleAttribute may come from a different assembly

#pragma warning disable CS0108 // Map in nested union hides Map from base class
   /// <summary>
   /// Maps current instance to an instance of type <typeparamref name="TResult"/>.
   /// </summary>
   /// <param name="regionIdInnerRegionId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult Map<TResult>(
      TResult @regionIdInnerRegionId,
      TResult @abstractRegionIdSpecialRegionId,
      TResult @unknown,
      TResult @countryId,
      TResult @regionId,
      TResult @regionIdInnerPlaceId)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
               return @regionIdInnerRegionId;
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
               return @abstractRegionIdSpecialRegionId;
         case global::Thinktecture.Tests.PlaceId.Unknown value:
               return @unknown;
         case global::Thinktecture.Tests.PlaceId.CountryId value:
               return @countryId;
         case global::Thinktecture.Tests.PlaceId.RegionId value:
               return @regionId;
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
               return @regionIdInnerPlaceId;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
         }
   }
#pragma warning restore CS0108 // Map in nested union hides Map from base class

#pragma warning disable CS0108 // Map in nested union hides Map from base class
   /// <summary>
   /// Maps current instance to an instance of type <typeparamref name="TResult"/>.
   /// </summary>
   /// <param name="default">The instance to return if no value is provided for the current type.</param>
   /// <param name="regionIdInnerRegionId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId"/>.</param>
   /// <param name="abstractRegionIdSpecialRegionId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId"/>.</param>
   /// <param name="unknown">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.Unknown"/>.</param>
   /// <param name="countryId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.CountryId"/>.</param>
   /// <param name="regionId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId"/>.</param>
   /// <param name="regionIdInnerPlaceId">The instance to return if the current type is <see cref="global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId"/>.</param>
   [global::System.Diagnostics.DebuggerStepThroughAttribute]
   public TResult MapPartially<TResult>(
      TResult @default,
      global::Thinktecture.Argument<TResult> @regionIdInnerRegionId = default,
      global::Thinktecture.Argument<TResult> @abstractRegionIdSpecialRegionId = default,
      global::Thinktecture.Argument<TResult> @unknown = default,
      global::Thinktecture.Argument<TResult> @countryId = default,
      global::Thinktecture.Argument<TResult> @regionId = default,
      global::Thinktecture.Argument<TResult> @regionIdInnerPlaceId = default)
#if NET9_0_OR_GREATER
		where TResult : allows ref struct
#endif
   {
      switch (this)
      {
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerRegionId value:
               if (@regionIdInnerRegionId.IsSet)
               {
                  return @regionIdInnerRegionId.Value;
               }

               if (@regionId.IsSet)
               {
                  return @regionId.Value;
               }
               break;
         case global::Thinktecture.Tests.PlaceId.AbstractRegionId.SpecialRegionId value:
               if (@abstractRegionIdSpecialRegionId.IsSet)
               {
                  return @abstractRegionIdSpecialRegionId.Value;
               }

               break;
         case global::Thinktecture.Tests.PlaceId.Unknown value:
               if (@unknown.IsSet)
               {
                  return @unknown.Value;
               }

               break;
         case global::Thinktecture.Tests.PlaceId.CountryId value:
               if (@countryId.IsSet)
               {
                  return @countryId.Value;
               }

               break;
         case global::Thinktecture.Tests.PlaceId.RegionId value:
               if (@regionId.IsSet)
               {
                  return @regionId.Value;
               }

               break;
         case global::Thinktecture.Tests.PlaceId.RegionId.InnerPlaceId value:
               if (@regionIdInnerPlaceId.IsSet)
               {
                  return @regionIdInnerPlaceId.Value;
               }

               break;
            default:
               throw new global::System.ArgumentOutOfRangeException($"Unexpected type '{this.GetType().FullName}'.");
         }

         return @default;
   }
#pragma warning restore CS0108 // Map in nested union hides Map from base class
}
