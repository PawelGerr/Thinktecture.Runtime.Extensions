using MessagePack;
using Thinktecture.CodeAnalysis;
using Thinktecture.Formatters;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class MessagePackValueObjectSourceGeneratorTests : SourceGeneratorTestsBase
{
   public MessagePackValueObjectSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<MessagePackValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial class TestValueObject
   {
      public class ValueObjectMessagePackFormatter : Thinktecture.Formatters.ValueObjectMessagePackFormatter<TestValueObject, string>
      {
         public ValueObjectMessagePackFormatter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_for_keyed_value_object_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
   public readonly string ReferenceField;
}
";
      var output = GetGeneratedOutput<MessagePackValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial class TestValueObject
   {
      public class ValueObjectMessagePackFormatter : Thinktecture.Formatters.ValueObjectMessagePackFormatter<TestValueObject, string>
      {
         public ValueObjectMessagePackFormatter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_struct_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<MessagePackValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial struct TestValueObject
   {
      public class ValueObjectMessagePackFormatter : Thinktecture.Formatters.ValueObjectMessagePackFormatter<TestValueObject, string>
      {
         public ValueObjectMessagePackFormatter()
            : base(TestValueObject.Create, static obj => obj.ReferenceField)
         {
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<MessagePackValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using MessagePack;
using MessagePack.Formatters;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial class TestValueObject
   {
      public class ValueObjectMessagePackFormatter : MessagePack.Formatters.IMessagePackFormatter<TestValueObject?>
      {
         /// <inheritdoc />
         public TestValueObject? Deserialize(ref MessagePack.MessagePackReader reader, MessagePack.MessagePackSerializerOptions options)
         {
            if (reader.TryReadNil())
               return default;

            var count = reader.ReadArrayHeader();

            if (count != 3)
               throw new MessagePack.MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

            MessagePack.IFormatterResolver resolver = options.Resolver;
            options.Security.DepthStep(ref reader);

            try
            {

               var referenceField = reader.ReadString()!;
               var structProperty = reader.ReadInt32()!;
               var nullableStructProperty = resolver.GetFormatterWithVerify<decimal?>().Deserialize(ref reader, options)!;

               var validationResult = TestValueObject.TryCreate(
                                          referenceField,
                                          structProperty,
                                          nullableStructProperty,
                                          out var obj);

               if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
                  throw new MessagePack.MessagePackSerializationException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

               return obj;
            }
            finally
            {
              reader.Depth--;
            }
         }

         /// <inheritdoc />
         public void Serialize(ref MessagePack.MessagePackWriter writer, TestValueObject? value, MessagePack.MessagePackSerializerOptions options)
         {
            if(value is null)
            {
               writer.WriteNil();
               return;
            }

            writer.WriteArrayHeader(3);

            var resolver = options.Resolver;
            writer.Write(value.ReferenceField);
            writer.Write(value.StructProperty);
            resolver.GetFormatterWithVerify<decimal?>().Serialize(ref writer, value.NullableStructProperty, options);
         }
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_for_non_key_value_object_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
   public readonly string ReferenceField;
   public int StructProperty { get; }
   public decimal? NullableStructProperty { get; }
}
";
      var output = GetGeneratedOutput<MessagePackValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using MessagePack;
using MessagePack.Formatters;
using Thinktecture;

   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial class TestValueObject
   {
      public class ValueObjectMessagePackFormatter : MessagePack.Formatters.IMessagePackFormatter<TestValueObject?>
      {
         /// <inheritdoc />
         public TestValueObject? Deserialize(ref MessagePack.MessagePackReader reader, MessagePack.MessagePackSerializerOptions options)
         {
            if (reader.TryReadNil())
               return default;

            var count = reader.ReadArrayHeader();

            if (count != 3)
               throw new MessagePack.MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

            MessagePack.IFormatterResolver resolver = options.Resolver;
            options.Security.DepthStep(ref reader);

            try
            {

               var referenceField = reader.ReadString()!;
               var structProperty = reader.ReadInt32()!;
               var nullableStructProperty = resolver.GetFormatterWithVerify<decimal?>().Deserialize(ref reader, options)!;

               var validationResult = TestValueObject.TryCreate(
                                          referenceField,
                                          structProperty,
                                          nullableStructProperty,
                                          out var obj);

               if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
                  throw new MessagePack.MessagePackSerializationException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

               return obj;
            }
            finally
            {
              reader.Depth--;
            }
         }

         /// <inheritdoc />
         public void Serialize(ref MessagePack.MessagePackWriter writer, TestValueObject? value, MessagePack.MessagePackSerializerOptions options)
         {
            if(value is null)
            {
               writer.WriteNil();
               return;
            }

            writer.WriteArrayHeader(3);

            var resolver = options.Resolver;
            writer.Write(value.ReferenceField);
            writer.Write(value.StructProperty);
            resolver.GetFormatterWithVerify<decimal?>().Serialize(ref writer, value.NullableStructProperty, options);
         }
      }
   }
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<MessagePackValueObjectSourceGenerator>(source, typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.ComponentModel.DataAnnotations;
using System.Reflection;
using MessagePack;
using MessagePack.Formatters;
using Thinktecture;

namespace Thinktecture.Tests
{
   [MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
   partial struct TestValueObject
   {
      public class ValueObjectMessagePackFormatter : MessagePack.Formatters.IMessagePackFormatter<TestValueObject>
      {
         /// <inheritdoc />
         public TestValueObject Deserialize(ref MessagePack.MessagePackReader reader, MessagePack.MessagePackSerializerOptions options)
         {
            if (reader.TryReadNil())
               return default;

            var count = reader.ReadArrayHeader();

            if (count != 3)
               throw new MessagePack.MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

            MessagePack.IFormatterResolver resolver = options.Resolver;
            options.Security.DepthStep(ref reader);

            try
            {

               var referenceField = reader.ReadString()!;
               var structProperty = reader.ReadInt32()!;
               var nullableStructProperty = resolver.GetFormatterWithVerify<decimal?>().Deserialize(ref reader, options)!;

               var validationResult = TestValueObject.TryCreate(
                                          referenceField,
                                          structProperty,
                                          nullableStructProperty,
                                          out var obj);

               if (validationResult != System.ComponentModel.DataAnnotations.ValidationResult.Success)
                  throw new MessagePack.MessagePackSerializationException($""Unable to deserialize 'TestValueObject'. Error: {validationResult!.ErrorMessage}."");

               return obj;
            }
            finally
            {
              reader.Depth--;
            }
         }

         /// <inheritdoc />
         public void Serialize(ref MessagePack.MessagePackWriter writer, TestValueObject value, MessagePack.MessagePackSerializerOptions options)
         {
            writer.WriteArrayHeader(3);

            var resolver = options.Resolver;
            writer.Write(value.ReferenceField);
            writer.Write(value.StructProperty);
            resolver.GetFormatterWithVerify<decimal?>().Serialize(ref writer, value.NullableStructProperty, options);
         }
      }
   }
}
");
   }
}
