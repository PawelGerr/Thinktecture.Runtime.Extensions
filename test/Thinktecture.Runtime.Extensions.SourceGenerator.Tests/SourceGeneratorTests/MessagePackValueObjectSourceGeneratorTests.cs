using MessagePack;
using Thinktecture.CodeAnalysis.ValueObjects;
using Thinktecture.Formatters;
using Xunit.Abstractions;

namespace Thinktecture.Runtime.Tests.SourceGeneratorTests;

public class MessagePackValueObjectSourceGeneratorTests : SourceGeneratorTestsBase
{
   public MessagePackValueObjectSourceGeneratorTests(ITestOutputHelper output)
      : base(output)
   {
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source,
                                                                  ".MessagePack",
                                                                  typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, """
// <auto-generated />
#nullable enable

namespace Thinktecture.Tests;

[global::MessagePack.MessagePackFormatter(typeof(global::Thinktecture.Formatters.ValueObjectMessagePackFormatter<global::Thinktecture.Tests.TestValueObject, string>))]
partial class TestValueObject
{
}

""");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_for_keyed_value_object_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
   public readonly string ReferenceField;
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source,
                                                                  ".MessagePack",
                                                                  typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, """
// <auto-generated />
#nullable enable

[global::MessagePack.MessagePackFormatter(typeof(global::Thinktecture.Formatters.ValueObjectMessagePackFormatter<global::TestValueObject, string>))]
partial class TestValueObject
{
}

""");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_struct_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source,
                                                                  ".MessagePack",
                                                                  typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, """
// <auto-generated />
#nullable enable

namespace Thinktecture.Tests;

[global::MessagePack.MessagePackFormatter(typeof(global::Thinktecture.Formatters.StructValueObjectMessagePackFormatter<global::Thinktecture.Tests.TestValueObject, string>))]
partial struct TestValueObject
{
}

""");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public partial class TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source,
                                                                  ".MessagePack",
                                                                  typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

namespace Thinktecture.Tests;

[global::MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
partial class TestValueObject
{
   public sealed class ValueObjectMessagePackFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Thinktecture.Tests.TestValueObject?>
   {
      /// <inheritdoc />
      public global::Thinktecture.Tests.TestValueObject? Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
      {
         if (reader.TryReadNil())
            return default;

         var count = reader.ReadArrayHeader();

         if (count != 3)
            throw new global::MessagePack.MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

         global::MessagePack.IFormatterResolver resolver = options.Resolver;
         options.Security.DepthStep(ref reader);

         try
         {

            var referenceField = reader.ReadString()!;
            var structProperty = reader.ReadInt32()!;
            var nullableStructProperty = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<decimal?>(resolver).Deserialize(ref reader, options)!;

            var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(
                                       referenceField,
                                       structProperty,
                                       nullableStructProperty,
                                       out var obj);

            if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
               throw new global::MessagePack.MessagePackSerializationException($""Unable to deserialize \""TestValueObject\"". Error: {validationResult!.ErrorMessage}."");

            return obj;
         }
         finally
         {
           reader.Depth--;
         }
      }

      /// <inheritdoc />
      public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Thinktecture.Tests.TestValueObject? value, global::MessagePack.MessagePackSerializerOptions options)
      {
         if(value is null)
         {
            writer.WriteNil();
            return;
         }

         writer.WriteArrayHeader(3);

         var resolver = options.Resolver;
         writer.Write(value.ReferenceField);
         writer.Write(value.StructProperty);
         global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<decimal?>(resolver).Serialize(ref writer, value.NullableStructProperty, options);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_for_non_key_value_object_without_namespace()
   {
      var source = @"
using System;
using Thinktecture;

[ValueObject]
public partial class TestValueObject
{
   public readonly string ReferenceField;
   public int StructProperty { get; }
   public decimal? NullableStructProperty { get; }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source,
                                                                  ".MessagePack",
                                                                  typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

[global::MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
partial class TestValueObject
{
   public sealed class ValueObjectMessagePackFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::TestValueObject?>
   {
      /// <inheritdoc />
      public global::TestValueObject? Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
      {
         if (reader.TryReadNil())
            return default;

         var count = reader.ReadArrayHeader();

         if (count != 3)
            throw new global::MessagePack.MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

         global::MessagePack.IFormatterResolver resolver = options.Resolver;
         options.Security.DepthStep(ref reader);

         try
         {

            var referenceField = reader.ReadString()!;
            var structProperty = reader.ReadInt32()!;
            var nullableStructProperty = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<decimal?>(resolver).Deserialize(ref reader, options)!;

            var validationResult = global::TestValueObject.Validate(
                                       referenceField,
                                       structProperty,
                                       nullableStructProperty,
                                       out var obj);

            if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
               throw new global::MessagePack.MessagePackSerializationException($""Unable to deserialize \""TestValueObject\"". Error: {validationResult!.ErrorMessage}."");

            return obj;
         }
         finally
         {
           reader.Depth--;
         }
      }

      /// <inheritdoc />
      public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::TestValueObject? value, global::MessagePack.MessagePackSerializerOptions options)
      {
         if(value is null)
         {
            writer.WriteNil();
            return;
         }

         writer.WriteArrayHeader(3);

         var resolver = options.Resolver;
         writer.Write(value.ReferenceField);
         writer.Write(value.StructProperty);
         global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<decimal?>(resolver).Serialize(ref writer, value.NullableStructProperty, options);
      }
   }
}
");
   }

   [Fact]
   public void Should_generate_MessagePackFormatter_and_Attribute_for_struct_for_non_key_value_type_if_Attribute_is_missing()
   {
      var source = @"
using System;
using Thinktecture;

namespace Thinktecture.Tests
{
   [ValueObject]
	public readonly partial struct TestValueObject
	{
      public readonly string ReferenceField;
      public int StructProperty { get; }
      public decimal? NullableStructProperty { get; }
   }
}
";
      var output = GetGeneratedOutput<ValueObjectSourceGenerator>(source,
                                                                  ".MessagePack",
                                                                  typeof(ValueObjectAttribute).Assembly, typeof(ValueObjectMessagePackFormatter<,>).Assembly, typeof(MessagePackFormatterAttribute).Assembly);

      AssertOutput(output, @"// <auto-generated />
#nullable enable

namespace Thinktecture.Tests;

[global::MessagePack.MessagePackFormatter(typeof(ValueObjectMessagePackFormatter))]
partial struct TestValueObject
{
   public sealed class ValueObjectMessagePackFormatter : global::MessagePack.Formatters.IMessagePackFormatter<global::Thinktecture.Tests.TestValueObject>
   {
      /// <inheritdoc />
      public global::Thinktecture.Tests.TestValueObject Deserialize(ref global::MessagePack.MessagePackReader reader, global::MessagePack.MessagePackSerializerOptions options)
      {
         if (reader.TryReadNil())
            return default;

         var count = reader.ReadArrayHeader();

         if (count != 3)
            throw new global::MessagePack.MessagePackSerializationException($""Invalid member count. Expected 3 but found {count} field/property values."");

         global::MessagePack.IFormatterResolver resolver = options.Resolver;
         options.Security.DepthStep(ref reader);

         try
         {

            var referenceField = reader.ReadString()!;
            var structProperty = reader.ReadInt32()!;
            var nullableStructProperty = global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<decimal?>(resolver).Deserialize(ref reader, options)!;

            var validationResult = global::Thinktecture.Tests.TestValueObject.Validate(
                                       referenceField,
                                       structProperty,
                                       nullableStructProperty,
                                       out var obj);

            if (validationResult != global::System.ComponentModel.DataAnnotations.ValidationResult.Success)
               throw new global::MessagePack.MessagePackSerializationException($""Unable to deserialize \""TestValueObject\"". Error: {validationResult!.ErrorMessage}."");

            return obj;
         }
         finally
         {
           reader.Depth--;
         }
      }

      /// <inheritdoc />
      public void Serialize(ref global::MessagePack.MessagePackWriter writer, global::Thinktecture.Tests.TestValueObject value, global::MessagePack.MessagePackSerializerOptions options)
      {
         writer.WriteArrayHeader(3);

         var resolver = options.Resolver;
         writer.Write(value.ReferenceField);
         writer.Write(value.StructProperty);
         global::MessagePack.FormatterResolverExtensions.GetFormatterWithVerify<decimal?>(resolver).Serialize(ref writer, value.NullableStructProperty, options);
      }
   }
}
");
   }
}
